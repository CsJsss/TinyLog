--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./build/AsynLog
Data file:        Asyn_cachegrind.out.3807557
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr            ILmr           Dr                     D1mr            DLmr            Dw                     D1mw               DLmw               
--------------------------------------------------------------------------------
15,643,589,555 (100.0%) 39,543 (100.0%) 6,273 (100.0%) 4,113,211,160 (100.0%) 50,087 (100.0%) 32,114 (100.0%) 3,086,794,373 (100.0%) 6,930,377 (100.0%) 6,911,375 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr         Dr                   D1mr            DLmr            Dw                   D1mw               DLmw                file:function
--------------------------------------------------------------------------------
2,297,131,637 (14.68%) 2,123 ( 5.37%) 214 ( 3.41%) 609,603,032 (14.82%)    347 ( 0.69%)    106 ( 0.33%) 389,975,496 (12.63%)       760 ( 0.01%)       279 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/vfprintf-internal.c:__vfprintf_internal
1,280,000,000 ( 8.18%)    12 ( 0.03%)   8 ( 0.13%) 520,000,000 (12.64%)     30 ( 0.06%)     14 ( 0.04%) 280,000,000 ( 9.07%)        49 ( 0.00%)        11 ( 0.00%)  /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long)
1,263,925,189 ( 8.08%)    27 ( 0.07%)  20 ( 0.32%) 239,516,743 ( 5.82%)    212 ( 0.42%)      6 ( 0.02%) 198,735,894 ( 6.44%)       269 ( 0.00%)        80 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_default_xsputn
  713,319,381 ( 4.56%)    67 ( 0.17%)  32 ( 0.51%) 153,317,563 ( 3.73%) 21,001 (41.93%) 20,841 (64.90%) 105,317,455 ( 3.41%) 6,920,884 (99.86%) 6,907,173 (99.94%)  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  650,073,480 ( 4.16%)   263 ( 0.67%)   9 ( 0.14%)  47,576,831 ( 1.16%)     21 ( 0.04%)      8 ( 0.02%)  39,575,754 ( 1.28%)         8 ( 0.00%)         3 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/_itoa.c:_itoa_word
  640,000,040 ( 4.09%)     2 ( 0.01%)   0          192,000,008 ( 4.67%)     77 ( 0.15%)     23 ( 0.07%)  64,000,016 ( 2.07%)         2 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:__tls_init
  516,000,000 ( 3.30%)   758 ( 1.92%)  58 ( 0.92%)  64,000,000 ( 1.56%)    262 ( 0.52%)     78 ( 0.24%) 196,000,000 ( 6.35%)        39 ( 0.00%)         7 ( 0.00%)  /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...)
  512,000,000 ( 3.27%)     1 ( 0.00%)   0          192,000,000 ( 4.67%)     27 ( 0.05%)      8 ( 0.02%) 128,000,000 ( 4.15%)         0                  0           ???:TLS wrapper function for TinyLog::buffer
  484,000,000 ( 3.09%)     2 ( 0.01%)   2 ( 0.03%) 176,000,000 ( 4.28%)      8 ( 0.02%)      1 ( 0.00%)  88,000,000 ( 2.85%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::avail() const
  456,010,659 ( 2.92%)   262 ( 0.66%)   6 ( 0.10%) 104,002,431 ( 2.53%)     48 ( 0.10%)     12 ( 0.04%) 120,002,805 ( 3.89%)       165 ( 0.00%)        54 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/vsnprintf.c:__vsnprintf_internal
  455,200,046 ( 2.91%)    52 ( 0.13%)  25 ( 0.40%)  32,000,003 ( 0.78%)     52 ( 0.10%)     16 ( 0.05%)           0                  0                  0           /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strrchr-avx2.S:__strrchr_avx2
  373,628,360 ( 2.39%)    11 ( 0.03%)   8 ( 0.13%)  36,002,528 ( 0.88%)     74 ( 0.15%)     31 ( 0.10%)           0                  0                  0           /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strchr-avx2.S:__strchrnul_avx2
  328,014,469 ( 2.10%)    49 ( 0.12%)  26 ( 0.41%)  48,002,196 ( 1.17%)      4 ( 0.01%)      0           88,004,205 ( 2.85%)        42 ( 0.00%)        16 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/strops.c:_IO_str_init_static_internal
  272,000,000 ( 1.74%)   134 ( 0.34%)   5 ( 0.08%) 128,000,000 ( 3.11%)      0               0           72,000,000 ( 2.33%)         1 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul])
  248,005,340 ( 1.59%)    18 ( 0.05%)  14 ( 0.22%)  36,001,424 ( 0.88%)     90 ( 0.18%)     28 ( 0.09%)  52,001,068 ( 1.68%)         7 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::formatTime()
  216,009,631 ( 1.38%)   174 ( 0.44%)   2 ( 0.03%)  56,002,591 ( 1.36%)      1 ( 0.00%)      1 ( 0.00%)  48,002,221 ( 1.56%)       213 ( 0.00%)        44 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_setb
  212,007,540 ( 1.36%)   747 ( 1.89%)  34 ( 0.54%)  52,001,762 ( 1.26%)     57 ( 0.11%)     20 ( 0.06%)  56,001,532 ( 1.81%)         2 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::append(char const*, unsigned long)
  192,012,407 ( 1.23%) 1,180 ( 2.98%) 491 ( 7.83%)  96,005,767 ( 2.33%)  1,085 ( 2.17%)    185 ( 0.58%)         606 ( 0.00%)        24 ( 0.00%)        14 ( 0.00%)  ???:???
  184,008,478 ( 1.18%)     4 ( 0.01%)   4 ( 0.06%)  40,001,840 ( 0.97%)      2 ( 0.00%)      2 ( 0.01%)  64,002,958 ( 2.07%)       332 ( 0.00%)        90 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_no_init
  176,008,100 ( 1.13%)     5 ( 0.01%)   4 ( 0.06%)  24,001,104 ( 0.58%)     20 ( 0.04%)      7 ( 0.02%)  88,004,052 ( 2.85%)       139 ( 0.00%)        48 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_old_init
  160,800,184 ( 1.03%) 1,810 ( 4.58%)  22 ( 0.35%)   5,600,072 ( 0.14%)      8 ( 0.02%)      8 ( 0.02%)  43,200,048 ( 1.40%)        10 ( 0.00%)         8 ( 0.00%)  /home1/jsj/Code/cpp/projects/AsynLog/main.cpp:func()
  144,010,486 ( 0.92%)     6 ( 0.02%)   5 ( 0.08%)  32,004,308 ( 0.78%)      0               0           16,000,374 ( 0.52%)         1 ( 0.00%)         1 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/../libio/libioP.h:__vfprintf_internal
  140,000,000 ( 0.89%)    23 ( 0.06%)   8 ( 0.13%)  32,000,000 ( 0.78%)     28 ( 0.06%)     10 ( 0.03%)  40,000,000 ( 1.30%)         2 ( 0.00%)         1 ( 0.00%)  /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator()(char const*, unsigned long) const
  140,000,000 ( 0.89%)    12 ( 0.03%)   7 ( 0.11%)  36,000,000 ( 0.88%)      5 ( 0.01%)      3 ( 0.01%)  20,000,000 ( 0.65%)         5 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Timestamp.cpp:TinyLog::Timestamp::now()
  128,020,026 ( 0.82%)    17 ( 0.04%)   7 ( 0.11%)   8,002,136 ( 0.19%)      0               0           44,004,673 ( 1.43%)       171 ( 0.00%)        65 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/printf-parse.h:__vfprintf_internal
  128,000,000 ( 0.82%)     2 ( 0.01%)   2 ( 0.03%)  52,000,000 ( 1.26%)      0               0           28,000,000 ( 0.91%)         1 ( 0.00%)         0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::append(char const*, unsigned long)
  120,000,000 ( 0.77%)   181 ( 0.46%)   1 ( 0.02%)  40,000,000 ( 0.97%)     27 ( 0.05%)     10 ( 0.03%)  40,000,000 ( 1.30%)        16 ( 0.00%)         4 ( 0.00%)  /usr/include/c++/9/bits/std_function.h:std::_Function_handler<void (char const*, unsigned long), void (*)(char const*, unsigned long)>::_M_invoke(std::_Any_data const&, char const*&&, unsigned long&&)
  116,000,428 ( 0.74%)   209 ( 0.53%)  16 ( 0.26%)  32,000,126 ( 0.78%)    136 ( 0.27%)     48 ( 0.15%)   8,000,064 ( 0.26%)         2 ( 0.00%)         0           /build/glibc-sMfBJT/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c:pthread_mutex_lock
   96,004,464 ( 0.61%)    63 ( 0.16%)  21 ( 0.33%)  16,000,744 ( 0.39%)     24 ( 0.05%)      6 ( 0.02%)  36,001,674 ( 1.17%)        40 ( 0.00%)        19 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/snprintf.c:snprintf
   92,000,184 ( 0.59%)     2 ( 0.01%)   0           36,000,072 ( 0.88%)     14 ( 0.03%)      2 ( 0.01%)  16,000,032 ( 0.52%)        13 ( 0.00%)         2 ( 0.00%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unlock()
   88,002,563 ( 0.56%)    89 ( 0.23%)  16 ( 0.26%)  32,000,932 ( 0.78%)     67 ( 0.13%)     40 ( 0.12%)  24,000,699 ( 0.78%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_ptr() const
   88,000,176 ( 0.56%)     7 ( 0.02%)   4 ( 0.06%)  36,000,072 ( 0.88%)     20 ( 0.04%)     10 ( 0.03%)  16,000,032 ( 0.52%)        20 ( 0.00%)        10 ( 0.00%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::lock()
   88,000,000 ( 0.56%)   185 ( 0.47%)   4 ( 0.06%)  32,000,000 ( 0.78%)      0               0           28,000,000 ( 0.91%)        78 ( 0.00%)        25 ( 0.00%)  /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul])
   88,000,000 ( 0.56%)     2 ( 0.01%)   2 ( 0.03%)  32,000,000 ( 0.78%)     46 ( 0.09%)     18 ( 0.06%)  16,000,000 ( 0.52%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::avail() const
   84,000,168 ( 0.54%)   285 ( 0.72%)   5 ( 0.08%)  28,000,056 ( 0.68%)      0               0           32,000,064 ( 1.04%)         3 ( 0.00%)         1 ( 0.00%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&)
   80,002,330 ( 0.51%)    39 ( 0.10%)  13 ( 0.21%)  24,000,699 ( 0.58%)      0               0           24,000,699 ( 0.78%)        16 ( 0.00%)         4 ( 0.00%)  /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_head(std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&)
   80,002,330 ( 0.51%)     3 ( 0.01%)   2 ( 0.03%)  24,000,699 ( 0.58%)      2 ( 0.00%)      0           24,000,699 ( 0.78%)         2 ( 0.00%)         0           /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > >::type const& std::get<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >(std::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&)
   80,002,330 ( 0.51%)     3 ( 0.01%)   2 ( 0.03%)  24,000,699 ( 0.58%)      0               0           24,000,699 ( 0.78%)         0                  0           /usr/include/c++/9/tuple:TinyLog::LogBuffer::FixedBuffer<4194304ul>* const& std::__get_helper<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >(std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&)
   80,002,330 ( 0.51%)     0            0           24,000,699 ( 0.58%)      2 ( 0.00%)      0           24,000,699 ( 0.78%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::get() const
   80,001,460 ( 0.51%)     1 ( 0.00%)   1 ( 0.02%)  24,000,438 ( 0.58%)      1 ( 0.00%)      0           24,000,438 ( 0.78%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const
   80,000,000 ( 0.51%)     0            0           32,000,000 ( 0.78%)     20 ( 0.04%)      7 ( 0.02%)  16,000,000 ( 0.52%)         0                  0           /usr/include/c++/9/bits/std_function.h:std::_Function_base::_M_empty() const
   76,000,431 ( 0.49%)   123 ( 0.31%)  22 ( 0.35%)  24,000,068 ( 0.58%)     15 ( 0.03%)      2 ( 0.01%)   4,000,010 ( 0.13%)         0                  0           /build/glibc-sMfBJT/glibc-2.31/nptl/pthread_mutex_unlock.c:pthread_mutex_unlock
   76,000,013 ( 0.49%)     3 ( 0.01%)   2 ( 0.03%)  32,000,001 ( 0.78%)     21 ( 0.04%)      7 ( 0.02%)  12,000,004 ( 0.39%)         9 ( 0.00%)         8 ( 0.00%)  /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance()
   72,030,762 ( 0.46%)     5 ( 0.01%)   4 ( 0.06%)  24,010,254 ( 0.58%)     21 ( 0.04%)      6 ( 0.02%)   8,003,418 ( 0.26%)         1 ( 0.00%)         1 ( 0.00%)  /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_active_p()
   68,000,000 ( 0.43%)     3 ( 0.01%)   3 ( 0.05%)  16,000,000 ( 0.39%)     27 ( 0.05%)     10 ( 0.03%)  20,000,000 ( 0.65%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/main.cpp:asynOutput(char const*, unsigned long)
   64,000,000 ( 0.41%)    91 ( 0.23%)   1 ( 0.02%)  16,000,000 ( 0.39%)      0               0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::getSeconds()
   64,000,000 ( 0.41%)    21 ( 0.05%)   8 ( 0.13%)  32,000,000 ( 0.78%)      2 ( 0.00%)      0           16,000,000 ( 0.52%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size()
   61,170,996 ( 0.39%)   163 ( 0.41%)   1 ( 0.02%)           0               0               0                    0                  0                  0           /build/glibc-sMfBJT/glibc-2.31/libio/libioP.h:_IO_default_xsputn
   60,000,120 ( 0.38%)   177 ( 0.45%)   1 ( 0.02%)  12,000,024 ( 0.29%)     11 ( 0.02%)      2 ( 0.01%)  16,000,032 ( 0.52%)         3 ( 0.00%)         0           /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_unlock(pthread_mutex_t*)
   60,000,120 ( 0.38%)     4 ( 0.01%)   1 ( 0.02%)  20,000,040 ( 0.49%)      1 ( 0.00%)      0           12,000,024 ( 0.39%)         0                  0           /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock()
   60,000,120 ( 0.38%)     2 ( 0.01%)   1 ( 0.02%)  12,000,024 ( 0.29%)      0               0           16,000,032 ( 0.52%)         0                  0           /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_lock(pthread_mutex_t*)
   60,000,000 ( 0.38%)   278 ( 0.70%)   0           16,000,000 ( 0.39%)      0               0           20,000,000 ( 0.65%)         7 ( 0.00%)         2 ( 0.00%)  /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_get_pointer(std::_Any_data const&)
   56,001,631 ( 0.36%)     2 ( 0.01%)   0           24,000,699 ( 0.58%)      0               0           16,000,466 ( 0.52%)         0                  0           /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, false>::_M_head(std::_Head_base<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, false> const&)
   56,000,112 ( 0.36%)   180 ( 0.46%)   1 ( 0.02%)  16,000,032 ( 0.39%)      0               0           16,000,032 ( 0.52%)        27 ( 0.00%)        12 ( 0.00%)  /usr/include/c++/9/bits/std_mutex.h:std::mutex::lock()
   56,000,000 ( 0.36%)     8 ( 0.02%)   8 ( 0.13%)  24,000,000 ( 0.58%)      0               0           16,000,000 ( 0.52%)         0                  0           /usr/include/c++/9/bits/move.h:unsigned long&& std::forward<unsigned long>(std::remove_reference<unsigned long>::type&)
   56,000,000 ( 0.36%)     1 ( 0.00%)   1 ( 0.02%)  24,000,000 ( 0.58%)      0               0           16,000,000 ( 0.52%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::addLen(unsigned long)
   56,000,000 ( 0.36%)     0            0           24,000,000 ( 0.58%)      0               0           16,000,000 ( 0.52%)         0                  0           /usr/include/c++/9/bits/move.h:char const*&& std::forward<char const*>(std::remove_reference<char const*>::type&)
   44,000,088 ( 0.28%)     1 ( 0.00%)   0           12,000,024 ( 0.29%)      0               0           12,000,024 ( 0.39%)         0                  0           /usr/include/c++/9/bits/std_mutex.h:std::mutex::unlock()
   44,000,022 ( 0.28%)    42 ( 0.11%)  14 ( 0.22%)  16,000,008 ( 0.39%)     20 ( 0.04%)      7 ( 0.02%)  12,000,006 ( 0.39%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::_M_ptr() const
   44,000,000 ( 0.28%)    16 ( 0.04%)  11 ( 0.18%)  16,000,000 ( 0.39%)      0               0           16,000,000 ( 0.52%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::Timestamp(long)
   44,000,000 ( 0.28%)     1 ( 0.00%)   1 ( 0.02%)  12,000,000 ( 0.29%)      1 ( 0.00%)      1 ( 0.00%)  12,000,000 ( 0.39%)         2 ( 0.00%)         1 ( 0.00%)  /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator bool() const
   40,026,110 ( 0.26%)   177 ( 0.45%)   2 ( 0.03%)  12,007,833 ( 0.29%)      0               0           12,007,833 ( 0.39%)         0                  0           /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const
   40,026,110 ( 0.26%)     7 ( 0.02%)   4 ( 0.06%)  12,007,833 ( 0.29%)      0               0           12,007,833 ( 0.39%)         0                  0           /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const
   40,000,020 ( 0.26%)    13 ( 0.03%)   9 ( 0.14%)  12,000,006 ( 0.29%)      1 ( 0.00%)      0           12,000,006 ( 0.39%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::get() const
   40,000,020 ( 0.26%)     9 ( 0.02%)   8 ( 0.13%)  12,000,006 ( 0.29%)      0               0           12,000,006 ( 0.39%)         0                  0           /usr/include/c++/9/tuple:TinyLog::AsynLog* const& std::__get_helper<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&)
   40,000,020 ( 0.26%)     5 ( 0.01%)   3 ( 0.05%)  12,000,006 ( 0.29%)      0               0           12,000,006 ( 0.39%)         5 ( 0.00%)         2 ( 0.00%)  /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >::_M_head(std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&)
   40,000,020 ( 0.26%)     1 ( 0.00%)   1 ( 0.02%)  12,000,006 ( 0.29%)      0               0           12,000,006 ( 0.39%)         5 ( 0.00%)         2 ( 0.00%)  /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > >::type const& std::get<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&)
   40,000,010 ( 0.26%)     2 ( 0.01%)   0           12,000,003 ( 0.29%)      0               0           12,000,003 ( 0.39%)         0                  0           /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::operator->() const
   40,000,000 ( 0.26%)   181 ( 0.46%)   2 ( 0.03%)  12,000,000 ( 0.29%)      0               0           12,000,000 ( 0.39%)         0                  0           /usr/include/c++/9/bits/std_function.h:void (* const&std::_Any_data::_M_access<void (*)(char const*, unsigned long)>() const)(char const*, unsigned long)
   40,000,000 ( 0.26%)     0            0           20,000,000 ( 0.49%)      1 ( 0.00%)      0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::current()
   36,000,000 ( 0.23%)   273 ( 0.69%)   1 ( 0.02%)  12,000,000 ( 0.29%)      0               0           12,000,000 ( 0.39%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::clear()
   32,022,552 ( 0.20%)     5 ( 0.01%)   3 ( 0.05%)  16,011,276 ( 0.39%)    140 ( 0.28%)     24 ( 0.07%)   8,005,638 ( 0.26%)         0                  0           /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::get() const
   32,000,000 ( 0.20%)   287 ( 0.73%)   0           16,000,000 ( 0.39%)      0               0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data()
   32,000,000 ( 0.20%)    90 ( 0.23%)   1 ( 0.02%)   4,000,000 ( 0.10%)      1 ( 0.00%)      0                    0                  0                  0           /build/glibc-sMfBJT/glibc-2.31/time/../sysdeps/unix/sysv/linux/gettimeofday.c:__gettimeofday_syscall
   32,000,000 ( 0.20%)     0            0           16,000,000 ( 0.39%)      0               0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::getMilliSeconds()
   32,000,000 ( 0.20%)     0            0           16,000,000 ( 0.39%)      0               0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::size() const
   28,000,056 ( 0.18%)     7 ( 0.02%)   6 ( 0.10%)  12,000,024 ( 0.29%)      0               0            8,000,016 ( 0.26%)         1 ( 0.00%)         0           /usr/include/c++/9/bits/move.h:std::mutex* std::__addressof<std::mutex>(std::mutex&)
   28,000,014 ( 0.18%)    11 ( 0.03%)   7 ( 0.11%)  12,000,006 ( 0.29%)      0               0            8,000,004 ( 0.26%)         0                  0           /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::AsynLog*, false>::_M_head(std::_Head_base<0ul, TinyLog::AsynLog*, false> const&)
   28,000,000 ( 0.18%)    17 ( 0.04%)   6 ( 0.10%)  12,000,000 ( 0.29%)      0               0            8,000,000 ( 0.26%)        16 ( 0.00%)         5 ( 0.00%)  /usr/include/c++/9/bits/std_function.h:std::_Any_data::_M_access() const
   28,000,000 ( 0.18%)     0            0           12,000,000 ( 0.29%)      1 ( 0.00%)      0            4,000,000 ( 0.13%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTidStr()
   28,000,000 ( 0.18%)     0            0           12,000,000 ( 0.29%)      0               0            8,000,000 ( 0.26%)         0                  0           /usr/include/c++/9/bits/move.h:void (* const*std::__addressof<void (* const)(char const*, unsigned long)>(void (* const&)(char const*, unsigned long)))(char const*, unsigned long)
   28,000,000 ( 0.18%)     0            0           12,000,000 ( 0.29%)      0               0            8,000,000 ( 0.26%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::data() const
   24,000,000 ( 0.15%)   175 ( 0.44%)   5 ( 0.08%)  12,000,000 ( 0.29%)     71 ( 0.14%)     24 ( 0.07%)   4,000,000 ( 0.13%)         0                  0           /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTidStrlen()
   17,078,248 ( 0.11%)   797 ( 2.02%)   6 ( 0.10%)   4,657,704 ( 0.11%)      0               0            3,105,136 ( 0.10%)       179 ( 0.00%)        29 ( 0.00%)  /build/glibc-sMfBJT/glibc-2.31/libio/iopadn.c:_IO_padn
   16,000,160 ( 0.10%)     0            0                    0               0               0                    0                  0                  0           /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__mempcpy_avx_unaligned_erms

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h
--------------------------------------------------------------------------------
Ir                   I1mr         ILmr       Dr                  D1mr       DLmr       Dw                  D1mw        DLmw        

-- line 30 ----------------------------------------
          .            .          .                   .          .          .                   .           .           .           */
          .            .          .                   .          .          .                   .           .           .           class str_const { // constexpr string
          .            .          .                   .          .          .                   .           .           .           private:
          .            .          .                   .          .          .                   .           .           .             const char *p_;
          .            .          .                   .          .          .                   .           .           .             std::size_t sz_;
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .           public:
          .            .          .                   .          .          .                   .           .           .             template <std::size_t N>
132,000,000 ( 0.84%) 150 ( 0.38%) 7 ( 0.11%) 36,000,000 ( 0.88%) 0          0          60,000,000 ( 1.94%) 76 ( 0.00%) 25 ( 0.00%)    constexpr str_const(const char (&a)[N]) : p_(a), sz_(N - 1) {
 72,000,000 ( 0.46%) 169 ( 0.43%) 2 ( 0.03%) 24,000,000 ( 0.58%) 0          0          24,000,000 ( 0.78%)  3 ( 0.00%)  0               const char *idx = strrchr(p_, '/'); // builtin function
 24,000,000 ( 0.15%)   0          0          12,000,000 ( 0.29%) 0          0                   0           0           0               if (idx) {
 32,000,000 ( 0.20%)   0          0          16,000,000 ( 0.39%) 0          0           8,000,000 ( 0.26%)  0           0                 p_ = idx + 1;
 64,000,000 ( 0.41%)   0          0          48,000,000 ( 1.17%) 0          0           8,000,000 ( 0.26%)  0           0                 sz_ -= static_cast<size_t>(p_ - a);
          .            .          .                   .          .          .                   .           .           .               }
 36,000,000 ( 0.23%)   0          0          24,000,000 ( 0.58%) 0          0                   0           0           0             }
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .             constexpr char operator[](std::size_t n) { // []
          .            .          .                   .          .          .                   .           .           .               return n < sz_ ? p_[n] : throw std::out_of_range("");
          .            .          .                   .          .          .                   .           .           .             }
          .            .          .                   .          .          .                   .           .           .           
 64,000,000 ( 0.41%)  21 ( 0.05%) 8 ( 0.13%) 32,000,000 ( 0.78%) 2 ( 0.00%) 0          16,000,000 ( 0.52%)  0           0             constexpr std::size_t size() { return sz_; }
 32,000,000 ( 0.20%) 287 ( 0.73%) 0          16,000,000 ( 0.39%) 0          0           8,000,000 ( 0.26%)  0           0             constexpr const char *data() { return p_; }
          .            .          .                   .          .          .                   .           .           .           };
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .           /* compile-time 将x转换为字符串 */
          .            .          .                   .          .          .                   .           .           .           #define strify_(x) val_(x)
          .            .          .                   .          .          .                   .           .           .           #define val_(x) #x
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .           /* 编译期获取字符串长度宏定义 */
          .            .          .                   .          .          .                   .           .           .           #define getStrLen_(x) TinyLog::str_const(x).size()
-- line 59 ----------------------------------------
-- line 106 ----------------------------------------
          .            .          .                   .          .          .                   .           .           .              *va_list、va_arg和va_end等可变参数相关的宏来处理.
          .            .          .                   .          .          .                   .           .           .              **/
          .            .          .                   .          .          .                   .           .           .             void append(const char *file, size_t fileLen, const char *line,
          .            .          .                   .          .          .                   .           .           .                         size_t lineLen, const char *fmt, Logger::LogLevel level, ...);
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .             /*内部类 用于回收单例Logger资源 */
          .            .          .                   .          .          .                   .           .           .             struct GC {
          .            .          .                   .          .          .                   .           .           .               GC() = default;
          5 ( 0.00%)   0          0                   0          0          0                   2 ( 0.00%)  0           0               ~GC() {
          3 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          1 ( 0.00%) 1 ( 0.00%) 0                   0           0           0                 if (_logger)
          6 ( 0.00%)   0          0                   1 ( 0.00%) 0          0                   1 ( 0.00%)  0           0                   delete _logger;
          3 ( 0.00%)   0          0                   2 ( 0.00%) 0          0                   0           0           0               }
          .            .          .                   .          .          .                   .           .           .             };
          .            .          .                   .          .          .                   .           .           .           
          .            .          .                   .          .          .                   .           .           .           private:
          .            .          .                   .          .          .                   .           .           .             /* Logger 单例变量的声明 */
          .            .          .                   .          .          .                   .           .           .             static Logger *_logger;
          .            .          .                   .          .          .                   .           .           .             static std::mutex _mtx;
          .            .          .                   .          .          .                   .           .           .             Logger() = default;
          .            .          .                   .          .          .                   .           .           .             ~Logger() = default;
-- line 125 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/unique_lock.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                  D1mr        DLmr        Dw                  D1mw        DLmw        

-- line 60 ----------------------------------------
         .            .          .                   .           .           .                   .           .           .               {
         .            .          .                   .           .           .                   .           .           .               public:
         .            .          .                   .           .           .                   .           .           .                 typedef _Mutex mutex_type;
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 unique_lock() noexcept
         .            .          .                   .           .           .                   .           .           .                 : _M_device(0), _M_owns(false)
         .            .          .                   .           .           .                   .           .           .                 { }
         .            .          .                   .           .           .                   .           .           .           
24,000,048 ( 0.15%) 280 ( 0.71%) 1 ( 0.02%)          0           0           0          12,000,024 ( 0.39%)  0           0                 explicit unique_lock(mutex_type& __m)
28,000,056 ( 0.18%)   5 ( 0.01%) 4 ( 0.06%) 12,000,024 ( 0.29%)  0           0          12,000,024 ( 0.39%)  3 ( 0.00%)  1 ( 0.00%)        : _M_device(std::__addressof(__m)), _M_owns(false)
         .            .          .                   .           .           .                   .           .           .                 {
12,000,024 ( 0.08%)   0          0           4,000,008 ( 0.10%)  0           0           4,000,008 ( 0.13%)  0           0           	lock();
 8,000,016 ( 0.05%)   0          0           4,000,008 ( 0.10%)  0           0           4,000,008 ( 0.13%)  0           0           	_M_owns = true;
12,000,024 ( 0.08%)   0          0           8,000,016 ( 0.19%)  0           0                   0           0           0                 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 unique_lock(mutex_type& __m, defer_lock_t) noexcept
         .            .          .                   .           .           .                   .           .           .                 : _M_device(std::__addressof(__m)), _M_owns(false)
         .            .          .                   .           .           .                   .           .           .                 { }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 unique_lock(mutex_type& __m, try_to_lock_t)
         .            .          .                   .           .           .                   .           .           .                 : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())
         .            .          .                   .           .           .                   .           .           .                 { }
-- line 81 ----------------------------------------
-- line 95 ----------------------------------------
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 template<typename _Rep, typename _Period>
         .            .          .                   .           .           .                   .           .           .           	unique_lock(mutex_type& __m,
         .            .          .                   .           .           .                   .           .           .           		    const chrono::duration<_Rep, _Period>& __rtime)
         .            .          .                   .           .           .                   .           .           .           	: _M_device(std::__addressof(__m)),
         .            .          .                   .           .           .                   .           .           .           	  _M_owns(_M_device->try_lock_for(__rtime))
         .            .          .                   .           .           .                   .           .           .           	{ }
         .            .          .                   .           .           .                   .           .           .           
20,000,040 ( 0.13%)   3 ( 0.01%) 1 ( 0.02%)          0           0           0           8,000,016 ( 0.26%)  0           0                 ~unique_lock()
         .            .          .                   .           .           .                   .           .           .                 {
16,000,032 ( 0.10%)   0          0           8,000,016 ( 0.19%)  1 ( 0.00%)  0                   0           0           0           	if (_M_owns)
12,000,024 ( 0.08%)   0          0           4,000,008 ( 0.10%)  0           0           4,000,008 ( 0.13%)  0           0           	  unlock();
12,000,024 ( 0.08%)   1 ( 0.00%) 0           8,000,016 ( 0.19%)  0           0                   0           0           0                 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 unique_lock(const unique_lock&) = delete;
         .            .          .                   .           .           .                   .           .           .                 unique_lock& operator=(const unique_lock&) = delete;
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 unique_lock(unique_lock&& __u) noexcept
         .            .          .                   .           .           .                   .           .           .                 : _M_device(__u._M_device), _M_owns(__u._M_owns)
         .            .          .                   .           .           .                   .           .           .                 {
         .            .          .                   .           .           .                   .           .           .           	__u._M_device = 0;
-- line 115 ----------------------------------------
-- line 125 ----------------------------------------
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .           	__u._M_device = 0;
         .            .          .                   .           .           .                   .           .           .           	__u._M_owns = false;
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .           	return *this;
         .            .          .                   .           .           .                   .           .           .                 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 void
20,000,040 ( 0.13%)   0          0                   0           0           0           8,000,016 ( 0.26%)  0           0                 lock()
         .            .          .                   .           .           .                   .           .           .                 {
16,000,032 ( 0.10%)   4 ( 0.01%) 2 ( 0.03%)  8,000,016 ( 0.19%)  0           0                   0           0           0           	if (!_M_device)
         .            .          .                   .           .           .                   .           .           .           	  __throw_system_error(int(errc::operation_not_permitted));
16,000,032 ( 0.10%)   0          0           8,000,016 ( 0.19%)  0           0                   0           0           0           	else if (_M_owns)
         .            .          .                   .           .           .                   .           .           .           	  __throw_system_error(int(errc::resource_deadlock_would_occur));
         .            .          .                   .           .           .                   .           .           .           	else
         .            .          .                   .           .           .                   .           .           .           	  {
16,000,032 ( 0.10%)   0          0           8,000,016 ( 0.19%)  0           0           4,000,008 ( 0.13%)  0           0           	    _M_device->lock();
 8,000,016 ( 0.05%)   3 ( 0.01%) 2 ( 0.03%)  4,000,008 ( 0.10%)  0           0           4,000,008 ( 0.13%) 20 ( 0.00%) 10 ( 0.00%)  	    _M_owns = true;
         .            .          .                   .           .           .                   .           .           .           	  }
12,000,024 ( 0.08%)   0          0           8,000,016 ( 0.19%) 20 ( 0.04%) 10 ( 0.03%)          0           0           0                 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 bool
         .            .          .                   .           .           .                   .           .           .                 try_lock()
         .            .          .                   .           .           .                   .           .           .                 {
         .            .          .                   .           .           .                   .           .           .           	if (!_M_device)
         .            .          .                   .           .           .                   .           .           .           	  __throw_system_error(int(errc::operation_not_permitted));
         .            .          .                   .           .           .                   .           .           .           	else if (_M_owns)
         .            .          .                   .           .           .                   .           .           .           	  __throw_system_error(int(errc::resource_deadlock_would_occur));
-- line 152 ----------------------------------------
-- line 183 ----------------------------------------
         .            .          .                   .           .           .                   .           .           .           	  else
         .            .          .                   .           .           .                   .           .           .           	    {
         .            .          .                   .           .           .                   .           .           .           	      _M_owns = _M_device->try_lock_for(__rtime);
         .            .          .                   .           .           .                   .           .           .           	      return _M_owns;
         .            .          .                   .           .           .                   .           .           .           	    }
         .            .          .                   .           .           .                   .           .           .           	 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 void
20,000,040 ( 0.13%)   1 ( 0.00%) 0                   0           0           0           8,000,016 ( 0.26%)  0           0                 unlock()
         .            .          .                   .           .           .                   .           .           .                 {
20,000,040 ( 0.13%)   0          0           8,000,016 ( 0.19%)  0           0                   0           0           0           	if (!_M_owns)
         .            .          .                   .           .           .                   .           .           .           	  __throw_system_error(int(errc::operation_not_permitted));
16,000,032 ( 0.10%)   0          0           8,000,016 ( 0.19%)  0           0                   0           0           0           	else if (_M_device)
         .            .          .                   .           .           .                   .           .           .           	  {
16,000,032 ( 0.10%)   1 ( 0.00%) 0           8,000,016 ( 0.19%)  0           0           4,000,008 ( 0.13%)  0           0           	    _M_device->unlock();
 8,000,016 ( 0.05%)   0          0           4,000,008 ( 0.10%)  1 ( 0.00%)  0           4,000,008 ( 0.13%) 13 ( 0.00%)  2 ( 0.00%)  	    _M_owns = false;
         .            .          .                   .           .           .                   .           .           .           	  }
12,000,024 ( 0.08%)   0          0           8,000,016 ( 0.19%) 13 ( 0.03%)  2 ( 0.01%)          0           0           0                 }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 void
         .            .          .                   .           .           .                   .           .           .                 swap(unique_lock& __u) noexcept
         .            .          .                   .           .           .                   .           .           .                 {
         .            .          .                   .           .           .                   .           .           .           	std::swap(_M_device, __u._M_device);
         .            .          .                   .           .           .                   .           .           .           	std::swap(_M_owns, __u._M_owns);
         .            .          .                   .           .           .                   .           .           .                 }
         .            .          .                   .           .           .                   .           .           .           
-- line 208 ----------------------------------------
-- line 218 ----------------------------------------
         .            .          .                   .           .           .                   .           .           .                 bool
         .            .          .                   .           .           .                   .           .           .                 owns_lock() const noexcept
         .            .          .                   .           .           .                   .           .           .                 { return _M_owns; }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 explicit operator bool() const noexcept
         .            .          .                   .           .           .                   .           .           .                 { return owns_lock(); }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .                 mutex_type*
         4 ( 0.00%)   0          0                   0           0           0                   2 ( 0.00%)  0           0                 mutex() const noexcept
         4 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          4 ( 0.00%)  0           0                   0           0           0                 { return _M_device; }
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .               private:
         .            .          .                   .           .           .                   .           .           .                 mutex_type*	_M_device;
         .            .          .                   .           .           .                   .           .           .                 bool		_M_owns;
         .            .          .                   .           .           .                   .           .           .               };
         .            .          .                   .           .           .                   .           .           .           
         .            .          .                   .           .           .                   .           .           .             /// Swap overload for unique_lock objects.
         .            .          .                   .           .           .                   .           .           .             template<typename _Mutex>
-- line 235 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/shared_ptr_base.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr        Dr                  D1mr         DLmr        Dw                 D1mw         DLmw        

-- line 109 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .                 enum { _S_need_barriers = 1 };
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             template<_Lock_policy _Lp = __default_lock_policy>
         .            .           .                   .            .           .                  .            .           .               class _Sp_counted_base
         .            .           .                   .            .           .                  .            .           .               : public _Mutex_base<_Lp>
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .               public:
       356 ( 0.00%)  78 ( 0.20%)  1 ( 0.02%)          0            0           0                178 ( 0.00%)   0           0                 _Sp_counted_base() noexcept
       890 ( 0.00%)   0           0                 445 ( 0.00%)   0           0                267 ( 0.00%)   0           0                 : _M_use_count(1), _M_weak_count(1) { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 virtual
       356 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0                178 ( 0.00%)   0           0                 ~_Sp_counted_base() noexcept
       534 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        267 ( 0.00%)   0           0                 89 ( 0.00%)   0           0                 { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Called when _M_use_count drops to zero, to release the resources
         .            .           .                   .            .           .                  .            .           .                 // managed by *this.
         .            .           .                   .            .           .                  .            .           .                 virtual void
         .            .           .                   .            .           .                  .            .           .                 _M_dispose() noexcept = 0;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Called when _M_weak_count drops to zero.
         .            .           .                   .            .           .                  .            .           .                 virtual void
         .            .           .                   .            .           .                  .            .           .                 _M_destroy() noexcept
         .            .           .                   .            .           .                  .            .           .                 { delete this; }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 virtual void*
         .            .           .                   .            .           .                  .            .           .                 _M_get_deleter(const std::type_info&) noexcept = 0;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
     8,060 ( 0.00%)   1 ( 0.00%)  0                   0            0           0              3,224 ( 0.00%)   0           0                 _M_add_ref_copy()
    12,896 ( 0.00%) 117 ( 0.30%)  1 ( 0.02%)      4,836 ( 0.00%)   0           0              1,612 ( 0.00%)   0           0                 { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
         .            .           .                   .            .           .                  .            .           .                 _M_add_ref_lock();
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 bool
         .            .           .                   .            .           .                  .            .           .                 _M_add_ref_lock_nothrow();
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
     8,505 ( 0.00%) 116 ( 0.29%)  1 ( 0.02%)          0            0           0              3,402 ( 0.00%)   0           0                 _M_release() noexcept
         .            .           .                   .            .           .                  .            .           .                 {
         .            .           .                   .            .           .                  .            .           .                   // Be race-detector-friendly.  For more info see bits/c++config.
         .            .           .                   .            .           .                  .            .           .                   _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
    15,309 ( 0.00%) 115 ( 0.29%)  1 ( 0.02%)      1,701 ( 0.00%)   0           0              1,701 ( 0.00%)   0           0           	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
         .            .           .                   .            .           .                  .            .           .           	  {
         .            .           .                   .            .           .                  .            .           .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
       623 ( 0.00%)   0           0                 356 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	    _M_dispose();
         .            .           .                   .            .           .                  .            .           .           	    // There must be a memory barrier between dispose() and destroy()
         .            .           .                   .            .           .                  .            .           .           	    // to ensure that the effects of dispose() are observed in the
         .            .           .                   .            .           .                  .            .           .           	    // thread that runs destroy().
         .            .           .                   .            .           .                  .            .           .           	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
         .            .           .                   .            .           .                  .            .           .           	    if (_Mutex_base<_Lp>::_S_need_barriers)
         .            .           .                   .            .           .                  .            .           .           	      {
         .            .           .                   .            .           .                  .            .           .           		__atomic_thread_fence (__ATOMIC_ACQ_REL);
         .            .           .                   .            .           .                  .            .           .           	      }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                       // Be race-detector-friendly.  For more info see bits/c++config.
         .            .           .                   .            .           .                  .            .           .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
       623 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
       178 ( 0.00%)   0           0                   0            0           0                  0            0           0           						       -1) == 1)
         .            .           .                   .            .           .                  .            .           .                         {
         .            .           .                   .            .           .                  .            .           .                           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
       623 ( 0.00%)   0           0                 356 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	        _M_destroy();
         .            .           .                   .            .           .                  .            .           .                         }
         .            .           .                   .            .           .                  .            .           .           	  }
     5,103 ( 0.00%) 115 ( 0.29%)  0               3,402 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
         .            .           .                   .            .           .                  .            .           .                 _M_weak_add_ref() noexcept
         .            .           .                   .            .           .                  .            .           .                 { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
         .            .           .                   .            .           .                  .            .           .                 _M_weak_release() noexcept
         .            .           .                   .            .           .                  .            .           .                 {
-- line 182 ----------------------------------------
-- line 404 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .               _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             template<int _Nm, typename _Tp,
         .            .           .                   .            .           .                  .            .           .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
         .            .           .                   .            .           .                  .            .           .               struct _Sp_ebo_helper;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             /// Specialization using EBO.
         .            .           .                   .            .           .                  .            .           .             template<int _Nm, typename _Tp>
       979 ( 0.00%)   0           0                 267 ( 0.00%)   0           0                267 ( 0.00%)   0           0               struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
         .            .           .                   .            .           .                  .            .           .               {
     1,246 ( 0.00%) 168 ( 0.42%)  4 ( 0.06%)        356 ( 0.00%)   0           0                356 ( 0.00%)   0           0                 explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
         .            .           .                   .            .           .                  .            .           .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 static _Tp&
     1,246 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        534 ( 0.00%)   0           0                356 ( 0.00%)   0           0                 _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             /// Specialization not using EBO.
         .            .           .                   .            .           .                  .            .           .             template<int _Nm, typename _Tp>
         .            .           .                   .            .           .                  .            .           .               struct _Sp_ebo_helper<_Nm, _Tp, false>
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .                 explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
         .            .           .                   .            .           .                  .            .           .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }
-- line 426 ----------------------------------------
-- line 518 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .               struct _Sp_alloc_shared_tag
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .                 const _Alloc& _M_a;
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
         .            .           .                   .            .           .                  .            .           .               class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
         .            .           .                   .            .           .                  .            .           .               {
       979 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        267 ( 0.00%)   0           0                267 ( 0.00%)   0           0                 class _Impl : _Sp_ebo_helper<0, _Alloc>
         .            .           .                   .            .           .                  .            .           .                 {
         .            .           .                   .            .           .                  .            .           .           	typedef _Sp_ebo_helper<0, _Alloc>	_A_base;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 public:
     1,246 ( 0.00%)  83 ( 0.21%)  2 ( 0.03%)        356 ( 0.00%)   0           0                356 ( 0.00%)   0           0           	explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }
         .            .           .                   .            .           .                  .            .           .           
     1,780 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        534 ( 0.00%)   0           0                534 ( 0.00%)   0           0           	_Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .           	__gnu_cxx::__aligned_buffer<_Tp> _M_storage;
         .            .           .                   .            .           .                  .            .           .                 };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               public:
         .            .           .                   .            .           .                  .            .           .                 using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Alloc parameter is not a reference so doesn't alias anything in __args
         .            .           .                   .            .           .                  .            .           .                 template<typename... _Args>
       890 ( 0.00%)  12 ( 0.03%) 10 ( 0.16%)         89 ( 0.00%)   0           0                445 ( 0.00%)   0           0           	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
     1,780 ( 0.00%)  20 ( 0.05%) 11 ( 0.18%)        356 ( 0.00%)   0           0                445 ( 0.00%)   0           0           	: _M_impl(__a)
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .           .                   .            .           .                  .            .           .           	  // 2070.  allocate_shared should use allocator_traits<A>::construct
       712 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                178 ( 0.00%)   0           0           	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
         .            .           .                   .            .           .                  .            .           .           	      std::forward<_Args>(__args)...); // might throw
       712 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        445 ( 0.00%)   0           0                  0            0           0           	}
         .            .           .                   .            .           .                  .            .           .           
     1,602 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        445 ( 0.00%)   0           0                445 ( 0.00%)   0           0                 ~_Sp_counted_ptr_inplace() noexcept { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 virtual void
       534 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0                267 ( 0.00%)   0           0                 _M_dispose() noexcept
         .            .           .                   .            .           .                  .            .           .                 {
       979 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        178 ( 0.00%)   0           0                267 ( 0.00%)   0           0           	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
       445 ( 0.00%)   0           0                 267 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Override because the allocator needs to know the dynamic type
         .            .           .                   .            .           .                  .            .           .                 virtual void
       712 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         89 ( 0.00%)   0           0                267 ( 0.00%)   0           0                 _M_destroy() noexcept
         .            .           .                   .            .           .                  .            .           .                 {
     1,068 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                267 ( 0.00%)   0           0           	__allocator_type __a(_M_impl._M_alloc());
       801 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         89 ( 0.00%)   0           0                178 ( 0.00%)   0           0           	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
       267 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	this->~_Sp_counted_ptr_inplace();
       534 ( 0.00%)   0           0                 356 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               private:
         .            .           .                   .            .           .                  .            .           .                 friend class __shared_count<_Lp>; // To be able to call _M_ptr().
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // No longer used, but code compiled against old libstdc++ headers
         .            .           .                   .            .           .                  .            .           .                 // might still call it from __shared_ptr ctor to get the pointer out.
         .            .           .                   .            .           .                  .            .           .                 virtual void*
         .            .           .                   .            .           .                  .            .           .                 _M_get_deleter(const std::type_info& __ti) noexcept override
-- line 575 ----------------------------------------
-- line 586 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           #else
         .            .           .                   .            .           .                  .            .           .           	    _Sp_make_shared_tag::_S_eq(__ti)
         .            .           .                   .            .           .                  .            .           .           #endif
         .            .           .                   .            .           .                  .            .           .           	   )
         .            .           .                   .            .           .                  .            .           .           	  return __ptr;
         .            .           .                   .            .           .                  .            .           .           	return nullptr;
         .            .           .                   .            .           .                  .            .           .                 }
         .            .           .                   .            .           .                  .            .           .           
     2,937 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)        801 ( 0.00%)   0           0                801 ( 0.00%)   0           0                 _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 _Impl _M_impl;
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             // The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.
         .            .           .                   .            .           .                  .            .           .             struct __sp_array_delete
         .            .           .                   .            .           .                  .            .           .             {
         .            .           .                   .            .           .                  .            .           .               template<typename _Yp>
-- line 602 ----------------------------------------
-- line 608 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp>
         .            .           .                   .            .           .                  .            .           .           	struct __not_alloc_shared_tag { using type = void; };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp>
         .            .           .                   .            .           .                  .            .           .           	struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               public:
     2,904 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)        484 ( 0.00%)   0           0              1,452 ( 0.00%)   0           0                 constexpr __shared_count() noexcept : _M_pi(0)
     1,452 ( 0.00%)   0           0                 968 ( 0.00%)   0           0                  0            0           0                 { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Ptr>
         .            .           .                   .            .           .                  .            .           .                   explicit
         .            .           .                   .            .           .                  .            .           .           	__shared_count(_Ptr __p) : _M_pi(0)
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  __try
         .            .           .                   .            .           .                  .            .           .           	    {
         .            .           .                   .            .           .                  .            .           .           	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
-- line 625 ----------------------------------------
-- line 664 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	  __catch(...)
         .            .           .                   .            .           .                  .            .           .           	    {
         .            .           .                   .            .           .                  .            .           .           	      __d(__p); // Call _Deleter on __p.
         .            .           .                   .            .           .                  .            .           .           	      __throw_exception_again;
         .            .           .                   .            .           .                  .            .           .           	    }
         .            .           .                   .            .           .                  .            .           .           	}
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp, typename _Alloc, typename... _Args>
     1,157 ( 0.00%) 102 ( 0.26%)  4 ( 0.06%)         89 ( 0.00%)   0           0                712 ( 0.00%)   0           0           	__shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         .            .           .                   .            .           .                  .            .           .           		       _Args&&... __args)
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
       712 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                178 ( 0.00%)   1 ( 0.00%)  1 ( 0.00%)  	  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
       712 ( 0.00%)   0           0                   0            0           0                178 ( 0.00%)   0           0           	  auto __guard = std::__allocate_guarded(__a2);
       356 ( 0.00%)  84 ( 0.21%)  2 ( 0.03%)          0            0           0                178 ( 0.00%)   0           0           	  _Sp_cp_type* __mem = __guard.get();
     1,602 ( 0.00%)  20 ( 0.05%)  2 ( 0.03%)        178 ( 0.00%)   0           0                445 ( 0.00%)   0           0           	  auto __pi = ::new (__mem)
         .            .           .                   .            .           .                  .            .           .           	    _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
       356 ( 0.00%)   0           0                   0            0           0                 89 ( 0.00%)   0           0           	  __guard = nullptr;
       267 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	  _M_pi = __pi;
       445 ( 0.00%)  84 ( 0.21%)  2 ( 0.03%)        178 ( 0.00%)   0           0                178 ( 0.00%)   0           0           	  __p = __pi->_M_ptr();
       890 ( 0.00%)  18 ( 0.05%)  9 ( 0.14%)        623 ( 0.00%)   0           0                  0            0           0           	}
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .           #if _GLIBCXX_USE_DEPRECATED
         .            .           .                   .            .           .                  .            .           .           #pragma GCC diagnostic push
         .            .           .                   .            .           .                  .            .           .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .            .           .                   .            .           .                  .            .           .                 // Special case for auto_ptr<_Tp> to provide the strong guarantee.
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp>
         .            .           .                   .            .           .                  .            .           .                   explicit
         .            .           .                   .            .           .                  .            .           .           	__shared_count(std::auto_ptr<_Tp>&& __r);
-- line 692 ----------------------------------------
-- line 719 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	}
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
         .            .           .                   .            .           .                  .            .           .                 explicit __shared_count(const __weak_count<_Lp>& __r);
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // Does not throw if __r._M_get_use_count() == 0, caller must check.
         .            .           .                   .            .           .                  .            .           .                 explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);
         .            .           .                   .            .           .                  .            .           .           
     5,440 ( 0.00%)  34 ( 0.09%) 15 ( 0.24%)          0            0           0              2,176 ( 0.00%)   0           0                 ~__shared_count() noexcept
         .            .           .                   .            .           .                  .            .           .                 {
     4,352 ( 0.00%)   0           0               2,176 ( 0.00%)  20 ( 0.04%)  6 ( 0.02%)         0            0           0           	if (_M_pi != nullptr)
     2,764 ( 0.00%)   3 ( 0.01%)  3 ( 0.05%)      1,382 ( 0.00%)   0           0                691 ( 0.00%)   0           0           	  _M_pi->_M_release();
     3,264 ( 0.00%)   0           0               2,176 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
     3,090 ( 0.00%)   6 ( 0.02%)  4 ( 0.06%)          0            0           0              1,545 ( 0.00%)   0           0                 __shared_count(const __shared_count& __r) noexcept
     2,060 ( 0.00%)   0           0               1,545 ( 0.00%)  18 ( 0.04%) 17 ( 0.05%)       515 ( 0.00%)   0           0                 : _M_pi(__r._M_pi)
         .            .           .                   .            .           .                  .            .           .                 {
     2,060 ( 0.00%)   0           0               1,030 ( 0.00%)   0           0                  0            0           0           	if (_M_pi != 0)
     2,056 ( 0.00%)   0           0               1,028 ( 0.00%)   0           0                514 ( 0.00%)   1 ( 0.00%)  1 ( 0.00%)  	  _M_pi->_M_add_ref_copy();
     1,545 ( 0.00%)   0           0               1,030 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 __shared_count&
     7,626 ( 0.00%)   0           0                   0            0           0              3,813 ( 0.00%)   0           0                 operator=(const __shared_count& __r) noexcept
         .            .           .                   .            .           .                  .            .           .                 {
     3,813 ( 0.00%)   0           0               2,542 ( 0.00%)  21 ( 0.04%)  0              1,271 ( 0.00%)   0           0           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
     5,084 ( 0.00%)   0           0               3,813 ( 0.00%)  68 ( 0.14%) 64 ( 0.20%)         0            0           0           	if (__tmp != _M_pi)
         .            .           .                   .            .           .                  .            .           .           	  {
     2,374 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)      1,187 ( 0.00%)   0           0                  0            0           0           	    if (__tmp != 0)
     3,294 ( 0.00%)   0           0               1,098 ( 0.00%)   0           0              1,098 ( 0.00%)   0           0           	      __tmp->_M_add_ref_copy();
     4,748 ( 0.00%)   0           0               2,374 ( 0.00%)   0           0                  0            0           0           	    if (_M_pi != 0)
     4,040 ( 0.00%)   0           0               2,020 ( 0.00%)   0           0              1,010 ( 0.00%)   0           0           	      _M_pi->_M_release();
     3,561 ( 0.00%)   0           0               2,374 ( 0.00%)   0           0              1,187 ( 0.00%)   0           0           	    _M_pi = __tmp;
         .            .           .                   .            .           .                  .            .           .           	  }
     1,271 ( 0.00%)   0           0               1,271 ( 0.00%)   0           0                  0            0           0           	return *this;
     2,542 ( 0.00%)   0           0               2,542 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
     1,525 ( 0.00%)   8 ( 0.02%)  1 ( 0.02%)          0            0           0                915 ( 0.00%)   7 ( 0.00%)  0                 _M_swap(__shared_count& __r) noexcept
         .            .           .                   .            .           .                  .            .           .                 {
       915 ( 0.00%)   0           0                 610 ( 0.00%)   0           0                305 ( 0.00%)   0           0           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
     1,220 ( 0.00%)   0           0                 915 ( 0.00%)   0           0                305 ( 0.00%)   0           0           	__r._M_pi = _M_pi;
       915 ( 0.00%)   0           0                 610 ( 0.00%)   0           0                305 ( 0.00%)   0           0           	_M_pi = __tmp;
       915 ( 0.00%)   0           0                 610 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 long
         .            .           .                   .            .           .                  .            .           .                 _M_get_use_count() const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 bool
         .            .           .                   .            .           .                  .            .           .                 _M_unique() const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return this->_M_get_use_count() == 1; }
-- line 769 ----------------------------------------
-- line 1004 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .                 element_type&
         .            .           .                   .            .           .                  .            .           .                 operator*() const noexcept
         .            .           .                   .            .           .                  .            .           .                 {
         .            .           .                   .            .           .                  .            .           .           	__glibcxx_assert(_M_get() != nullptr);
         .            .           .                   .            .           .                  .            .           .           	return *_M_get();
         .            .           .                   .            .           .                  .            .           .                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 element_type*
20,013,055 ( 0.13%)   7 ( 0.02%)  4 ( 0.06%)          0            0           0          8,005,222 ( 0.26%)   0           0                 operator->() const noexcept
         .            .           .                   .            .           .                  .            .           .                 {
         .            .           .                   .            .           .                  .            .           .           	_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);
12,007,833 ( 0.08%)   0           0           4,002,611 ( 0.10%)   0           0          4,002,611 ( 0.13%)   0           0           	return _M_get();
 8,005,222 ( 0.05%)   0           0           8,005,222 ( 0.19%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               private:
         .            .           .                   .            .           .                  .            .           .                 element_type*
20,013,055 ( 0.13%) 177 ( 0.45%)  2 ( 0.03%)          0            0           0          8,005,222 ( 0.26%)   0           0                 _M_get() const noexcept
20,013,055 ( 0.13%)   0           0          12,007,833 ( 0.29%)   0           0          4,002,611 ( 0.13%)   0           0                 { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             // Define operator-> for shared_ptr<cv void>.
         .            .           .                   .            .           .                  .            .           .             template<typename _Tp, _Lock_policy _Lp>
         .            .           .                   .            .           .                  .            .           .               class __shared_ptr_access<_Tp, _Lp, false, true>
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .               public:
         .            .           .                   .            .           .                  .            .           .                 using element_type = _Tp;
-- line 1029 ----------------------------------------
-- line 1072 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               private:
         .            .           .                   .            .           .                  .            .           .                 element_type*
         .            .           .                   .            .           .                  .            .           .                 _M_get() const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
         .            .           .                   .            .           .                  .            .           .               };
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .             template<typename _Tp, _Lock_policy _Lp>
    25,420 ( 0.00%) 104 ( 0.26%)  0              10,168 ( 0.00%)  49 ( 0.10%)  1 ( 0.00%)     6,355 ( 0.00%)   7 ( 0.00%)  7 ( 0.00%)      class __shared_ptr
         .            .           .                   .            .           .                  .            .           .               : public __shared_ptr_access<_Tp, _Lp>
         .            .           .                   .            .           .                  .            .           .               {
         .            .           .                   .            .           .                  .            .           .               public:
         .            .           .                   .            .           .                  .            .           .                 using element_type = typename remove_extent<_Tp>::type;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               private:
         .            .           .                   .            .           .                  .            .           .                 // Constraint for taking ownership of a pointer of type _Yp*:
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp>
-- line 1088 ----------------------------------------
-- line 1110 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               public:
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .           #if __cplusplus > 201402L
         .            .           .                   .            .           .                  .            .           .                 using weak_type = __weak_ptr<_Tp, _Lp>;
         .            .           .                   .            .           .                  .            .           .           #endif
         .            .           .                   .            .           .                  .            .           .           
     1,340 ( 0.00%)  85 ( 0.21%)  3 ( 0.05%)          0            0           0                536 ( 0.00%)   0           0                 constexpr __shared_ptr() noexcept
     1,608 ( 0.00%)   0           0                 536 ( 0.00%)   0           0                536 ( 0.00%)   0           0                 : _M_ptr(0), _M_refcount()
       804 ( 0.00%)   0           0                 536 ( 0.00%)   0           0                  0            0           0                 { }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp, typename = _SafeConv<_Yp>>
         .            .           .                   .            .           .                  .            .           .           	explicit
         .            .           .                   .            .           .                  .            .           .           	__shared_ptr(_Yp* __p)
         .            .           .                   .            .           .                  .            .           .           	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  static_assert( !is_void<_Yp>::value, "incomplete type" );
         .            .           .                   .            .           .                  .            .           .           	  static_assert( sizeof(_Yp) > 0, "incomplete type" );
-- line 1128 ----------------------------------------
-- line 1159 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	{ }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp>
         .            .           .                   .            .           .                  .            .           .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
         .            .           .                   .            .           .                  .            .           .           		     element_type* __p) noexcept
         .            .           .                   .            .           .                  .            .           .           	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
         .            .           .                   .            .           .                  .            .           .           	{ }
         .            .           .                   .            .           .                  .            .           .           
    10,300 ( 0.00%) 116 ( 0.29%)  0               3,605 ( 0.00%)  59 ( 0.12%) 46 ( 0.14%)     2,575 ( 0.00%) 106 ( 0.00%) 29 ( 0.00%)        __shared_ptr(const __shared_ptr&) noexcept = default;
         .            .           .                   .            .           .                  .            .           .                 __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
    13,056 ( 0.00%) 103 ( 0.26%)  2 ( 0.03%)      3,264 ( 0.00%)   0           0              3,264 ( 0.00%)   0           0                 ~__shared_ptr() = default;
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .            .           .                   .            .           .                  .            .           .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         .            .           .                   .            .           .                  .            .           .           	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         .            .           .                   .            .           .                  .            .           .           	{ }
         .            .           .                   .            .           .                  .            .           .           
     1,296 ( 0.00%)   4 ( 0.01%)  2 ( 0.03%)          0            0           0                648 ( 0.00%)   0           0                 __shared_ptr(__shared_ptr&& __r) noexcept
     1,728 ( 0.00%)   0           0                 864 ( 0.00%)  35 ( 0.07%) 28 ( 0.09%)       432 ( 0.00%)  27 ( 0.00%) 27 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount()
         .            .           .                   .            .           .                  .            .           .                 {
     1,512 ( 0.00%)   0           0                 432 ( 0.00%)   0           0                216 ( 0.00%)   0           0           	_M_refcount._M_swap(__r._M_refcount);
       432 ( 0.00%)   0           0                 216 ( 0.00%)   0           0                216 ( 0.00%)   0           0           	__r._M_ptr = 0;
       648 ( 0.00%)   0           0                 432 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .            .           .                   .            .           .                  .            .           .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
         .            .           .                   .            .           .                  .            .           .           	: _M_ptr(__r._M_ptr), _M_refcount()
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  _M_refcount._M_swap(__r._M_refcount);
         .            .           .                   .            .           .                  .            .           .           	  __r._M_ptr = 0;
         .            .           .                   .            .           .                  .            .           .           	}
-- line 1189 ----------------------------------------
-- line 1255 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  __shared_ptr(std::move(__r)).swap(*this);
         .            .           .                   .            .           .                  .            .           .           	  return *this;
         .            .           .                   .            .           .                  .            .           .           	}
         .            .           .                   .            .           .                  .            .           .           #pragma GCC diagnostic pop
         .            .           .                   .            .           .                  .            .           .           #endif
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 __shared_ptr&
       801 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         89 ( 0.00%)   0           0                356 ( 0.00%)   0           0                 operator=(__shared_ptr&& __r) noexcept
         .            .           .                   .            .           .                  .            .           .                 {
     1,424 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        178 ( 0.00%)   0           0                356 ( 0.00%)   0           0           	__shared_ptr(std::move(__r)).swap(*this);
        89 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                  0            0           0           	return *this;
       445 ( 0.00%)   0           0                 356 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<class _Yp>
         .            .           .                   .            .           .                  .            .           .           	_Assignable<_Yp>
         .            .           .                   .            .           .                  .            .           .           	operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  __shared_ptr(std::move(__r)).swap(*this);
         .            .           .                   .            .           .                  .            .           .           	  return *this;
         .            .           .                   .            .           .                  .            .           .           	}
-- line 1275 ----------------------------------------
-- line 1301 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	{ __shared_ptr(__p, std::move(__d)).swap(*this); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp, typename _Deleter, typename _Alloc>
         .            .           .                   .            .           .                  .            .           .           	_SafeConv<_Yp>
         .            .           .                   .            .           .                  .            .           .           	reset(_Yp* __p, _Deleter __d, _Alloc __a)
         .            .           .                   .            .           .                  .            .           .                   { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 element_type*
16,011,276 ( 0.10%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0          8,005,638 ( 0.26%)   0           0                 get() const noexcept
16,011,276 ( 0.10%)   4 ( 0.01%)  2 ( 0.03%) 16,011,276 ( 0.39%) 140 ( 0.28%) 24 ( 0.07%)         0            0           0                 { return _M_ptr; }
         .            .           .                   .            .           .                  .            .           .           
       360 ( 0.00%)   0           0                   0            0           0                180 ( 0.00%)   0           0                 explicit operator bool() const // never throws
       540 ( 0.00%)   0           0                 360 ( 0.00%)   0           0                  0            0           0                 { return _M_ptr == 0 ? false : true; }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 bool
         .            .           .                   .            .           .                  .            .           .                 unique() const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return _M_refcount._M_unique(); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 long
         .            .           .                   .            .           .                  .            .           .                 use_count() const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return _M_refcount._M_get_use_count(); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void
       534 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0                267 ( 0.00%)   0           0                 swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
         .            .           .                   .            .           .                  .            .           .                 {
       445 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	std::swap(_M_ptr, __other._M_ptr);
       623 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	_M_refcount._M_swap(__other._M_refcount);
       267 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                  0            0           0                 }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp1>
         .            .           .                   .            .           .                  .            .           .           	bool
         .            .           .                   .            .           .                  .            .           .           	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .            .           .                   .            .           .                  .            .           .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp1>
         .            .           .                   .            .           .                  .            .           .           	bool
         .            .           .                   .            .           .                  .            .           .           	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .            .           .                   .            .           .                  .            .           .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .               protected:
         .            .           .                   .            .           .                  .            .           .                 // This constructor is non-standard, it is used by allocate_shared.
         .            .           .                   .            .           .                  .            .           .                 template<typename _Alloc, typename... _Args>
       534 ( 0.00%)  22 ( 0.06%) 11 ( 0.18%)          0            0           0                267 ( 0.00%)   0           0           	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
       801 ( 0.00%)   0           0                 356 ( 0.00%)   0           0                178 ( 0.00%)   1 ( 0.00%)  1 ( 0.00%)  	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
       801 ( 0.00%)  79 ( 0.20%)  1 ( 0.02%)        445 ( 0.00%)   0           0                 89 ( 0.00%)   0           0           	{ _M_enable_shared_from_this_with(_M_ptr); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
         .            .           .                   .            .           .                  .            .           .           	       typename... _Args>
         .            .           .                   .            .           .                  .            .           .           	friend __shared_ptr<_Tp1, _Lp1>
         .            .           .                   .            .           .                  .            .           .           	__allocate_shared(const _Alloc& __a, _Args&&... __args);
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 // This constructor is used by __weak_ptr::lock() and
         .            .           .                   .            .           .                  .            .           .                 // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).
-- line 1353 ----------------------------------------
-- line 1380 ----------------------------------------
         .            .           .                   .            .           .                  .            .           .           	_M_enable_shared_from_this_with(_Yp* __p) noexcept
         .            .           .                   .            .           .                  .            .           .           	{
         .            .           .                   .            .           .                  .            .           .           	  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
         .            .           .                   .            .           .                  .            .           .           	    __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
         .            .           .                   .            .           .                  .            .           .           	}
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
         .            .           .                   .            .           .                  .            .           .           	typename enable_if<!__has_esft_base<_Yp2>::value>::type
       445 ( 0.00%)   0           0                   0            0           0                267 ( 0.00%)   0           0           	_M_enable_shared_from_this_with(_Yp*) noexcept
       267 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                  0            0           0           	{ }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 void*
         .            .           .                   .            .           .                  .            .           .                 _M_get_deleter(const std::type_info& __ti) const noexcept
         .            .           .                   .            .           .                  .            .           .                 { return _M_refcount._M_get_deleter(__ti); }
         .            .           .                   .            .           .                  .            .           .           
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
         .            .           .                   .            .           .                  .            .           .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
         .            .           .                   .            .           .                  .            .           .           
-- line 1397 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/unique_ptr.h
--------------------------------------------------------------------------------
Ir                   I1mr         ILmr        Dr                  D1mr         DLmr        Dw                  D1mw       DLmw       

-- line 63 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** @brief Converting constructor.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * Allows conversion from a deleter for arrays of another type, @p _Up,
          .            .           .                   .            .           .                   .          .          .                  * only if @p _Up* is convertible to @p _Tp*.
          .            .           .                   .            .           .                   .          .          .                  */
          .            .           .                   .            .           .                   .          .          .                 template<typename _Up, typename = typename
          .            .           .                   .            .           .                   .          .          .           	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
          8 ( 0.00%)   0           0                   2 ( 0.00%)   0           0                   3 ( 0.00%) 0          0                   default_delete(const default_delete<_Up>&) noexcept { }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Calls @c delete @p __ptr
          .            .           .                   .            .           .                   .          .          .                 void
        535 ( 0.00%)   0           0                   0            0           0                 268 ( 0.00%) 0          0                 operator()(_Tp* __ptr) const
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	static_assert(!is_void<_Tp>::value,
          .            .           .                   .            .           .                   .          .          .           		      "can't delete pointer to incomplete type");
          .            .           .                   .            .           .                   .          .          .           	static_assert(sizeof(_Tp)>0,
          .            .           .                   .            .           .                   .          .          .           		      "can't delete pointer to incomplete type");
        538 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         91 ( 0.00%)   0           0                  90 ( 0.00%) 0          0           	delete __ptr;
        269 ( 0.00%)   0           0                 179 ( 0.00%)   0           0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .               };
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .            .           .                   .            .           .                   .          .          .             // DR 740 - omit specialization for array objects with a compile time length
          .            .           .                   .            .           .                   .          .          .             /// Specialization for arrays, default_delete.
          .            .           .                   .            .           .                   .          .          .             template<typename _Tp>
          .            .           .                   .            .           .                   .          .          .               struct default_delete<_Tp[]>
          .            .           .                   .            .           .                   .          .          .               {
-- line 90 ----------------------------------------
-- line 138 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .           	       is_default_constructible<_Dp>>::value>;
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 using pointer = typename _Ptr<_Tp, _Dp>::type;
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 static_assert( !is_rvalue_reference<_Dp>::value,
          .            .           .                   .            .           .                   .          .          .           		     "unique_ptr's deleter type must be a function object type"
          .            .           .                   .            .           .                   .          .          .           		     " or an lvalue reference type" );
          .            .           .                   .            .           .                   .          .          .           
        990 ( 0.00%)   0           0                 270 ( 0.00%)   0           0                 270 ( 0.00%) 0          0                 __uniq_ptr_impl() = default;
      1,930 ( 0.00%)   6 ( 0.02%)  4 ( 0.06%)        578 ( 0.00%)   0           0                 676 ( 0.00%) 0          0                 __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 template<typename _Del>
          .            .           .                   .            .           .                   .          .          .                 __uniq_ptr_impl(pointer __p, _Del&& __d)
          .            .           .                   .            .           .                   .          .          .           	: _M_t(__p, std::forward<_Del>(__d)) { }
          .            .           .                   .            .           .                   .          .          .           
      4,660 ( 0.00%)   9 ( 0.02%)  6 ( 0.10%)      1,398 ( 0.00%)   0           0               1,398 ( 0.00%) 0          0                 pointer&   _M_ptr() { return std::get<0>(_M_t); }
132,003,069 ( 0.84%) 162 ( 0.41%) 44 ( 0.70%) 48,001,116 ( 1.17%) 109 ( 0.22%) 55 ( 0.17%) 36,000,837 ( 1.17%) 0          0                 pointer    _M_ptr() const { return std::get<0>(_M_t); }
      2,670 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)        801 ( 0.00%)   0           0                 801 ( 0.00%) 0          0                 _Dp&       _M_deleter() { return std::get<1>(_M_t); }
          .            .           .                   .            .           .                   .          .          .                 const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 void
          .            .           .                   .            .           .                   .          .          .                 swap(__uniq_ptr_impl& __rhs) noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	using std::swap;
          .            .           .                   .            .           .                   .          .          .           	swap(this->_M_ptr(), __rhs._M_ptr());
          .            .           .                   .            .           .                   .          .          .           	swap(this->_M_deleter(), __rhs._M_deleter());
-- line 163 ----------------------------------------
-- line 191 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .           	  __not_<is_array<_Up>>
          .            .           .                   .            .           .                   .          .          .                   >;
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .               public:
          .            .           .                   .            .           .                   .          .          .                 // Constructors.
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Default constructor, creates a unique_ptr that owns nothing.
          .            .           .                   .            .           .                   .          .          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
          5 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0                   2 ( 0.00%) 0          0           	constexpr unique_ptr() noexcept
          5 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)   0           0                   2 ( 0.00%) 0          0           	: _M_t()
          3 ( 0.00%)   0           0                   2 ( 0.00%)   0           0                   0          0          0           	{ }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** Takes ownership of a pointer.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * @param __p  A pointer to an object of @c element_type
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * The deleter will be value-initialized.
          .            .           .                   .            .           .                   .          .          .                  */
          .            .           .                   .            .           .                   .          .          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
          .            .           .                   .            .           .                   .          .          .           	explicit
        588 ( 0.00%)   3 ( 0.01%)  2 ( 0.03%)          0            0           0                 294 ( 0.00%) 0          0           	unique_ptr(pointer __p) noexcept
        490 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        196 ( 0.00%)   0           0                  98 ( 0.00%) 0          0           	: _M_t(__p)
        294 ( 0.00%)   0           0                 196 ( 0.00%)   0           0                   0          0          0                   { }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** Takes ownership of a pointer.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * @param __p  A pointer to an object of @c element_type
          .            .           .                   .            .           .                   .          .          .                  * @param __d  A reference to a deleter.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * The deleter will be initialized with @p __d
          .            .           .                   .            .           .                   .          .          .                  */
-- line 221 ----------------------------------------
-- line 242 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .                 template<typename _Del = deleter_type,
          .            .           .                   .            .           .                   .          .          .           	       typename _DelUnref = typename remove_reference<_Del>::type>
          .            .           .                   .            .           .                   .          .          .           	unique_ptr(pointer,
          .            .           .                   .            .           .                   .          .          .           		   __enable_if_t<is_lvalue_reference<_Del>::value,
          .            .           .                   .            .           .                   .          .          .           				 _DelUnref&&>) = delete;
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Creates a unique_ptr that owns nothing.
          .            .           .                   .            .           .                   .          .          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
        534 ( 0.00%)   4 ( 0.01%)  4 ( 0.06%)          0            0           0                 267 ( 0.00%) 0          0           	constexpr unique_ptr(nullptr_t) noexcept
        445 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                 178 ( 0.00%) 0          0           	: _M_t()
        267 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                   0          0          0           	{ }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 // Move constructors.
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Move constructor.
          .            .           .                   .            .           .                   .          .          .                 unique_ptr(unique_ptr&& __u) noexcept
          .            .           .                   .            .           .                   .          .          .                 : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** @brief Converting constructor from another type
-- line 260 ----------------------------------------
-- line 278 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .                 /// Converting constructor from @c auto_ptr
          .            .           .                   .            .           .                   .          .          .                 template<typename _Up, typename = _Require<
          .            .           .                   .            .           .                   .          .          .           	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
          .            .           .                   .            .           .                   .          .          .           	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
          .            .           .                   .            .           .                   .          .          .           #pragma GCC diagnostic pop
          .            .           .                   .            .           .                   .          .          .           #endif
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Destructor, invokes the deleter if the stored pointer is not null.
      1,140 ( 0.00%)   9 ( 0.02%)  8 ( 0.13%)          0            0           0                 570 ( 0.00%) 0          0                 ~unique_ptr() noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
          .            .           .                   .            .           .                   .          .          .           		      "unique_ptr's deleter must be invocable with a pointer");
        760 ( 0.00%)  89 ( 0.23%)  6 ( 0.10%)        190 ( 0.00%)   0           0                 380 ( 0.00%) 0          0           	auto& __ptr = _M_t._M_ptr();
        760 ( 0.00%)   0           0                 380 ( 0.00%)   0           0                   0          0          0           	if (__ptr != nullptr)
        979 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        267 ( 0.00%)   0           0                 267 ( 0.00%) 0          0           	  get_deleter()(std::move(__ptr));
        380 ( 0.00%)   3 ( 0.01%)  2 ( 0.03%)        190 ( 0.00%)   1 ( 0.00%)  0                 190 ( 0.00%) 1 ( 0.00%) 0           	__ptr = pointer();
        950 ( 0.00%)   0           0                 570 ( 0.00%)   0           0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 // Assignment.
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** @brief Move assignment operator.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * @param __u  The object to transfer ownership from.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * Invokes the deleter first if this object owns a pointer.
          .            .           .                   .            .           .                   .          .          .                  */
          .            .           .                   .            .           .                   .          .          .                 unique_ptr&
        528 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0            0           0                 264 ( 0.00%) 0          0                 operator=(unique_ptr&& __u) noexcept
          .            .           .                   .            .           .                   .          .          .                 {
        704 ( 0.00%)  79 ( 0.20%)  1 ( 0.02%)        176 ( 0.00%)   0           0                 176 ( 0.00%) 0          0           	reset(__u.release());
        704 ( 0.00%)   0           0                 176 ( 0.00%)   0           0                 264 ( 0.00%) 0          0           	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
         88 ( 0.00%)   0           0                  88 ( 0.00%)   0           0                   0          0          0           	return *this;
        176 ( 0.00%)   0           0                 176 ( 0.00%)   0           0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** @brief Assignment from another type.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * @param __u  The object to transfer ownership from, which owns a
          .            .           .                   .            .           .                   .          .          .                  *             convertible pointer to a non-array object.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * Invokes the deleter first if this object owns a pointer.
          .            .           .                   .            .           .                   .          .          .                  */
          .            .           .                   .            .           .                   .          .          .                 template<typename _Up, typename _Ep>
          .            .           .                   .            .           .                   .          .          .                   typename enable_if< __and_<
          .            .           .                   .            .           .                   .          .          .                     __safe_conversion_up<_Up, _Ep>,
          .            .           .                   .            .           .                   .          .          .                     is_assignable<deleter_type&, _Ep&&>
          .            .           .                   .            .           .                   .          .          .                     >::value,
          .            .           .                   .            .           .                   .          .          .                     unique_ptr&>::type
          9 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)   0           0                   4 ( 0.00%) 0          0           	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
          .            .           .                   .            .           .                   .          .          .           	{
          8 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)   0           0                   2 ( 0.00%) 0          0           	  reset(__u.release());
         13 ( 0.00%)   0           0                   2 ( 0.00%)   0           0                   4 ( 0.00%) 0          0           	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
          1 ( 0.00%)   1 ( 0.00%)  0                   1 ( 0.00%)   0           0                   0          0          0           	  return *this;
          5 ( 0.00%)   0           0                   4 ( 0.00%)   0           0                   0          0          0           	}
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
          .            .           .                   .            .           .                   .          .          .                 unique_ptr&
          .            .           .                   .            .           .                   .          .          .                 operator=(nullptr_t) noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	reset();
          .            .           .                   .            .           .                   .          .          .           	return *this;
          .            .           .                   .            .           .                   .          .          .                 }
-- line 338 ----------------------------------------
-- line 344 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .                 operator*() const
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	__glibcxx_assert(get() != pointer());
          .            .           .                   .            .           .                   .          .          .           	return *get();
          .            .           .                   .            .           .                   .          .          .                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Return the stored pointer.
          .            .           .                   .            .           .                   .          .          .                 pointer
 60,000,950 ( 0.38%)   8 ( 0.02%)  6 ( 0.10%)          0            0           0          24,000,380 ( 0.78%) 0          0                 operator->() const noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
 36,000,570 ( 0.23%)   1 ( 0.00%)  0          12,000,190 ( 0.29%)   0           0          12,000,190 ( 0.39%) 0          0           	return get();
 24,000,380 ( 0.15%)   0           0          24,000,380 ( 0.58%)   1 ( 0.00%)  0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Return the stored pointer.
          .            .           .                   .            .           .                   .          .          .                 pointer
 60,001,395 ( 0.38%)  47 ( 0.12%) 25 ( 0.40%)          0            0           0          24,000,558 ( 0.78%) 0          0                 get() const noexcept
 60,001,395 ( 0.38%)   0           0          36,000,837 ( 0.88%)   3 ( 0.01%)  0          12,000,279 ( 0.39%) 0          0                 { return _M_t._M_ptr(); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Return a reference to the stored deleter.
          .            .           .                   .            .           .                   .          .          .                 deleter_type&
      1,335 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0            0           0                 534 ( 0.00%) 0          0                 get_deleter() noexcept
      1,335 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        801 ( 0.00%)   0           0                 267 ( 0.00%) 0          0                 { return _M_t._M_deleter(); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Return a reference to the stored deleter.
          .            .           .                   .            .           .                   .          .          .                 const deleter_type&
          .            .           .                   .            .           .                   .          .          .                 get_deleter() const noexcept
          .            .           .                   .            .           .                   .          .          .                 { return _M_t._M_deleter(); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Return @c true if the stored pointer is not null.
          .            .           .                   .            .           .                   .          .          .                 explicit operator bool() const noexcept
          .            .           .                   .            .           .                   .          .          .                 { return get() == pointer() ? false : true; }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 // Modifiers.
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Release ownership of any stored pointer.
          .            .           .                   .            .           .                   .          .          .                 pointer
        445 ( 0.00%)  15 ( 0.04%) 14 ( 0.22%)          0            0           0                 178 ( 0.00%) 0          0                 release() noexcept
          .            .           .                   .            .           .                   .          .          .                 {
        356 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         89 ( 0.00%)   0           0                 178 ( 0.00%) 0          0           	pointer __p = get();
        356 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                 178 ( 0.00%) 0          0           	_M_t._M_ptr() = pointer();
         89 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                   0          0          0           	return __p;
        178 ( 0.00%)   0           0                 178 ( 0.00%)   0           0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /** @brief Replace the stored pointer.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * @param __p  The new pointer to store.
          .            .           .                   .            .           .                   .          .          .                  *
          .            .           .                   .            .           .                   .          .          .                  * The deleter will be invoked if a pointer is already owned.
          .            .           .                   .            .           .                   .          .          .                  */
          .            .           .                   .            .           .                   .          .          .                 void
        623 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0            0           0                 356 ( 0.00%) 0          0                 reset(pointer __p = pointer()) noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
          .            .           .                   .            .           .                   .          .          .           		      "unique_ptr's deleter must be invocable with a pointer");
          .            .           .                   .            .           .                   .          .          .           	using std::swap;
        712 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         89 ( 0.00%)   0           0                 178 ( 0.00%) 0          0           	swap(_M_t._M_ptr(), __p);
        267 ( 0.00%)   0           0                  89 ( 0.00%)   0           0                   0          0          0           	if (__p != pointer())
          .            .           .                   .            .           .                   .          .          .           	  get_deleter()(std::move(__p));
        445 ( 0.00%)   0           0                 267 ( 0.00%)   0           0                   0          0          0                 }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .                 /// Exchange the pointer and deleter with another object.
          .            .           .                   .            .           .                   .          .          .                 void
          .            .           .                   .            .           .                   .          .          .                 swap(unique_ptr& __u) noexcept
          .            .           .                   .            .           .                   .          .          .                 {
          .            .           .                   .            .           .                   .          .          .           	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
          .            .           .                   .            .           .                   .          .          .           	_M_t.swap(__u._M_t);
          .            .           .                   .            .           .                   .          .          .                 }
-- line 411 ----------------------------------------
-- line 848 ----------------------------------------
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .             template<typename _Tp, size_t _Bound>
          .            .           .                   .            .           .                   .          .          .               struct _MakeUniq<_Tp[_Bound]>
          .            .           .                   .            .           .                   .          .          .               { struct __invalid_type { }; };
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .             /// std::make_unique for single objects
          .            .           .                   .            .           .                   .          .          .             template<typename _Tp, typename... _Args>
          .            .           .                   .            .           .                   .          .          .               inline typename _MakeUniq<_Tp>::__single_object
        535 ( 0.00%)   5 ( 0.01%)  4 ( 0.06%)          0            0           0                 268 ( 0.00%) 0          0               make_unique(_Args&&... __args)
      1,262 ( 0.00%)  89 ( 0.23%)  6 ( 0.10%)        452 ( 0.00%)   1 ( 0.00%)  0                 270 ( 0.00%) 0          0               { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .             /// std::make_unique for arrays of unknown bound
          .            .           .                   .            .           .                   .          .          .             template<typename _Tp>
          .            .           .                   .            .           .                   .          .          .               inline typename _MakeUniq<_Tp>::__array
          .            .           .                   .            .           .                   .          .          .               make_unique(size_t __num)
          .            .           .                   .            .           .                   .          .          .               { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
          .            .           .                   .            .           .                   .          .          .           
          .            .           .                   .            .           .                   .          .          .             /// Disable std::make_unique for arrays of known bound
-- line 865 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/std_mutex.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                 D1mr       DLmr       Dw                 D1mw        DLmw        

-- line 57 ----------------------------------------
         .            .          .                  .          .          .                  .           .           .             class __mutex_base
         .            .          .                  .          .          .                  .           .           .             {
         .            .          .                  .          .          .                  .           .           .             protected:
         .            .          .                  .          .          .                  .           .           .               typedef __gthread_mutex_t			__native_type;
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .           #ifdef __GTHREAD_MUTEX_INIT
         .            .          .                  .          .          .                  .           .           .               __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;
         .            .          .                  .          .          .                  .           .           .           
        26 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         6 ( 0.00%) 0          0                 14 ( 0.00%)  1 ( 0.00%)  1 ( 0.00%)      constexpr __mutex_base() noexcept = default;
         .            .          .                  .          .          .                  .           .           .           #else
         .            .          .                  .          .          .                  .           .           .               __native_type  _M_mutex;
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               __mutex_base() noexcept
         .            .          .                  .          .          .                  .           .           .               {
         .            .          .                  .          .          .                  .           .           .                 // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
         .            .          .                  .          .          .                  .           .           .                 __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
         .            .          .                  .          .          .                  .           .           .               }
-- line 73 ----------------------------------------
-- line 83 ----------------------------------------
         .            .          .                  .          .          .                  .           .           .             class mutex : private __mutex_base
         .            .          .                  .          .          .                  .           .           .             {
         .            .          .                  .          .          .                  .           .           .             public:
         .            .          .                  .          .          .                  .           .           .               typedef __native_type* 			native_handle_type;
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .           #ifdef __GTHREAD_MUTEX_INIT
         .            .          .                  .          .          .                  .           .           .               constexpr
         .            .          .                  .          .          .                  .           .           .           #endif
        22 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         6 ( 0.00%) 0          0                  6 ( 0.00%)  0           0               mutex() noexcept = default;
         .            .          .                  .          .          .                  .           .           .               ~mutex() = default;
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               mutex(const mutex&) = delete;
         .            .          .                  .          .          .                  .           .           .               mutex& operator=(const mutex&) = delete;
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               void
20,000,040 ( 0.13%) 179 ( 0.45%) 0                  0          0          0          8,000,016 ( 0.26%)  0           0               lock()
         .            .          .                  .          .          .                  .           .           .               {
16,000,032 ( 0.10%)   0          0          4,000,008 ( 0.10%) 0          0          8,000,016 ( 0.26%) 27 ( 0.00%) 12 ( 0.00%)        int __e = __gthread_mutex_lock(&_M_mutex);
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .                 // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
 8,000,016 ( 0.05%)   1 ( 0.00%) 1 ( 0.02%) 4,000,008 ( 0.10%) 0          0                  0           0           0                 if (__e)
         .            .          .                  .          .          .                  .           .           .           	__throw_system_error(__e);
12,000,024 ( 0.08%)   0          0          8,000,016 ( 0.19%) 0          0                  0           0           0               }
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               bool
         .            .          .                  .          .          .                  .           .           .               try_lock() noexcept
         .            .          .                  .          .          .                  .           .           .               {
         .            .          .                  .          .          .                  .           .           .                 // XXX EINVAL, EAGAIN, EBUSY
         .            .          .                  .          .          .                  .           .           .                 return !__gthread_mutex_trylock(&_M_mutex);
         .            .          .                  .          .          .                  .           .           .               }
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               void
20,000,040 ( 0.13%)   1 ( 0.00%) 0                  0          0          0          8,000,016 ( 0.26%)  0           0               unlock()
         .            .          .                  .          .          .                  .           .           .               {
         .            .          .                  .          .          .                  .           .           .                 // XXX EINVAL, EAGAIN, EPERM
12,000,024 ( 0.08%)   0          0          4,000,008 ( 0.10%) 0          0          4,000,008 ( 0.13%)  0           0                 __gthread_mutex_unlock(&_M_mutex);
12,000,024 ( 0.08%)   0          0          8,000,016 ( 0.19%) 0          0                  0           0           0               }
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .               native_handle_type
         4 ( 0.00%)   0          0                  0          0          0                  2 ( 0.00%)  0           0               native_handle() noexcept
         3 ( 0.00%)   0          0                  3 ( 0.00%) 0          0                  0           0           0               { return &_M_mutex; }
         .            .          .                  .          .          .                  .           .           .             };
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .           #endif // _GLIBCXX_HAS_GTHREADS
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .             /// Do not acquire ownership of the mutex.
         .            .          .                  .          .          .                  .           .           .             struct defer_lock_t { explicit defer_lock_t() = default; };
         .            .          .                  .          .          .                  .           .           .           
         .            .          .                  .          .          .                  .           .           .             /// Try to acquire ownership of the mutex without blocking.
-- line 131 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/move.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 39 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             // Used, in C++03 mode too, by allocators, etc.
         .           .           .                   .          .          .                   .          .          .             /**
         .           .           .                   .          .          .                   .          .          .              *  @brief Same as C++11 std::addressof
         .           .           .                   .          .          .                   .          .          .              *  @ingroup utilities
         .           .           .                   .          .          .                   .          .          .              */
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
         .           .           .                   .          .          .                   .          .          .               inline _GLIBCXX_CONSTEXPR _Tp*
32,002,756 ( 0.20%) 13 ( 0.03%) 10 ( 0.16%)          0          0          0          16,001,378 ( 0.52%) 1 ( 0.00%) 0               __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
24,002,067 ( 0.15%)  0           0          24,002,067 ( 0.58%) 0          0                   0          0          0               { return __builtin_addressof(__r); }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           #if __cplusplus >= 201103L
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
         .           .           .                   .          .          .                   .          .          .           } // namespace
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           #include <type_traits> // Brings in std::declval too.
         .           .           .                   .          .          .                   .          .          .           
-- line 56 ----------------------------------------
-- line 66 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .             /**
         .           .           .                   .          .          .                   .          .          .              *  @brief  Forward an lvalue.
         .           .           .                   .          .          .                   .          .          .              *  @return The parameter cast to the specified type.
         .           .           .                   .          .          .                   .          .          .              *
         .           .           .                   .          .          .                   .          .          .              *  This function is used to implement "perfect forwarding".
         .           .           .                   .          .          .                   .          .          .              */
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
         .           .           .                   .          .          .                   .          .          .               constexpr _Tp&&
64,002,632 ( 0.41%) 20 ( 0.05%) 14 ( 0.22%)          0          0          0          32,001,316 ( 1.04%) 0          0               forward(typename std::remove_reference<_Tp>::type& __t) noexcept
48,001,974 ( 0.31%) 12 ( 0.03%)  6 ( 0.10%) 48,001,974 ( 1.17%) 0          0                   0          0          0               { return static_cast<_Tp&&>(__t); }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /**
         .           .           .                   .          .          .                   .          .          .              *  @brief  Forward an rvalue.
         .           .           .                   .          .          .                   .          .          .              *  @return The parameter cast to the specified type.
         .           .           .                   .          .          .                   .          .          .              *
         .           .           .                   .          .          .                   .          .          .              *  This function is used to implement "perfect forwarding".
         .           .           .                   .          .          .                   .          .          .              */
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
-- line 83 ----------------------------------------
-- line 91 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /**
         .           .           .                   .          .          .                   .          .          .              *  @brief  Convert a value to an rvalue.
         .           .           .                   .          .          .                   .          .          .              *  @param  __t  A thing of arbitrary type.
         .           .           .                   .          .          .                   .          .          .              *  @return The parameter cast to an rvalue-reference to allow moving it.
         .           .           .                   .          .          .                   .          .          .             */
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
         .           .           .                   .          .          .                   .          .          .               constexpr typename std::remove_reference<_Tp>::type&&
     4,492 ( 0.00%) 96 ( 0.24%)  8 ( 0.13%)          0          0          0               2,246 ( 0.00%) 0          0               move(_Tp&& __t) noexcept
     3,369 ( 0.00%)  0           0               3,369 ( 0.00%) 0          0                   0          0          0               { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
         .           .           .                   .          .          .                   .          .          .               struct __move_if_noexcept_cond
         .           .           .                   .          .          .                   .          .          .               : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
         .           .           .                   .          .          .                   .          .          .                               is_copy_constructible<_Tp>>::type { };
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /**
-- line 108 ----------------------------------------
-- line 174 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .              *  @return   Nothing.
         .           .           .                   .          .          .                   .          .          .             */
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp>
         .           .           .                   .          .          .                   .          .          .               inline
         .           .           .                   .          .          .                   .          .          .           #if __cplusplus >= 201103L
         .           .           .                   .          .          .                   .          .          .               typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         .           .           .                   .          .          .                   .          .          .           			      is_move_constructible<_Tp>,
         .           .           .                   .          .          .                   .          .          .           			      is_move_assignable<_Tp>>::value>::type
     1,737 ( 0.00%) 89 ( 0.23%)  7 ( 0.11%)        193 ( 0.00%) 0          0                 772 ( 0.00%) 0          0               swap(_Tp& __a, _Tp& __b)
         .           .           .                   .          .          .                   .          .          .               noexcept(__and_<is_nothrow_move_constructible<_Tp>,
         .           .           .                   .          .          .                   .          .          .           	            is_nothrow_move_assignable<_Tp>>::value)
         .           .           .                   .          .          .                   .          .          .           #else
         .           .           .                   .          .          .                   .          .          .               void
         .           .           .                   .          .          .                   .          .          .               swap(_Tp& __a, _Tp& __b)
         .           .           .                   .          .          .                   .          .          .           #endif
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 // concept requirements
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
         .           .           .                   .          .          .                   .          .          .           
       969 ( 0.00%)  3 ( 0.01%)  3 ( 0.05%)        388 ( 0.00%) 2 ( 0.00%) 0                 388 ( 0.00%) 0          0                 _Tp __tmp = _GLIBCXX_MOVE(__a);
     1,162 ( 0.00%) 82 ( 0.21%)  4 ( 0.06%)        581 ( 0.00%) 0          0                 388 ( 0.00%) 0          0                 __a = _GLIBCXX_MOVE(__b);
     1,162 ( 0.00%)  2 ( 0.01%)  2 ( 0.03%)        388 ( 0.00%) 0          0                 388 ( 0.00%) 0          0                 __b = _GLIBCXX_MOVE(__tmp);
     1,158 ( 0.00%)  1 ( 0.00%)  1 ( 0.02%)        772 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .                   .          .          .                   .          .          .             // DR 809. std::swap should be overloaded for array types.
         .           .           .                   .          .          .                   .          .          .             /// Swap the contents of two arrays.
         .           .           .                   .          .          .                   .          .          .             template<typename _Tp, size_t _Nm>
         .           .           .                   .          .          .                   .          .          .               inline
         .           .           .                   .          .          .                   .          .          .           #if __cplusplus >= 201103L
         .           .           .                   .          .          .                   .          .          .               typename enable_if<__is_swappable<_Tp>::value>::type
-- line 204 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp
--------------------------------------------------------------------------------
Ir                   I1mr         ILmr        Dr                   D1mr         DLmr        Dw                  D1mw        DLmw       

-- line 18 ----------------------------------------
          .            .           .                    .            .           .                   .           .          .           #include <cstdlib>
          .            .           .                    .            .           .                   .           .          .           #include <ctime>
          .            .           .                    .            .           .                   .           .          .           #include <mutex>
          .            .           .                    .            .           .                   .           .          .           #include <utility>
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           namespace TinyLog {
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /*Global Logger Config*/
          6 ( 0.00%)   0           0                    0            0           0                   2 ( 0.00%)  0          0           LogConfig kLogConfig;
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* Logger 单例变量的定义 */
          .            .           .                    .            .           .                   .           .          .           Logger *Logger::_logger = nullptr;
          .            .           .                    .            .           .                   .           .          .           std::mutex Logger::_mtx;
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 用于回收单例资源 */
          4 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)           0            0           0                   1 ( 0.00%)  0          0           Logger::GC gcVariabel;
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 线程局部变量, 对日期和时间部分进行缓存, 每个线程拥有独立的缓存*/
          .            .           .                    .            .           .                   .           .          .           thread_local time_t prevSecond;
          .            .           .                    .            .           .                   .           .          .           thread_local char timeStr[64];
384,000,032 ( 2.45%)   1 ( 0.00%)  0          128,000,008 ( 3.11%)   0           0          64,000,008 ( 2.07%)  2 ( 0.00%) 0           thread_local Logger::Buffer buffer;
          .            .           .                    .            .           .                   .           .          .           
 32,000,000 ( 0.20%)   1 ( 0.00%)  1 ( 0.02%)   4,000,000 ( 0.10%)   1 ( 0.00%)  0          12,000,000 ( 0.39%)  9 ( 0.00%) 8 ( 0.00%)  Logger *Logger::getInstance() {
          .            .           .                    .            .           .                   .           .          .             /* 双检锁实现单例模式 */
 12,000,000 ( 0.08%)   0           0            4,000,000 ( 0.10%)  20 ( 0.04%)  7 ( 0.02%)          0           0          0             if (_logger == nullptr) {
          .            .           .                    .            .           .                   .           .          .               /* RAII lock template */
          7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)           0            0           0                   2 ( 0.00%)  0          0               std::unique_lock<std::mutex> lock(_mtx);
          3 ( 0.00%)   0           0                    1 ( 0.00%)   0           0                   0           0          0               if (_logger == nullptr)
          3 ( 0.00%)   0           0                    0            0           0                   2 ( 0.00%)  0          0                 _logger = new Logger;
          .            .           .                    .            .           .                   .           .          .             }
  4,000,000 ( 0.03%)   0           0            4,000,000 ( 0.10%)   0           0                   0           0          0             return _logger;
 28,000,000 ( 0.18%)   1 ( 0.00%)  0           20,000,000 ( 0.49%)   0           0                   0           0          0           }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 默认日志等级为: INFO*/
          6 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)           3 ( 0.00%)   0           0                   1 ( 0.00%)  0          0           inline Logger::LogLevel defaultLogLevel() { return kLogConfig.logLevel; }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           const char *LogLevelStr[Logger::LogLevel::numOfLevels] = {
          .            .           .                    .            .           .                   .           .          .               "TRACE", "DEBUG", "INFO ", "WARN ", "ERROR", "FATAL",
          .            .           .                    .            .           .                   .           .          .           };
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 默认输出路径为stdout */
          .            .           .                    .            .           .                   .           .          .           inline void defaultOutput(const char *_msg, size_t _len) {
          .            .           .                    .            .           .                   .           .          .             size_t n = fwrite(_msg, 1, _len, stdout);
          .            .           .                    .            .           .                   .           .          .             (void)n;
          .            .           .                    .            .           .                   .           .          .           }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 默认flush函数*/
          .            .           .                    .            .           .                   .           .          .           inline void defaultFlush() { fflush(stdout); }
          .            .           .                    .            .           .                   .           .          .           
          2 ( 0.00%)   0           0                    0            0           0                   2 ( 0.00%)  1 ( 0.00%) 1 ( 0.00%)  Logger::LogLevel _global_logLevel = defaultLogLevel();
          7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)           0            0           0                   2 ( 0.00%)  0          0           Logger::outPutFunc _global_outPutFunc = defaultOutput;
          7 ( 0.00%)   0           0                    0            0           0                   2 ( 0.00%)  0          0           Logger::flushFunc _global_flushFunc = defaultFlush;
          .            .           .                    .            .           .                   .           .          .           
          5 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)           0            0           0                   2 ( 0.00%)  0          0           void Logger::setOutput(Logger::outPutFunc _func) {
          6 ( 0.00%)   0           0                    1 ( 0.00%)   0           0                   2 ( 0.00%)  0          0             _global_outPutFunc = std::move(_func);
          3 ( 0.00%)   0           0                    2 ( 0.00%)   0           0                   0           0          0           }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           void Logger::setFlush(Logger::flushFunc _func) {
          .            .           .                    .            .           .                   .           .          .             _global_flushFunc = std::move(_func);
          .            .           .                    .            .           .                   .           .          .           }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 不能被内联 */
  9,600,000 ( 0.06%)  17 ( 0.04%) 10 ( 0.16%)   4,800,000 ( 0.12%)  20 ( 0.04%)  7 ( 0.02%)  1,600,000 ( 0.05%)  0          0           Logger::LogLevel Logger::getLogLevel() { return kLogConfig.logLevel; }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 不能被内联 */
         12 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)           3 ( 0.00%)   0           0                   3 ( 0.00%)  0          0           void Logger::setConfig(const LogConfig &_config) { kLogConfig = _config; }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* 设置日志时间, 使用TLS进行缓存优化 */
 28,000,000 ( 0.18%)   2 ( 0.01%)  1 ( 0.02%)   4,000,000 ( 0.10%)   0           0           8,000,000 ( 0.26%)  0          0           inline void Logger::formatTime() {
  8,000,000 ( 0.05%)   0           0                    0            0           0           8,000,000 ( 0.26%)  5 ( 0.00%) 0             Timestamp current = Timestamp::now();
 16,000,000 ( 0.10%)   0           0                    0            0           0           8,000,000 ( 0.26%)  1 ( 0.00%) 0             time_t curSecond = current.getSeconds();
 60,000,000 ( 0.38%)   1 ( 0.00%)  1 ( 0.02%)           0            0           0           4,000,000 ( 0.13%)  0          0             int milliSecond = static_cast<int>(current.getMilliSeconds() %
  4,000,000 ( 0.03%)   0           0                    0            0           0           4,000,000 ( 0.13%)  0          0                                                Timestamp::kmilliSecondsPerSecond);
          .            .           .                    .            .           .                   .           .          .             /* 无法使用TLS时间缓存进行优化 */
 16,000,000 ( 0.10%)   1 ( 0.00%)  1 ( 0.02%)   8,000,000 ( 0.19%)  86 ( 0.17%) 27 ( 0.08%)          0           0          0             if (curSecond != prevSecond) {
        356 ( 0.00%)   0           0                  178 ( 0.00%)   0           0                 178 ( 0.00%)  0          0               prevSecond = curSecond;
          .            .           .                    .            .           .                   .           .          .               /* 重新写入时间到TLS中 */
          .            .           .                    .            .           .                   .           .          .               struct tm tm_time;
        890 ( 0.00%)   0           0                    0            0           0                 178 ( 0.00%)  0          0               localtime_r(&curSecond, &tm_time);
          .            .           .                    .            .           .                   .           .          .           
      3,738 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         890 ( 0.00%)   0           0                 712 ( 0.00%)  0          0               snprintf(timeStr, sizeof(timeStr), "%4d-%02d-%02d %02d:%02d:%02d-",
        356 ( 0.00%)   0           0                  356 ( 0.00%)   0           0                   0           0          0                        tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
          .            .           .                    .            .           .                   .           .          .                        tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
          .            .           .                    .            .           .                   .           .          .             }
          .            .           .                    .            .           .                   .           .          .             /* 写入日志行缓冲区中: 精确到秒 */
 32,000,000 ( 0.20%)  11 ( 0.03%)  8 ( 0.13%)   4,000,000 ( 0.10%)   0           0           8,000,000 ( 0.26%)  0          0             buffer.append(timeStr, 20);
          .            .           .                    .            .           .                   .           .          .             /* 写入毫秒 */
          .            .           .                    .            .           .                   .           .          .             char mStr[6];
 32,000,000 ( 0.20%)   2 ( 0.01%)  2 ( 0.03%)   4,000,000 ( 0.10%)   1 ( 0.00%)  0           4,000,000 ( 0.13%)  0          0             snprintf(mStr, sizeof(mStr), "%03d ", milliSecond);
 28,000,000 ( 0.18%)   0           0                    0            0           0           8,000,000 ( 0.26%)  1 ( 0.00%) 0             buffer.append(mStr, 4);
 24,000,000 ( 0.15%)   0           0           16,000,000 ( 0.39%)   3 ( 0.01%)  1 ( 0.00%)          0           0          0           }
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .           /* file和line在编译期获取其长度fileLen, lineLen */
          .            .           .                    .            .           .                   .           .          .           void Logger::append(const char *file, size_t fileLen, const char *line,
          .            .           .                    .            .           .                   .           .          .                               size_t lineLen, const char *fmt, Logger::LogLevel level,
 68,000,000 ( 0.43%) 214 ( 0.54%)  2 ( 0.03%)   4,000,000 ( 0.10%)   4 ( 0.01%)  0          40,000,000 ( 1.30%) 10 ( 0.00%) 0                               ...) {
          .            .           .                    .            .           .                   .           .          .             /* 处理日志中的时间 */
  4,000,000 ( 0.03%)   0           0                    0            0           0           4,000,000 ( 0.13%)  0          0             formatTime();
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .             /* 添加线程号: ID*/
 20,000,000 ( 0.13%) 178 ( 0.45%)  0                    0            0           0           8,000,000 ( 0.26%)  0          0             buffer.append("tid:", 4);
 36,000,000 ( 0.23%)  52 ( 0.13%) 13 ( 0.21%)           0            0           0          16,000,000 ( 0.52%)  1 ( 0.00%) 0             buffer.append(ThreadInfo::getTidStr(), ThreadInfo::getTidStrlen());
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .             /* 源文件[line:行号] - 日志级别
          .            .           .                    .            .           .                   .           .          .              *  example:
          .            .           .                    .            .           .                   .           .          .              *  test.py[line:233] - INFO: 正文
          .            .           .                    .            .           .                   .           .          .              */
 28,000,000 ( 0.18%)   0           0            8,000,000 ( 0.19%)  24 ( 0.05%)  5 ( 0.02%)  8,000,000 ( 0.26%)  0          0             buffer.append(file, fileLen);
 20,000,000 ( 0.13%)   0           0                    0            0           0           8,000,000 ( 0.26%)  1 ( 0.00%) 0             buffer.append("[line:", 6);
 28,000,000 ( 0.18%)  46 ( 0.12%) 14 ( 0.22%)   8,000,000 ( 0.19%)   3 ( 0.01%)  0           8,000,000 ( 0.26%)  0          0             buffer.append(line, lineLen);
 20,000,000 ( 0.13%)   0           0                    0            0           0           8,000,000 ( 0.26%)  1 ( 0.00%) 0             buffer.append("] - ", 4);
 44,000,000 ( 0.28%)   2 ( 0.01%)  1 ( 0.02%)   8,000,000 ( 0.19%)  89 ( 0.18%) 25 ( 0.08%)  8,000,000 ( 0.26%)  0          0             buffer.append(LogLevelStr[level], 5);
 20,000,000 ( 0.13%) 177 ( 0.45%)  1 ( 0.02%)           0            0           0           8,000,000 ( 0.26%)  0          0             buffer.append(": ", 2);
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .             /* 正文, 使用va_list、va_arg和va_end等宏来处理, 其原理是
          .            .           .                    .            .           .                   .           .          .              * cdelc_ 参数从右到左压栈, 第一个参数在栈顶 */
          .            .           .                    .            .           .                   .           .          .             va_list argPtr;
 24,000,000 ( 0.15%)   0           0                    0            0           0          16,000,000 ( 0.52%) 15 ( 0.00%) 5 ( 0.00%)    va_start(argPtr, fmt);
 60,000,000 ( 0.38%)   3 ( 0.01%)  3 ( 0.05%)   4,000,000 ( 0.10%)   1 ( 0.00%)  0          24,000,000 ( 0.78%)  9 ( 0.00%) 1 ( 0.00%)    int n = vsnprintf(buffer.current(), buffer.avail(), fmt, argPtr);
          .            .           .                    .            .           .                   .           .          .             va_end(argPtr);
 28,000,000 ( 0.18%)  44 ( 0.11%) 12 ( 0.19%)   4,000,000 ( 0.10%)   1 ( 0.00%)  0           8,000,000 ( 0.26%)  1 ( 0.00%) 1 ( 0.00%)    buffer.addLen(static_cast<size_t>(n));
          .            .           .                    .            .           .                   .           .          .           
          .            .           .                    .            .           .                   .           .          .             /* appen到outPutfunc */
          .            .           .                    .            .           .                   .           .          .             /* used for BenchMark*/
 16,000,000 ( 0.10%)   0           0                    0            0           0           4,000,000 ( 0.13%)  0          0             if (_global_outPutFunc)
 44,000,000 ( 0.28%)   1 ( 0.00%)  1 ( 0.02%)           0            0           0          20,000,000 ( 0.65%)  1 ( 0.00%) 0               _global_outPutFunc(buffer.data(), buffer.size());
          .            .           .                    .            .           .                   .           .          .             /* 缓冲区清空, 等待线程下一条日志记录, 因为其是TLS变量*/
 12,000,000 ( 0.08%)   0           0                    0            0           0           8,000,000 ( 0.26%)  0          0             buffer.clear();
          .            .           .                    .            .           .                   .           .          .             /* 学习muduo的做法 */
  8,000,000 ( 0.05%)   0           0            4,000,000 ( 0.10%)  37 ( 0.07%) 12 ( 0.04%)          0           0          0             if (level == Logger::FATAL) {
          .            .           .                    .            .           .                   .           .          .               if (_global_flushFunc)
          .            .           .                    .            .           .                   .           .          .                 _global_flushFunc();
          .            .           .                    .            .           .                   .           .          .               abort();
          .            .           .                    .            .           .                   .           .          .             }
 36,000,000 ( 0.23%)  41 ( 0.10%) 11 ( 0.18%)  24,000,000 ( 0.58%) 103 ( 0.21%) 36 ( 0.11%)          0           0          0           }
          .            .           .                    .            .           .                   .           .          .           
256,000,029 ( 1.64%)   5 ( 0.01%)  4 ( 0.06%)  64,000,006 ( 1.56%)  77 ( 0.15%) 23 ( 0.07%)         13 ( 0.00%)  0          0           } // namespace TinyLog

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Asynlog.cpp
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr        Dr                  D1mr        DLmr        Dw                  D1mw       DLmw       

-- line 15 ----------------------------------------
         .            .           .                   .           .           .                   .          .          .           #include <chrono>
         .            .           .                   .           .           .                   .          .          .           #include <cstddef>
         .            .           .                   .           .           .                   .          .          .           #include <memory>
         .            .           .                   .           .           .                   .          .          .           #include <mutex>
         .            .           .                   .           .           .                   .          .          .           #include <type_traits>
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           namespace TinyLog {
         .            .           .                   .           .           .                   .          .          .           
        14 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          1 ( 0.00%)  0           0                   9 ( 0.00%) 0          0           AsynLog::AsynLog(const std::string &_basename, size_t _rollSize,
         .            .           .                   .           .           .                   .          .          .                            int _flushInterval, int _bufferNums,
         .            .           .                   .           .           .                   .          .          .                            FileWriterType _writerType)
         .            .           .                   .           .           .                   .          .          .               : basename_(_basename), rollSize_(_rollSize),
         .            .           .                   .           .           .                   .          .          .                 flushInterval_(_flushInterval), started_(false), counter_(1),
         .            .           .                   .           .           .                   .          .          .                 bufferSize_(_bufferNums), writerType_(_writerType),
         .            .           .                   .           .           .                   .          .          .                 head(std::make_shared<BufferNode>()),
        55 ( 0.00%)   4 ( 0.01%)  4 ( 0.06%)         19 ( 0.00%)  0           0                  14 ( 0.00%) 0          0                 tail(std::make_shared<BufferNode>()) {
         .            .           .                   .           .           .                   .          .          .             /* 初始化 head 和 tail 的指针域*/
        10 ( 0.00%)   0           0                   2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0             head->next_ = tail;
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0             tail->prev_ = head;
         8 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          5 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
        40 ( 0.00%)   4 ( 0.01%)  4 ( 0.06%)          9 ( 0.00%)  0           0                  12 ( 0.00%) 0          0           AsynLog::~AsynLog() {
         6 ( 0.00%)   0           0                   1 ( 0.00%)  0           0                   1 ( 0.00%) 0          0             if (started_)
         3 ( 0.00%)   0           0                   1 ( 0.00%)  0           0                   1 ( 0.00%) 0          0               stop();
         .            .           .                   .           .           .                   .          .          .             /* 回收缓冲区资源, 裸指针的时候需要这样做 */
         .            .           .                   .           .           .                   .          .          .             // BufferNodePtr cur = head;
         .            .           .                   .           .           .                   .          .          .             // while (cur != nullptr) {
         .            .           .                   .           .           .                   .          .          .             //   BufferNodePtr nxt = cur->next_;
         .            .           .                   .           .           .                   .          .          .             //   delete cur;
         .            .           .                   .           .           .                   .          .          .             //   cur = nxt;
         .            .           .                   .           .           .                   .          .          .             // }
         .            .           .                   .           .           .                   .          .          .             /* shared_ptr节点会造成循环引用而导致无法释放, 因此手动释放 */
         9 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)  0           0                   2 ( 0.00%) 0          0             BufferNodePtr cur = head;
       629 ( 0.00%)   0           0                   0           0           0                  90 ( 0.00%) 0          0             while (cur != nullptr) {
       979 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0           0           0                 267 ( 0.00%) 0          0               BufferNodePtr nxt = cur->next_;
     2,047 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0           0           0                 534 ( 0.00%) 0          0               cur->prev_ = cur->next_ = nullptr;
       445 ( 0.00%)   0           0                   0           0           0                  89 ( 0.00%) 0          0               cur = nxt;
         .            .           .                   .           .           .                   .          .          .             }
         8 ( 0.00%)   0           0                   5 ( 0.00%)  1 ( 0.00%)  0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
       870 ( 0.00%) 166 ( 0.42%)  4 ( 0.06%)         87 ( 0.00%)  0           0                 435 ( 0.00%) 0          0           AsynLog::BufferNodePtr AsynLog::newBufferNode() {
       261 ( 0.00%)   0           0                  87 ( 0.00%)  0           0                  87 ( 0.00%) 0          0             BufferNodePtr cur = std::make_shared<BufferNode>();
     1,218 ( 0.00%)  83 ( 0.21%)  2 ( 0.03%)         87 ( 0.00%)  0           0                 348 ( 0.00%) 0          0             cur->buff_ = std::make_unique<Buffer>();
        87 ( 0.00%)   0           0                   0           0           0                   0          0          0             return cur;
       696 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        522 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 前端和后端的唯一接口 */
44,000,000 ( 0.28%)  49 ( 0.12%) 12 ( 0.19%)  4,000,000 ( 0.10%)  2 ( 0.00%)  0          24,000,000 ( 0.78%) 2 ( 0.00%) 0           void AsynLog::append(const char *_msg, size_t _len) {
         .            .           .                   .           .           .                   .          .          .             /* RAII lock */
24,000,000 ( 0.15%)   0           0           4,000,000 ( 0.10%)  0           0           4,000,000 ( 0.13%) 0          0             std::unique_lock<std::mutex> lock(mtx_);
20,000,000 ( 0.13%)   0           0           4,000,000 ( 0.10%)  0           0           8,000,000 ( 0.26%) 0          0             std::unique_ptr<Buffer> &curBuff = curBuffNode->buff_;
         .            .           .                   .           .           .                   .          .          .           
36,000,000 ( 0.23%)  85 ( 0.21%)  1 ( 0.02%)  8,000,000 ( 0.19%)  0           0           8,000,000 ( 0.26%) 0          0             if (curBuff->avail() > _len) {
39,998,960 ( 0.26%)   0           0          11,999,688 ( 0.29%)  3 ( 0.01%)  0           7,999,792 ( 0.26%) 0          0               curBuff->append(_msg, _len);
 3,999,896 ( 0.03%) 100 ( 0.25%)  3 ( 0.05%)          0           0           0                   0          0          0               return;
         .            .           .                   .           .           .                   .          .          .             }
         .            .           .                   .           .           .                   .          .          .             /* 当前缓冲区写满了, 从环形缓冲区中移除该bufferNode */
         .            .           .                   .           .           .                   .          .          .             /* curPtr = curBuffNode */
     1,248 ( 0.00%)   0           0                 208 ( 0.00%)  0           0                 208 ( 0.00%) 0          0             assert(curBuffNode == head->next_);
         .            .           .                   .           .           .                   .          .          .             /* 将当前缓冲区加入待落盘队列 */
       728 ( 0.00%) 104 ( 0.26%)  1 ( 0.02%)        208 ( 0.00%)  0           0                 104 ( 0.00%) 0          0             writeBufferNode.push_back(curBuffNode);
       832 ( 0.00%) 104 ( 0.26%)  1 ( 0.02%)        104 ( 0.00%)  0           0                 208 ( 0.00%) 0          0             removeHead();
       520 ( 0.00%)   0           0                 312 ( 0.00%)  0           0                 104 ( 0.00%) 0          0             bufferSize_ -= 1;
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .             /* 如果无空余缓冲, 则新建缓冲区 BufferNode, 并加入环形缓冲区中 */
       416 ( 0.00%)   0           0                 208 ( 0.00%)  0           0                   0          0          0             if (bufferSize_ == 0) {
       656 ( 0.00%)   3 ( 0.01%)  3 ( 0.05%)         82 ( 0.00%)  0           0                 164 ( 0.00%) 0          0               BufferNodePtr newNode = newBufferNode();
     1,066 ( 0.00%)   0           0                  82 ( 0.00%)  0           0                 246 ( 0.00%) 0          0               addTail(newNode);
       410 ( 0.00%)  16 ( 0.04%)  9 ( 0.14%)        246 ( 0.00%)  0           0                  82 ( 0.00%) 0          0               bufferSize_ += 1;
         .            .           .                   .           .           .                   .          .          .             }
         .            .           .                   .           .           .                   .          .          .             /* 更新 curBuffNode, 然后写入消息 */
     1,040 ( 0.00%) 109 ( 0.28%)  3 ( 0.05%)        208 ( 0.00%)  0           0                 208 ( 0.00%) 0          0             curBuffNode = head->next_;
     1,248 ( 0.00%)   0           0                 312 ( 0.00%)  0           0                 312 ( 0.00%) 0          0             curBuffNode->buff_->append(_msg, _len);
         .            .           .                   .           .           .                   .          .          .             /* 唤醒后台线程进行落盘操作 */
16,000,520 ( 0.10%) 175 ( 0.44%)  1 ( 0.02%)        104 ( 0.00%)  0           0           4,000,104 ( 0.13%) 0          0             cv_.notify_one();
28,000,000 ( 0.18%)   2 ( 0.01%)  0          20,000,000 ( 0.49%) 52 ( 0.10%) 20 ( 0.06%)          0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 后台日志线程 */
         9 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)  0           0                   4 ( 0.00%) 0          0           void AsynLog::threadFunc() {
         7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)  0           0                   1 ( 0.00%) 0          0             assert(started_ == true);
         4 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  1 ( 0.00%)  0                   0          0          0             assert(bufferSize_ > 0);
         4 ( 0.00%)   0           0                   1 ( 0.00%)  0           0                   1 ( 0.00%) 0          0             counter_.countdown();
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .             /* 构建默认大小的环形缓冲区 */
        29 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         19 ( 0.00%)  0           0                   1 ( 0.00%) 1 ( 0.00%) 1 ( 0.00%)    for (int i = 0; i < bufferSize_; i++) {
        32 ( 0.00%)   0           0                   4 ( 0.00%)  0           0                   8 ( 0.00%) 0          0               auto cur = newBufferNode();
        52 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          4 ( 0.00%)  0           0                  12 ( 0.00%) 0          0               addHead(cur);
         .            .           .                   .           .           .                   .          .          .             }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .             /* 初始化curBuffNode, 让其指向head -> next */
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0             curBuffNode = head->next_;
         .            .           .                   .           .           .                   .          .          .             /* 日志文件写的具体实现 */
        11 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          5 ( 0.00%)  0           0                   2 ( 0.00%) 0          0             LogFile fileWriter(basename_, rollSize_, writerType_);
         .            .           .                   .           .           .                   .          .          .           
        20 ( 0.00%)   3 ( 0.01%)  2 ( 0.03%)          3 ( 0.00%)  0           0                   3 ( 0.00%) 0          0             while (started_) {
         .            .           .                   .           .           .                   .          .          .               /* RAII lock block */
         .            .           .                   .           .           .                   .          .          .               {
        12 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 std::unique_lock<std::mutex> lock(mtx_);
         .            .           .                   .           .           .                   .          .          .                 /* 如果写的太慢会被刷盘间隔唤醒, 唤醒后进行刷盘,
         .            .           .                   .           .           .                   .          .          .                  * 不能用while循环判断缓冲区是否为空, 如果缓冲区一直为空, 则导致死锁*/
        12 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 if (writeBufferNode.empty())
        13 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                   cv_.wait_for(lock, std::chrono::seconds(flushInterval_));
         .            .           .                   .           .           .                   .          .          .           
        18 ( 0.00%)   3 ( 0.01%)  3 ( 0.05%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 if (writeBufferNode.empty() and curBuffNode->buff_->size() == 0)
         .            .           .                   .           .           .                   .          .          .                   continue;
         .            .           .                   .           .           .                   .          .          .                 /* 将当前缓冲区加入待落盘队列 */
        14 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          4 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 writeBufferNode.push_back(curBuffNode);
        16 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          2 ( 0.00%)  0           0                   4 ( 0.00%) 0          0                 removeHead();
        10 ( 0.00%)   0           0                   6 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 bufferSize_ -= 1;
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .                 /* 如果之后无缓冲区则新建 */
         8 ( 0.00%)   0           0                   4 ( 0.00%)  0           0                   0          0          0                 if (bufferSize_ == 0) {
         8 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                   auto newNode = newBufferNode();
        13 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          1 ( 0.00%)  0           0                   3 ( 0.00%) 0          0                   addTail(newNode);
         5 ( 0.00%)   0           0                   3 ( 0.00%)  0           0                   1 ( 0.00%) 0          0                   bufferSize_ += 1;
         .            .           .                   .           .           .                   .          .          .                 }
         .            .           .                   .           .           .                   .          .          .                 /* 更新 curBuffNode */
        32 ( 0.00%)   3 ( 0.01%)  3 ( 0.05%)          4 ( 0.00%)  0           0                   6 ( 0.00%) 0          0                 curBuffNode = head->next_;
         .            .           .                   .           .           .                   .          .          .               }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .               /* 异步写入日志, 限制最大写入缓冲区数目*/
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          2 ( 0.00%)  0           0                   4 ( 0.00%) 2 ( 0.00%) 0               int mxNums = std::min(static_cast<int>(writeBufferNode.size()),
        12 ( 0.00%)   0           0                   2 ( 0.00%)  0           0                   4 ( 0.00%) 0          0                                     kLogConfig.fileOption.maxBuffToWrite);
       108 ( 0.00%)  15 ( 0.04%)  7 ( 0.11%)         64 ( 0.00%) 20 ( 0.04%)  6 ( 0.02%)          2 ( 0.00%) 0          0               for (int i = 0; i < mxNums; i++) {
       300 ( 0.00%)  14 ( 0.04%)  6 ( 0.10%)         40 ( 0.00%)  0           0                  60 ( 0.00%) 0          0                 BufferNodePtr node = writeBufferNode[i];
       420 ( 0.00%)  17 ( 0.04%) 10 ( 0.16%)          0           0           0                 140 ( 0.00%) 0          0                 fileWriter.append(node->buff_->data(), node->buff_->size());
         .            .           .                   .           .           .                   .          .          .               }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .               /* Flush */
         6 ( 0.00%)   0           0                   0           0           0                   2 ( 0.00%) 0          0               fileWriter.flush();
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .               /* RAII lock block*/
         .            .           .                   .           .           .                   .          .          .               {
         .            .           .                   .           .           .                   .          .          .                 /* 归还buffer到环形缓冲区中 */
        18 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          2 ( 0.00%)  0           0                   4 ( 0.00%) 0          0                 std::unique_lock<std::mutex> lock(mtx_);
     1,626 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          6 ( 0.00%)  0           0                 436 ( 0.00%) 1 ( 0.00%) 0                 for (auto &node : writeBufferNode) {
         .            .           .                   .           .           .                   .          .          .                   /* 必须清空后加入环形缓冲区 */
       742 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        106 ( 0.00%)  0           0                 318 ( 0.00%) 0          0                   node->buff_->clear();
     1,378 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        212 ( 0.00%)  0           0                 318 ( 0.00%) 0          0                   addTail(node);
       530 ( 0.00%)   0           0                 318 ( 0.00%)  0           0                 106 ( 0.00%) 0          0                   bufferSize_ += 1;
         .            .           .                   .           .           .                   .          .          .                 }
         8 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          2 ( 0.00%)  0           0                   2 ( 0.00%) 0          0                 writeBufferNode.clear();
         .            .           .                   .           .           .                   .          .          .               }
         .            .           .                   .           .           .                   .          .          .             }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .             /* Last Flush */
         3 ( 0.00%)   0           0                   0           0           0                   1 ( 0.00%) 0          0             fileWriter.flush();
         8 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          5 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 必须在临界区中执行, 即被 mutex 保护 */
        28 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0           0           0                  16 ( 0.00%) 0          0           void AsynLog::addHead(BufferNodePtr cur) {
        48 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          8 ( 0.00%)  0           0                  12 ( 0.00%) 0          0             cur->next_ = head->next_;
        48 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          8 ( 0.00%)  0           0                  12 ( 0.00%) 0          0             head->next_->prev_ = cur;
        36 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          8 ( 0.00%)  0           0                   8 ( 0.00%) 0          0             head->next_ = cur;
        36 ( 0.00%)   0           0                   8 ( 0.00%)  0           0                   8 ( 0.00%) 0          0             cur->prev_ = head;
        20 ( 0.00%)   0           0                  12 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 必须在临界区中执行, 即被 mutex 保护 */
     1,060 ( 0.00%) 112 ( 0.28%)  4 ( 0.06%)        106 ( 0.00%)  0           0                 530 ( 0.00%) 0          0           AsynLog::BufferNodePtr AsynLog::removeHead() {
       424 ( 0.00%)   0           0                 212 ( 0.00%)  0           0                   0          0          0             assert(bufferSize_ != 0);
       954 ( 0.00%)  88 ( 0.22%)  4 ( 0.06%)        212 ( 0.00%)  0           0                 212 ( 0.00%) 0          0             BufferNodePtr ret = head->next_;
     1,696 ( 0.00%)  14 ( 0.04%)  7 ( 0.11%)        212 ( 0.00%)  0           0                 424 ( 0.00%) 0          0             head->next_ = head->next_->next_;
     1,378 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        212 ( 0.00%)  0           0                 318 ( 0.00%) 0          0             head->next_->prev_ = head;
       106 ( 0.00%)   0           0                   0           0           0                   0          0          0             return ret;
       848 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)        636 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 必须在临界区中执行, 即被 mutex 保护 */
     1,323 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0           0           0                 756 ( 0.00%) 0          0           void AsynLog::addTail(BufferNodePtr cur) {
     2,268 ( 0.00%)   5 ( 0.01%)  5 ( 0.08%)        378 ( 0.00%)  0           0                 567 ( 0.00%) 0          0             cur->prev_ = tail->prev_;
     2,268 ( 0.00%)   0           0                 378 ( 0.00%)  0           0                 567 ( 0.00%) 0          0             tail->prev_->next_ = cur;
     1,701 ( 0.00%)  27 ( 0.07%) 10 ( 0.16%)        378 ( 0.00%)  0           0                 378 ( 0.00%) 0          0             cur->next_ = tail;
     1,701 ( 0.00%)  84 ( 0.21%)  2 ( 0.03%)        378 ( 0.00%)  0           0                 378 ( 0.00%) 0          0             tail->prev_ = cur;
       945 ( 0.00%)   0           0                 567 ( 0.00%)  0           0                   0          0          0           }
         .            .           .                   .           .           .                   .          .          .           
         .            .           .                   .           .           .                   .          .          .           /* 必须在临界区中执行, 即被 mutex 保护 */
         .            .           .                   .           .           .                   .          .          .           AsynLog::BufferNodePtr AsynLog::removeTail() {
         .            .           .                   .           .           .                   .          .          .             assert(bufferSize_ != 0);
         .            .           .                   .           .           .                   .          .          .             BufferNodePtr ret = tail->prev_;
         .            .           .                   .           .           .                   .          .          .             tail->prev_ = tail->prev_->prev_;
         .            .           .                   .           .           .                   .          .          .             tail->prev_->next_ = tail;
         .            .           .                   .           .           .                   .          .          .             return ret;
-- line 195 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/tuple
--------------------------------------------------------------------------------
Ir                   I1mr         ILmr        Dr                  D1mr       DLmr       Dw                  D1mw        DLmw       

-- line 68 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .             template<std::size_t _Idx, typename _Head,
          .            .           .                   .          .          .                   .           .          .           	   bool = __empty_not_final<_Head>::value>
          .            .           .                   .          .          .                   .           .          .               struct _Head_base;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             template<std::size_t _Idx, typename _Head>
          .            .           .                   .          .          .                   .           .          .               struct _Head_base<_Idx, _Head, true>
          .            .           .                   .          .          .                   .           .          .               : public _Head
          .            .           .                   .          .          .                   .           .          .               {
        752 ( 0.00%) 172 ( 0.43%)  7 ( 0.11%)          0          0          0                 376 ( 0.00%)  0          0                 constexpr _Head_base()
        564 ( 0.00%)   0           0                 376 ( 0.00%) 0          0                   0           0          0                 : _Head() { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr _Head_base(const _Head& __h)
          .            .           .                   .          .          .                   .           .          .                 : _Head(__h) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr _Head_base(const _Head_base&) = default;
          .            .           .                   .          .          .                   .           .          .                 constexpr _Head_base(_Head_base&&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead>
-- line 85 ----------------------------------------
-- line 105 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .           	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
          .            .           .                   .          .          .                   .           .          .           	: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _Alloc, typename _UHead>
          .            .           .                   .          .          .                   .           .          .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
          .            .           .                   .          .          .                   .           .          .           	: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr _Head&
      1,869 ( 0.00%)   4 ( 0.01%)  2 ( 0.03%)        801 ( 0.00%) 0          0                 534 ( 0.00%)  0          0                 _M_head(_Head_base& __b) noexcept { return __b; }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr const _Head&
          .            .           .                   .          .          .                   .           .          .                 _M_head(const _Head_base& __b) noexcept { return __b; }
          .            .           .                   .          .          .                   .           .          .               };
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             template<std::size_t _Idx, typename _Head>
          .            .           .                   .          .          .                   .           .          .               struct _Head_base<_Idx, _Head, false>
          .            .           .                   .          .          .                   .           .          .               {
        752 ( 0.00%)   0           0                   0          0          0                 376 ( 0.00%)  0          0                 constexpr _Head_base()
        940 ( 0.00%)   0           0                 564 ( 0.00%) 0          0                 188 ( 0.00%)  1 ( 0.00%) 0                 : _M_head_impl() { }
          .            .           .                   .          .          .                   .           .          .           
         40 ( 0.00%)   0           0                   0          0          0                  24 ( 0.00%)  0          0                 constexpr _Head_base(const _Head& __h)
         56 ( 0.00%)   0           0                  40 ( 0.00%) 0          0                   8 ( 0.00%)  0          0                 : _M_head_impl(__h) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr _Head_base(const _Head_base&) = default;
          .            .           .                   .          .          .                   .           .          .                 constexpr _Head_base(_Head_base&&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead>
         72 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0          0          0                  36 ( 0.00%)  0          0                   constexpr _Head_base(_UHead&& __h)
        112 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         62 ( 0.00%) 0          0                  26 ( 0.00%)  0          0           	: _M_head_impl(std::forward<_UHead>(__h)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 _Head_base(allocator_arg_t, __uses_alloc0)
          .            .           .                   .          .          .                   .           .          .                 : _M_head_impl() { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _Alloc>
          .            .           .                   .          .          .                   .           .          .           	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
          .            .           .                   .          .          .                   .           .          .           	: _M_head_impl(allocator_arg, *__a._M_a) { }
          .            .           .                   .          .          .                   .           .          .           
-- line 141 ----------------------------------------
-- line 152 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .           	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
          .            .           .                   .          .          .                   .           .          .           	{ }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _Alloc, typename _UHead>
          .            .           .                   .          .          .                   .           .          .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
          .            .           .                   .          .          .                   .           .          .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr _Head&
      3,402 ( 0.00%)  11 ( 0.03%)  8 ( 0.13%)      1,458 ( 0.00%) 0          0                 972 ( 0.00%)  0          0                 _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr const _Head&
 84,001,953 ( 0.54%)  46 ( 0.12%) 23 ( 0.37%) 36,000,837 ( 0.88%) 0          0          24,000,558 ( 0.78%)  0          0                 _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 _Head _M_head_impl;
          .            .           .                   .          .          .                   .           .          .               };
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             /**
          .            .           .                   .          .          .                   .           .          .              * Contains the actual implementation of the @c tuple template, stored
          .            .           .                   .          .          .                   .           .          .              * as a recursive inheritance hierarchy from the first element (most
          .            .           .                   .          .          .                   .           .          .              * derived class) to the last (least derived class). The @c Idx
-- line 171 ----------------------------------------
-- line 187 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .                 private _Head_base<_Idx, _Head>
          .            .           .                   .          .          .                   .           .          .               {
          .            .           .                   .          .          .                   .           .          .                 template<std::size_t, typename...> friend class _Tuple_impl;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
          .            .           .                   .          .          .                   .           .          .                 typedef _Head_base<_Idx, _Head> _Base;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr _Head&
      4,682 ( 0.00%)  17 ( 0.04%) 15 ( 0.24%)      1,404 ( 0.00%) 0          0               1,404 ( 0.00%)  1 ( 0.00%) 0                 _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr const _Head&
120,002,790 ( 0.77%)  61 ( 0.15%) 25 ( 0.40%) 36,000,837 ( 0.88%) 0          0          36,000,837 ( 1.17%) 23 ( 0.00%) 6 ( 0.00%)        _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr _Inherited&
          7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          3 ( 0.00%) 0          0                   2 ( 0.00%)  0          0                 _M_tail(_Tuple_impl& __t) noexcept { return __t; }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr const _Inherited&
          .            .           .                   .          .          .                   .           .          .                 _M_tail(const _Tuple_impl& __t) noexcept { return __t; }
          .            .           .                   .          .          .                   .           .          .           
        940 ( 0.00%)   4 ( 0.01%)  3 ( 0.05%)          0          0          0                 376 ( 0.00%)  0          0                 constexpr _Tuple_impl()
      1,692 ( 0.00%)  83 ( 0.21%)  2 ( 0.03%)        752 ( 0.00%) 0          0                 376 ( 0.00%)  0          0                 : _Inherited(), _Base() { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 explicit
          .            .           .                   .          .          .                   .           .          .                 constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
          .            .           .                   .          .          .                   .           .          .                 : _Inherited(__tail...), _Base(__head) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead, typename... _UTail, typename = typename
          .            .           .                   .          .          .                   .           .          .                          enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
          .            .           .                   .          .          .                   .           .          .                   explicit
          8 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0          0          0                   5 ( 0.00%)  0          0                   constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
          .            .           .                   .          .          .                   .           .          .           	: _Inherited(std::forward<_UTail>(__tail)...),
         20 ( 0.00%)   0           0                   7 ( 0.00%) 0          0                   4 ( 0.00%)  0          0           	  _Base(std::forward<_UHead>(__head)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .            .           .                   .          .          .                   .           .          .                 // 2729. Missing SFINAE on std::pair::operator=
          .            .           .                   .          .          .                   .           .          .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr
          7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0          0          0                   4 ( 0.00%)  0          0                 _Tuple_impl(_Tuple_impl&& __in)
          .            .           .                   .          .          .                   .           .          .                 noexcept(__and_<is_nothrow_move_constructible<_Head>,
          .            .           .                   .          .          .                   .           .          .           	              is_nothrow_move_constructible<_Inherited>>::value)
          5 ( 0.00%)   0           0                   1 ( 0.00%) 0          0                   2 ( 0.00%)  0          0                 : _Inherited(std::move(_M_tail(__in))),
         19 ( 0.00%)   0           0                   6 ( 0.00%) 0          0                   4 ( 0.00%)  0          0           	_Base(std::forward<_Head>(_M_head(__in))) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename... _UElements>
          .            .           .                   .          .          .                   .           .          .                   constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
          .            .           .                   .          .          .                   .           .          .           	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
          .            .           .                   .          .          .                   .           .          .           	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead, typename... _UTails>
          .            .           .                   .          .          .                   .           .          .                   constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
-- line 239 ----------------------------------------
-- line 326 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .               struct _Tuple_impl<_Idx, _Head>
          .            .           .                   .          .          .                   .           .          .               : private _Head_base<_Idx, _Head>
          .            .           .                   .          .          .                   .           .          .               {
          .            .           .                   .          .          .                   .           .          .                 template<std::size_t, typename...> friend class _Tuple_impl;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 typedef _Head_base<_Idx, _Head> _Base;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr _Head&
      2,850 ( 0.00%)  12 ( 0.03%)  4 ( 0.06%)        855 ( 0.00%) 0          0                 855 ( 0.00%)  8 ( 0.00%) 8 ( 0.00%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 static constexpr const _Head&
          .            .           .                   .          .          .                   .           .          .                 _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
        940 ( 0.00%)  14 ( 0.04%) 12 ( 0.19%)          0          0          0                 376 ( 0.00%)  0          0                 constexpr _Tuple_impl()
      1,128 ( 0.00%)  12 ( 0.03%) 11 ( 0.18%)        564 ( 0.00%) 0          0                 188 ( 0.00%)  0          0                 : _Base() { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 explicit
         48 ( 0.00%)   0           0                   0          0          0                  24 ( 0.00%)  0          0                 constexpr _Tuple_impl(const _Head& __head)
         64 ( 0.00%)   0           0                  32 ( 0.00%) 0          0                   8 ( 0.00%)  0          0                 : _Base(__head) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead>
          .            .           .                   .          .          .                   .           .          .                   explicit
          7 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0          0          0                   4 ( 0.00%)  0          0                   constexpr _Tuple_impl(_UHead&& __head)
         12 ( 0.00%)   0           0                   5 ( 0.00%) 0          0                   2 ( 0.00%)  0          0           	: _Base(std::forward<_UHead>(__head)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .            .           .                   .          .          .                   .           .          .                 // 2729. Missing SFINAE on std::pair::operator=
          .            .           .                   .          .          .                   .           .          .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr
         63 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0          0          0                  36 ( 0.00%)  0          0                 _Tuple_impl(_Tuple_impl&& __in)
          .            .           .                   .          .          .                   .           .          .                 noexcept(is_nothrow_move_constructible<_Head>::value)
        126 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         45 ( 0.00%) 0          0                  27 ( 0.00%)  0          0                 : _Base(std::forward<_Head>(_M_head(__in))) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead>
          .            .           .                   .          .          .                   .           .          .                   constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
          .            .           .                   .          .          .                   .           .          .           	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _UHead>
          .            .           .                   .          .          .                   .           .          .                   constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
          .            .           .                   .          .          .                   .           .          .           	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
-- line 368 ----------------------------------------
-- line 580 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .                 template<typename _Dummy = void,
          .            .           .                   .          .          .                   .           .          .                          typename enable_if<
          .            .           .                   .          .          .                   .           .          .                            _TCC<_Dummy>::template
          .            .           .                   .          .          .                   .           .          .                              _ConstructibleTuple<_Elements...>()
          .            .           .                   .          .          .                   .           .          .                            && _TCC<_Dummy>::template
          .            .           .                   .          .          .                   .           .          .                              _ImplicitlyConvertibleTuple<_Elements...>()
          .            .           .                   .          .          .                   .           .          .                            && (sizeof...(_Elements) >= 1),
          .            .           .                   .          .          .                   .           .          .                          bool>::type=true>
         48 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0          0          0                  24 ( 0.00%)  0          0                   constexpr tuple(const _Elements&... __elements)
         64 ( 0.00%)   0           0                  32 ( 0.00%) 0          0                   8 ( 0.00%)  0          0                 : _Inherited(__elements...) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _Dummy = void,
          .            .           .                   .          .          .                   .           .          .                          typename enable_if<
          .            .           .                   .          .          .                   .           .          .                            _TCC<_Dummy>::template
          .            .           .                   .          .          .                   .           .          .                              _ConstructibleTuple<_Elements...>()
          .            .           .                   .          .          .                   .           .          .                            && !_TCC<_Dummy>::template
          .            .           .                   .          .          .                   .           .          .                              _ImplicitlyConvertibleTuple<_Elements...>()
          .            .           .                   .          .          .                   .           .          .                            && (sizeof...(_Elements) >= 1),
-- line 597 ----------------------------------------
-- line 634 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .                               _ImplicitlyMoveConvertibleTuple<_UElements...>()
          .            .           .                   .          .          .                   .           .          .                             && (sizeof...(_Elements) >= 1),
          .            .           .                   .          .          .                   .           .          .                   bool>::type=false>
          .            .           .                   .          .          .                   .           .          .                   explicit constexpr tuple(_UElements&&... __elements)
          .            .           .                   .          .          .                   .           .          .           	: _Inherited(std::forward<_UElements>(__elements)...) {	}
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr tuple(const tuple&) = default;
          .            .           .                   .          .          .                   .           .          .           
        112 ( 0.00%)   0           0                  32 ( 0.00%) 0          0                  32 ( 0.00%)  0          0                 constexpr tuple(tuple&&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 // Shortcut for the cases where constructors taking tuples
          .            .           .                   .          .          .                   .           .          .                 // must avoid creating temporaries.
          .            .           .                   .          .          .                   .           .          .                 template<typename _Dummy> using _TNTC =
          .            .           .                   .          .          .                   .           .          .                   _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
          .            .           .                   .          .          .                   .           .          .                       _Elements...>;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename... _UElements, typename _Dummy = void, typename
-- line 650 ----------------------------------------
-- line 910 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .               public:
          .            .           .                   .          .          .                   .           .          .                 template <typename _U1 = _T1,
          .            .           .                   .          .          .                   .           .          .                           typename _U2 = _T2,
          .            .           .                   .          .          .                   .           .          .                           typename enable_if<__and_<
          .            .           .                   .          .          .                   .           .          .                                                __is_implicitly_default_constructible<_U1>,
          .            .           .                   .          .          .                   .           .          .                                                __is_implicitly_default_constructible<_U2>>
          .            .           .                   .          .          .                   .           .          .                                              ::value, bool>::type = true>
        940 ( 0.00%)   6 ( 0.02%)  5 ( 0.08%)          0          0          0                 376 ( 0.00%)  0          0           	constexpr tuple()
      1,128 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)        564 ( 0.00%) 0          0                 188 ( 0.00%)  0          0           	: _Inherited() { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template <typename _U1 = _T1,
          .            .           .                   .          .          .                   .           .          .                           typename _U2 = _T2,
          .            .           .                   .          .          .                   .           .          .                           typename enable_if<
          .            .           .                   .          .          .                   .           .          .                             __and_<
          .            .           .                   .          .          .                   .           .          .                               is_default_constructible<_U1>,
          .            .           .                   .          .          .                   .           .          .                               is_default_constructible<_U2>,
          .            .           .                   .          .          .                   .           .          .                               __not_<
-- line 927 ----------------------------------------
-- line 960 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _U1, typename _U2, typename
          .            .           .                   .          .          .                   .           .          .                   enable_if<_TMC::template
          .            .           .                   .          .          .                   .           .          .                               _MoveConstructibleTuple<_U1, _U2>()
          .            .           .                   .          .          .                   .           .          .                             && _TMC::template
          .            .           .                   .          .          .                   .           .          .                               _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
          .            .           .                   .          .          .                   .           .          .           	          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
          .            .           .                   .          .          .                   .           .          .           	bool>::type = true>
          9 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)          0          0          0                   6 ( 0.00%)  0          0                   constexpr tuple(_U1&& __a1, _U2&& __a2)
         18 ( 0.00%)   0           0                   7 ( 0.00%) 0          0                   3 ( 0.00%)  0          0           	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _U1, typename _U2, typename
          .            .           .                   .          .          .                   .           .          .                   enable_if<_TMC::template
          .            .           .                   .          .          .                   .           .          .                               _MoveConstructibleTuple<_U1, _U2>()
          .            .           .                   .          .          .                   .           .          .                             && !_TMC::template
          .            .           .                   .          .          .                   .           .          .                               _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
          .            .           .                   .          .          .                   .           .          .           	          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
          .            .           .                   .          .          .                   .           .          .           	bool>::type = false>
          .            .           .                   .          .          .                   .           .          .                   explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
          .            .           .                   .          .          .                   .           .          .           	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 constexpr tuple(const tuple&) = default;
          .            .           .                   .          .          .                   .           .          .           
         14 ( 0.00%)   0           0                   4 ( 0.00%) 0          0                   4 ( 0.00%)  0          0                 constexpr tuple(tuple&&) = default;
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .                 template<typename _U1, typename _U2, typename
          .            .           .                   .          .          .                   .           .          .                   enable_if<_TMC::template
          .            .           .                   .          .          .                   .           .          .                               _ConstructibleTuple<_U1, _U2>()
          .            .           .                   .          .          .                   .           .          .                             && _TMC::template
          .            .           .                   .          .          .                   .           .          .                               _ImplicitlyConvertibleTuple<_U1, _U2>(),
          .            .           .                   .          .          .                   .           .          .           	bool>::type = true>
          .            .           .                   .          .          .                   .           .          .                   constexpr tuple(const tuple<_U1, _U2>& __in)
-- line 991 ----------------------------------------
-- line 1301 ----------------------------------------
          .            .           .                   .          .          .                   .           .          .               struct tuple_element<__i, tuple<>>
          .            .           .                   .          .          .                   .           .          .               {
          .            .           .                   .          .          .                   .           .          .                 static_assert(__i < tuple_size<tuple<>>::value,
          .            .           .                   .          .          .                   .           .          .           	  "tuple index is in range");
          .            .           .                   .          .          .                   .           .          .               };
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename _Head, typename... _Tail>
          .            .           .                   .          .          .                   .           .          .               constexpr _Head&
      3,715 ( 0.00%)  12 ( 0.03%)  7 ( 0.11%)          0          0          0               1,486 ( 0.00%)  0          0               __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      3,715 ( 0.00%)   0           0               2,229 ( 0.00%) 0          0                 743 ( 0.00%)  0          0               { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename _Head, typename... _Tail>
          .            .           .                   .          .          .                   .           .          .               constexpr const _Head&
 60,001,395 ( 0.38%)  29 ( 0.07%) 19 ( 0.30%)          0          0          0          24,000,558 ( 0.78%)  0          0               __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 60,001,395 ( 0.38%)   0           0          36,000,837 ( 0.88%) 0          0          12,000,279 ( 0.39%)  0          0               { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             /// Return a reference to the ith element of a tuple.
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename... _Elements>
          .            .           .                   .          .          .                   .           .          .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      3,715 ( 0.00%)  13 ( 0.03%) 10 ( 0.16%)          0          0          0               1,486 ( 0.00%)  8 ( 0.00%) 8 ( 0.00%)      get(tuple<_Elements...>& __t) noexcept
      3,715 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)      2,229 ( 0.00%) 0          0                 743 ( 0.00%)  1 ( 0.00%) 0               { return std::__get_helper<__i>(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             /// Return a const reference to the ith element of a const tuple.
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename... _Elements>
          .            .           .                   .          .          .                   .           .          .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
 60,001,395 ( 0.38%)  21 ( 0.05%) 11 ( 0.18%)          0          0          0          24,000,558 ( 0.78%)  2 ( 0.00%) 0               get(const tuple<_Elements...>& __t) noexcept
 60,001,395 ( 0.38%)   1 ( 0.00%)  1 ( 0.02%) 36,000,837 ( 0.88%) 2 ( 0.00%) 0          12,000,279 ( 0.39%)  5 ( 0.00%) 2 ( 0.00%)      { return std::__get_helper<__i>(__t); }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             /// Return an rvalue reference to the ith element of a tuple rvalue.
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename... _Elements>
          .            .           .                   .          .          .                   .           .          .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
         50 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)          0          0          0                  20 ( 0.00%)  0          0               get(tuple<_Elements...>&& __t) noexcept
          .            .           .                   .          .          .                   .           .          .               {
          .            .           .                   .          .          .                   .           .          .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
         50 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         10 ( 0.00%) 0          0                  20 ( 0.00%)  0          0                 return std::forward<__element_type&&>(std::get<__i>(__t));
         20 ( 0.00%)   0           0                  20 ( 0.00%) 0          0                   0           0          0               }
          .            .           .                   .          .          .                   .           .          .           
          .            .           .                   .          .          .                   .           .          .             /// Return a const rvalue reference to the ith element of a const tuple rvalue.
          .            .           .                   .          .          .                   .           .          .             template<std::size_t __i, typename... _Elements>
          .            .           .                   .          .          .                   .           .          .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
          .            .           .                   .          .          .                   .           .          .               get(const tuple<_Elements...>&& __t) noexcept
          .            .           .                   .          .          .                   .           .          .               {
          .            .           .                   .          .          .                   .           .          .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
          .            .           .                   .          .          .                   .           .          .                 return std::forward<const __element_type&&>(std::get<__i>(__t));
-- line 1344 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Timestamp.cpp
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr       Dr                  D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 13 ----------------------------------------
         .           .          .                   .          .          .                  .          .          .           #include "sys/time.h"
         .           .          .                   .          .          .                  .          .          .           #include <cstddef>
         .           .          .                   .          .          .                  .          .          .           #include <cstdio>
         .           .          .                   .          .          .                  .          .          .           #include <ctime>
         .           .          .                   .          .          .                  .          .          .           
         .           .          .                   .          .          .                  .          .          .           namespace TinyLog {
         .           .          .                   .          .          .                  .          .          .           
         .           .          .                   .          .          .                  .          .          .           /* Unix 时间戳 */
28,000,000 ( 0.18%) 10 ( 0.03%) 5 ( 0.08%)  4,000,000 ( 0.10%) 0          0          8,000,000 ( 0.26%) 0          0           Timestamp Timestamp::now() {
         .           .          .                   .          .          .                  .          .          .             struct timeval tv;
16,000,000 ( 0.10%)  0          0                   0          0          0          4,000,000 ( 0.13%) 5 ( 0.00%) 0             gettimeofday(&tv, NULL);
 8,000,000 ( 0.05%)  0          0           4,000,000 ( 0.10%) 0          0          4,000,000 ( 0.13%) 0          0             int64_t seconds = tv.tv_sec;
28,000,000 ( 0.18%)  2 ( 0.01%) 2 ( 0.03%)  4,000,000 ( 0.10%) 0          0          4,000,000 ( 0.13%) 0          0             return Timestamp(seconds * kmilliSecondsPerSecond +
40,000,000 ( 0.26%)  0          0           8,000,000 ( 0.19%) 1 ( 0.00%) 1 ( 0.00%)         0          0          0                              tv.tv_usec / kmilliSecondsPerSecond);
20,000,000 ( 0.13%)  0          0          16,000,000 ( 0.39%) 4 ( 0.01%) 2 ( 0.01%)         0          0          0           }
         .           .          .                   .          .          .                  .          .          .           
         .           .          .                   .          .          .                  .          .          .           /* 格式化时间: 使用localtime_r保证线程安全 */
         .           .          .                   .          .          .                  .          .          .           std::string Timestamp::toString() {
         .           .          .                   .          .          .                  .          .          .             char buff[64];
         .           .          .                   .          .          .                  .          .          .             time_t second =
         .           .          .                   .          .          .                  .          .          .                 static_cast<time_t>(milliSecondsSinceEpoch_ / kmilliSecondsPerSecond);
         .           .          .                   .          .          .                  .          .          .             struct tm tm_time;
         .           .          .                   .          .          .                  .          .          .             /* stores the data in a user-supplied struct tm_time*/
-- line 35 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/std_function.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                  D1mr        DLmr        Dw                  D1mw        DLmw       

-- line 79 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .               void*       _M_object;
         .            .          .                   .           .           .                   .           .          .               const void* _M_const_object;
         .            .          .                   .           .           .                   .           .          .               void (*_M_function_pointer)();
         .            .          .                   .           .           .                   .           .          .               void (_Undefined_class::*_M_member_pointer)();
         .            .          .                   .           .           .                   .           .          .             };
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             union [[gnu::may_alias]] _Any_data
         .            .          .                   .           .           .                   .           .          .             {
        42 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         18 ( 0.00%)  0           0                  12 ( 0.00%)  0          0               void*       _M_access()       { return &_M_pod_data[0]; }
28,000,000 ( 0.18%)  17 ( 0.04%) 6 ( 0.10%) 12,000,000 ( 0.29%)  0           0           8,000,000 ( 0.26%) 16 ( 0.00%) 5 ( 0.00%)      const void* _M_access() const { return &_M_pod_data[0]; }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .               template<typename _Tp>
         .            .          .                   .           .           .                   .           .          .                 _Tp&
        15 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          0           0           0                   6 ( 0.00%)  0          0                 _M_access()
        15 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          9 ( 0.00%)  0           0                   3 ( 0.00%)  0          0                 { return *static_cast<_Tp*>(_M_access()); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .               template<typename _Tp>
         .            .          .                   .           .           .                   .           .          .                 const _Tp&
20,000,000 ( 0.13%) 178 ( 0.45%) 0                   0           0           0           8,000,000 ( 0.26%)  0          0                 _M_access() const
20,000,000 ( 0.13%)   3 ( 0.01%) 2 ( 0.03%) 12,000,000 ( 0.29%)  0           0           4,000,000 ( 0.13%)  0          0                 { return *static_cast<const _Tp*>(_M_access()); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .               _Nocopy_types _M_unused;
         .            .          .                   .           .           .                   .           .          .               char _M_pod_data[sizeof(_Nocopy_types)];
         .            .          .                   .           .           .                   .           .          .             };
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             enum _Manager_operation
         .            .          .                   .           .           .                   .           .          .             {
         .            .          .                   .           .           .                   .           .          .               __get_type_info,
-- line 106 ----------------------------------------
-- line 143 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           	 && sizeof(_Functor) <= _M_max_size
         .            .          .                   .           .           .                   .           .          .           	 && __alignof__(_Functor) <= _M_max_align
         .            .          .                   .           .           .                   .           .          .           	 && (_M_max_align % __alignof__(_Functor) == 0));
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	typedef integral_constant<bool, __stored_locally> _Local_storage;
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	// Retrieve a pointer to the function object
         .            .          .                   .           .           .                   .           .          .           	static _Functor*
20,000,000 ( 0.13%) 278 ( 0.70%) 0                   0           0           0           8,000,000 ( 0.26%)  7 ( 0.00%) 2 ( 0.00%)  	_M_get_pointer(const _Any_data& __source)
         .            .          .                   .           .           .                   .           .          .           	{
         .            .          .                   .           .           .                   .           .          .           	  if _GLIBCXX17_CONSTEXPR (__stored_locally)
         .            .          .                   .           .           .                   .           .          .           	    {
16,000,000 ( 0.10%)   0          0           4,000,000 ( 0.10%)  0           0           8,000,000 ( 0.26%)  0          0           	      const _Functor& __f = __source._M_access<_Functor>();
16,000,000 ( 0.10%)   0          0           4,000,000 ( 0.10%)  0           0           4,000,000 ( 0.13%)  0          0           	      return const_cast<_Functor*>(std::__addressof(__f));
         .            .          .                   .           .           .                   .           .          .           	    }
         .            .          .                   .           .           .                   .           .          .           	  else // have stored a pointer
         .            .          .                   .           .           .                   .           .          .           	    return __source._M_access<_Functor*>();
 8,000,000 ( 0.05%)   0          0           8,000,000 ( 0.19%)  0           0                   0           0          0           	}
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	// Clone a location-invariant function object that fits within
         .            .          .                   .           .           .                   .           .          .           	// an _Any_data structure.
         .            .          .                   .           .           .                   .           .          .           	static void
         .            .          .                   .           .           .                   .           .          .           	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
         .            .          .                   .           .           .                   .           .          .           	{
         .            .          .                   .           .           .                   .           .          .           	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
         .            .          .                   .           .           .                   .           .          .           	}
-- line 168 ----------------------------------------
-- line 174 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           	{
         .            .          .                   .           .           .                   .           .          .           	  __dest._M_access<_Functor*>() =
         .            .          .                   .           .           .                   .           .          .           	    new _Functor(*__source._M_access<const _Functor*>());
         .            .          .                   .           .           .                   .           .          .           	}
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	// Destroying a location-invariant object may still require
         .            .          .                   .           .           .                   .           .          .           	// destruction.
         .            .          .                   .           .           .                   .           .          .           	static void
        15 ( 0.00%)   5 ( 0.01%) 5 ( 0.08%)          0           0           0                   6 ( 0.00%)  0          0           	_M_destroy(_Any_data& __victim, true_type)
         .            .          .                   .           .           .                   .           .          .           	{
         9 ( 0.00%)   0          0                   3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	  __victim._M_access<_Functor>().~_Functor();
         9 ( 0.00%)   0          0                   6 ( 0.00%)  0           0                   0           0          0           	}
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	// Destroying an object located on the heap.
         .            .          .                   .           .           .                   .           .          .           	static void
         .            .          .                   .           .           .                   .           .          .           	_M_destroy(_Any_data& __victim, false_type)
         .            .          .                   .           .           .                   .           .          .           	{
         .            .          .                   .           .           .                   .           .          .           	  delete __victim._M_access<_Functor*>();
         .            .          .                   .           .           .                   .           .          .           	}
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 public:
         .            .          .                   .           .           .                   .           .          .           	static bool
        33 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          3 ( 0.00%)  0           0                  18 ( 0.00%)  0          0           	_M_manager(_Any_data& __dest, const _Any_data& __source,
         .            .          .                   .           .           .                   .           .          .           		   _Manager_operation __op)
         .            .          .                   .           .           .                   .           .          .           	{
         9 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          3 ( 0.00%)  0           0                   0           0          0           	  switch (__op)
         .            .          .                   .           .           .                   .           .          .           	    {
         .            .          .                   .           .           .                   .           .          .           #if __cpp_rtti
         .            .          .                   .           .           .                   .           .          .           	    case __get_type_info:
         .            .          .                   .           .           .                   .           .          .           	      __dest._M_access<const type_info*>() = &typeid(_Functor);
         .            .          .                   .           .           .                   .           .          .           	      break;
         .            .          .                   .           .           .                   .           .          .           #endif
         .            .          .                   .           .           .                   .           .          .           	    case __get_functor_ptr:
         .            .          .                   .           .           .                   .           .          .           	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
         .            .          .                   .           .           .                   .           .          .           	      break;
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	    case __clone_functor:
         .            .          .                   .           .           .                   .           .          .           	      _M_clone(__dest, __source, _Local_storage());
         .            .          .                   .           .           .                   .           .          .           	      break;
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	    case __destroy_functor:
         9 ( 0.00%)   3 ( 0.01%) 3 ( 0.05%)          3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	      _M_destroy(__dest, _Local_storage());
         3 ( 0.00%)   0          0                   0           0           0                   0           0          0           	      break;
         .            .          .                   .           .           .                   .           .          .           	    }
         3 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          0           0           0                   0           0          0           	  return false;
        21 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         15 ( 0.00%)  0           0                   0           0          0           	}
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	static void
        27 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          3 ( 0.00%)  0           0                  12 ( 0.00%)  0          0           	_M_init_functor(_Any_data& __functor, _Functor&& __f)
        42 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         18 ( 0.00%)  0           0                   6 ( 0.00%)  0          0           	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	template<typename _Signature>
         .            .          .                   .           .           .                   .           .          .           	  static bool
         .            .          .                   .           .           .                   .           .          .           	  _M_not_empty_function(const function<_Signature>& __f)
         .            .          .                   .           .           .                   .           .          .           	  { return static_cast<bool>(__f); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	template<typename _Tp>
         .            .          .                   .           .           .                   .           .          .           	  static bool
        12 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          0           0           0                   6 ( 0.00%)  0          0           	  _M_not_empty_function(_Tp* __fp)
        12 ( 0.00%)   0          0                   9 ( 0.00%)  0           0                   0           0          0           	  { return __fp != nullptr; }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	template<typename _Class, typename _Tp>
         .            .          .                   .           .           .                   .           .          .           	  static bool
         .            .          .                   .           .           .                   .           .          .           	  _M_not_empty_function(_Tp _Class::* __mp)
         .            .          .                   .           .           .                   .           .          .           	  { return __mp != nullptr; }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	template<typename _Tp>
         .            .          .                   .           .           .                   .           .          .           	  static bool
         .            .          .                   .           .           .                   .           .          .           	  _M_not_empty_function(const _Tp&)
         .            .          .                   .           .           .                   .           .          .           	  { return true; }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 private:
         .            .          .                   .           .           .                   .           .          .           	static void
        21 ( 0.00%)   3 ( 0.01%) 3 ( 0.05%)          0           0           0                  12 ( 0.00%)  0          0           	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
        48 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)         18 ( 0.00%)  0           0                  12 ( 0.00%)  0          0           	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           	static void
         .            .          .                   .           .           .                   .           .          .           	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
         .            .          .                   .           .           .                   .           .          .           	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
         .            .          .                   .           .           .                   .           .          .                 };
         .            .          .                   .           .           .                   .           .          .           
        36 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         12 ( 0.00%)  0           0                  12 ( 0.00%)  1 ( 0.00%) 1 ( 0.00%)      _Function_base() : _M_manager(nullptr) { }
         .            .          .                   .           .           .                   .           .          .           
        20 ( 0.00%)   0          0                   0           0           0                   8 ( 0.00%)  0          0               ~_Function_base()
         .            .          .                   .           .           .                   .           .          .               {
        16 ( 0.00%)   2 ( 0.01%) 1 ( 0.02%)          8 ( 0.00%)  1 ( 0.00%)  0                   0           0          0                 if (_M_manager)
        24 ( 0.00%)   0          0                  12 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	_M_manager(_M_functor, _M_functor, __destroy_functor);
        12 ( 0.00%)   0          0                   8 ( 0.00%)  0           0                   0           0          0               }
         .            .          .                   .           .           .                   .           .          .           
80,000,000 ( 0.51%)   0          0          32,000,000 ( 0.78%) 20 ( 0.04%)  7 ( 0.02%) 16,000,000 ( 0.52%)  0          0               bool _M_empty() const { return !_M_manager; }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .               typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
         .            .          .                   .           .           .                   .           .          .           				  _Manager_operation);
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .               _Any_data     _M_functor;
         .            .          .                   .           .           .                   .           .          .               _Manager_type _M_manager;
         .            .          .                   .           .           .                   .           .          .             };
         .            .          .                   .           .           .                   .           .          .           
-- line 271 ----------------------------------------
-- line 290 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .             template<typename _Functor, typename... _ArgTypes>
         .            .          .                   .           .           .                   .           .          .               class _Function_handler<void(_ArgTypes...), _Functor>
         .            .          .                   .           .           .                   .           .          .               : public _Function_base::_Base_manager<_Functor>
         .            .          .                   .           .           .                   .           .          .               {
         .            .          .                   .           .           .                   .           .          .                 typedef _Function_base::_Base_manager<_Functor> _Base;
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                public:
         .            .          .                   .           .           .                   .           .          .                 static void
36,000,000 ( 0.23%) 178 ( 0.45%) 1 ( 0.02%)          0           0           0          24,000,000 ( 0.78%) 16 ( 0.00%) 4 ( 0.00%)        _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
         .            .          .                   .           .           .                   .           .          .                 {
36,000,000 ( 0.23%)   0          0          16,000,000 ( 0.39%)  0           0           8,000,000 ( 0.26%)  0          0           	(*_Base::_M_get_pointer(__functor))(
24,000,000 ( 0.15%)   3 ( 0.01%) 0           8,000,000 ( 0.19%)  0           0           8,000,000 ( 0.26%)  0          0           	    std::forward<_ArgTypes>(__args)...);
24,000,000 ( 0.15%)   0          0          16,000,000 ( 0.39%) 27 ( 0.05%) 10 ( 0.03%)          0           0          0                 }
         .            .          .                   .           .           .                   .           .          .               };
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             template<typename _Class, typename _Member, typename _Res,
         .            .          .                   .           .           .                   .           .          .           	   typename... _ArgTypes>
         .            .          .                   .           .           .                   .           .          .               class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
         .            .          .                   .           .           .                   .           .          .               : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
         .            .          .                   .           .           .                   .           .          .               {
         .            .          .                   .           .           .                   .           .          .                 typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
-- line 310 ----------------------------------------
-- line 361 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             /**
         .            .          .                   .           .           .                   .           .          .              *  @brief Primary class template for std::function.
         .            .          .                   .           .           .                   .           .          .              *  @ingroup functors
         .            .          .                   .           .           .                   .           .          .              *
         .            .          .                   .           .           .                   .           .          .              *  Polymorphic function wrapper.
         .            .          .                   .           .           .                   .           .          .              */
         .            .          .                   .           .           .                   .           .          .             template<typename _Res, typename... _ArgTypes>
        44 ( 0.00%)   4 ( 0.01%) 4 ( 0.06%)         12 ( 0.00%)  0           0                  12 ( 0.00%)  0          0               class function<_Res(_ArgTypes...)>
         .            .          .                   .           .           .                   .           .          .               : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
         .            .          .                   .           .           .                   .           .          .                 private _Function_base
         .            .          .                   .           .           .                   .           .          .               {
         .            .          .                   .           .           .                   .           .          .                 template<typename _Func,
         .            .          .                   .           .           .                   .           .          .           	       typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
         .            .          .                   .           .           .                   .           .          .           	struct _Callable
         .            .          .                   .           .           .                   .           .          .           	: __is_invocable_impl<_Res2, _Res>::type
         .            .          .                   .           .           .                   .           .          .           	{ };
-- line 377 ----------------------------------------
-- line 415 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief %Function move constructor.
         .            .          .                   .           .           .                   .           .          .                  *  @param __x A %function object rvalue with identical call signature.
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  The newly-created %function contains the target of @a __x
         .            .          .                   .           .           .                   .           .          .                  *  (if it has one).
         .            .          .                   .           .           .                   .           .          .                  */
         9 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          1 ( 0.00%)  0           0                   4 ( 0.00%)  0          0                 function(function&& __x) noexcept : _Function_base()
         .            .          .                   .           .           .                   .           .          .                 {
         5 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          2 ( 0.00%)  0           0                   1 ( 0.00%)  0          0           	__x.swap(*this);
         3 ( 0.00%)   0          0                   2 ( 0.00%)  0           0                   0           0          0                 }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief Builds a %function that targets a copy of the incoming
         .            .          .                   .           .           .                   .           .          .                  *  function object.
         .            .          .                   .           .           .                   .           .          .                  *  @param __f A %function object that is callable with parameters of
         .            .          .                   .           .           .                   .           .          .                  *  type @c T1, @c T2, ..., @c TN and returns a value convertible
         .            .          .                   .           .           .                   .           .          .                  *  to @c Res.
         .            .          .                   .           .           .                   .           .          .                  *
-- line 434 ----------------------------------------
-- line 472 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  The target of @a __x is moved to @c *this. If @a __x has no
         .            .          .                   .           .           .                   .           .          .                  *  target, then @c *this will be empty.
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  If @a __x targets a function pointer or a reference to a function
         .            .          .                   .           .           .                   .           .          .                  *  object, then this operation will not throw an %exception.
         .            .          .                   .           .           .                   .           .          .                  */
         .            .          .                   .           .           .                   .           .          .                 function&
         9 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          1 ( 0.00%)  0           0                   4 ( 0.00%)  0          0                 operator=(function&& __x) noexcept
         .            .          .                   .           .           .                   .           .          .                 {
        16 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          2 ( 0.00%)  0           0                   4 ( 0.00%)  0          0           	function(std::move(__x)).swap(*this);
         1 ( 0.00%)   0          0                   1 ( 0.00%)  0           0                   0           0          0           	return *this;
         5 ( 0.00%)   0          0                   4 ( 0.00%)  0           0                   0           0          0                 }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief %Function assignment to zero.
         .            .          .                   .           .           .                   .           .          .                  *  @post @c !(bool)*this
         .            .          .                   .           .           .                   .           .          .                  *  @returns @c *this
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  The target of @c *this is deallocated, leaving it empty.
         .            .          .                   .           .           .                   .           .          .                  */
-- line 492 ----------------------------------------
-- line 539 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief Swap the targets of two %function objects.
         .            .          .                   .           .           .                   .           .          .                  *  @param __x A %function with identical call signature.
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  Swap the targets of @c this function object and @a __f. This
         .            .          .                   .           .           .                   .           .          .                  *  function will not throw an %exception.
         .            .          .                   .           .           .                   .           .          .                  */
        12 ( 0.00%)   0          0                   0           0           0                   6 ( 0.00%)  0          0                 void swap(function& __x) noexcept
         .            .          .                   .           .           .                   .           .          .                 {
        10 ( 0.00%)   0          0                   4 ( 0.00%)  0           0                   2 ( 0.00%)  0          0           	std::swap(_M_functor, __x._M_functor);
        14 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          4 ( 0.00%)  0           0                   2 ( 0.00%)  0          0           	std::swap(_M_manager, __x._M_manager);
        14 ( 0.00%)   0          0                   4 ( 0.00%)  0           0                   2 ( 0.00%)  0          0           	std::swap(_M_invoker, __x._M_invoker);
         6 ( 0.00%)   0          0                   4 ( 0.00%)  0           0                   0           0          0                 }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 // [3.7.2.3] function capacity
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief Determine if the %function wrapper has a target.
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  @return @c true when this %function object contains a target,
         .            .          .                   .           .           .                   .           .          .                  *  or @c false when it is empty.
         .            .          .                   .           .           .                   .           .          .                  *
         .            .          .                   .           .           .                   .           .          .                  *  This function will not throw an %exception.
         .            .          .                   .           .           .                   .           .          .                  */
20,000,000 ( 0.13%)   0          0                   0           0           0           8,000,000 ( 0.26%)  0          0                 explicit operator bool() const noexcept
24,000,000 ( 0.15%)   1 ( 0.00%) 1 ( 0.02%) 12,000,000 ( 0.29%)  1 ( 0.00%)  1 ( 0.00%)  4,000,000 ( 0.13%)  2 ( 0.00%) 1 ( 0.00%)        { return !_M_empty(); }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 // [3.7.2.4] function invocation
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .                 /**
         .            .          .                   .           .           .                   .           .          .                  *  @brief Invokes the function targeted by @c *this.
         .            .          .                   .           .           .                   .           .          .                  *  @returns the result of the target.
         .            .          .                   .           .           .                   .           .          .                  *  @throws bad_function_call when @c !(bool)*this
         .            .          .                   .           .           .                   .           .          .                  *
-- line 573 ----------------------------------------
-- line 659 ----------------------------------------
         .            .          .                   .           .           .                   .           .          .           	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
         .            .          .                   .           .           .                   .           .          .           	  _M_invoker = __x._M_invoker;
         .            .          .                   .           .           .                   .           .          .           	  _M_manager = __x._M_manager;
         .            .          .                   .           .           .                   .           .          .           	}
         .            .          .                   .           .           .                   .           .          .               }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             template<typename _Res, typename... _ArgTypes>
         .            .          .                   .           .           .                   .           .          .               template<typename _Functor, typename, typename>
        21 ( 0.00%)   2 ( 0.01%) 2 ( 0.03%)          0           0           0                  12 ( 0.00%)  0          0                 function<_Res(_ArgTypes...)>::
         .            .          .                   .           .           .                   .           .          .                 function(_Functor __f)
         9 ( 0.00%)   0          0                   3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0                 : _Function_base()
         .            .          .                   .           .           .                   .           .          .                 {
         .            .          .                   .           .           .                   .           .          .           	typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;
         .            .          .                   .           .           .                   .           .          .           
        15 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	if (_My_handler::_M_not_empty_function(__f))
         .            .          .                   .           .           .                   .           .          .           	  {
        24 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          3 ( 0.00%)  0           0                   6 ( 0.00%)  0          0           	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
         9 ( 0.00%)   0          0                   3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	    _M_invoker = &_My_handler::_M_invoke;
         9 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          3 ( 0.00%)  0           0                   3 ( 0.00%)  0          0           	    _M_manager = &_My_handler::_M_manager;
         .            .          .                   .           .           .                   .           .          .           	  }
        18 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          9 ( 0.00%)  0           0                   0           0          0                 }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .             template<typename _Res, typename... _ArgTypes>
         .            .          .                   .           .           .                   .           .          .               _Res
36,000,000 ( 0.23%)  15 ( 0.04%) 6 ( 0.10%)          0           0           0          24,000,000 ( 0.78%)  2 ( 0.00%) 1 ( 0.00%)      function<_Res(_ArgTypes...)>::
         .            .          .                   .           .           .                   .           .          .               operator()(_ArgTypes... __args) const
         .            .          .                   .           .           .                   .           .          .               {
20,000,000 ( 0.13%)   0          0           4,000,000 ( 0.10%)  0           0           4,000,000 ( 0.13%)  0          0                 if (_M_empty())
         .            .          .                   .           .           .                   .           .          .           	__throw_bad_function_call();
64,000,000 ( 0.41%)   8 ( 0.02%) 2 ( 0.03%) 12,000,000 ( 0.29%)  0           0          12,000,000 ( 0.39%)  0          0                 return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
20,000,000 ( 0.13%)   0          0          16,000,000 ( 0.39%) 28 ( 0.06%) 10 ( 0.03%)          0           0          0               }
         .            .          .                   .           .           .                   .           .          .           
         .            .          .                   .           .           .                   .           .          .           #if __cpp_rtti
         .            .          .                   .           .           .                   .           .          .             template<typename _Res, typename... _ArgTypes>
         .            .          .                   .           .           .                   .           .          .               const type_info&
         .            .          .                   .           .           .                   .           .          .               function<_Res(_ArgTypes...)>::
         .            .          .                   .           .           .                   .           .          .               target_type() const noexcept
         .            .          .                   .           .           .                   .           .          .               {
         .            .          .                   .           .           .                   .           .          .                 if (_M_manager)
-- line 697 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                  D1mr        DLmr       Dw                 D1mw       DLmw       

-- line 241 ----------------------------------------
         .            .          .                   .           .          .                  .          .          .           #elif defined (__BIONIC__)
         .            .          .                   .           .          .                  .          .          .           # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_create)
         .            .          .                   .           .          .                  .          .          .           #else
         .            .          .                   .           .          .                  .          .          .           # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_cancel)
         .            .          .                   .           .          .                  .          .          .           #endif
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_active_p (void)
16,006,836 ( 0.10%)   5 ( 0.01%) 4 ( 0.06%)          0           0          0          8,003,418 ( 0.26%) 1 ( 0.00%) 1 ( 0.00%)  {
         .            .          .                   .           .          .                  .          .          .             static void *const __gthread_active_ptr
         .            .          .                   .           .          .                  .          .          .               = __extension__ (void *) &GTHR_ACTIVE_PROXY;
40,017,090 ( 0.26%)   0          0           8,003,418 ( 0.19%) 21 ( 0.04%) 6 ( 0.02%)         0          0          0             return __gthread_active_ptr != 0;
16,006,836 ( 0.10%)   0          0          16,006,836 ( 0.39%)  0          0                  0          0          0           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           #endif /* FreeBSD or Solaris */
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           #else /* not __GXX_WEAK__ */
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           /* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread
         .            .          .                   .           .          .                  .          .          .              calls in shared flavors of the HP-UX C library.  Most of the stubs
         .            .          .                   .           .          .                  .          .          .              have no functionality.  The details are described in the "libc cumulative
-- line 261 ----------------------------------------
-- line 739 ----------------------------------------
         .            .          .                   .           .          .                  .          .          .             if (__gthread_active_p ())
         .            .          .                   .           .          .                  .          .          .               return __gthrw_(pthread_mutex_destroy) (__mutex);
         .            .          .                   .           .          .                  .          .          .             else
         .            .          .                   .           .          .                  .          .          .               return 0;
         .            .          .                   .           .          .                  .          .          .           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_mutex_lock (__gthread_mutex_t *__mutex)
16,000,032 ( 0.10%)   2 ( 0.01%) 1 ( 0.02%)          0           0          0          8,000,016 ( 0.26%) 0          0           {
20,000,040 ( 0.13%)   0          0                   0           0          0          4,000,008 ( 0.13%) 0          0             if (__gthread_active_p ())
16,000,032 ( 0.10%)   0          0           4,000,008 ( 0.10%)  0          0          4,000,008 ( 0.13%) 0          0               return __gthrw_(pthread_mutex_lock) (__mutex);
         .            .          .                   .           .          .                  .          .          .             else
         .            .          .                   .           .          .                  .          .          .               return 0;
 8,000,016 ( 0.05%)   0          0           8,000,016 ( 0.19%)  0          0                  0          0          0           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_mutex_trylock (__gthread_mutex_t *__mutex)
         .            .          .                   .           .          .                  .          .          .           {
         .            .          .                   .           .          .                  .          .          .             if (__gthread_active_p ())
         .            .          .                   .           .          .                  .          .          .               return __gthrw_(pthread_mutex_trylock) (__mutex);
         .            .          .                   .           .          .                  .          .          .             else
         .            .          .                   .           .          .                  .          .          .               return 0;
-- line 760 ----------------------------------------
-- line 769 ----------------------------------------
         .            .          .                   .           .          .                  .          .          .               return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);
         .            .          .                   .           .          .                  .          .          .             else
         .            .          .                   .           .          .                  .          .          .               return 0;
         .            .          .                   .           .          .                  .          .          .           }
         .            .          .                   .           .          .                  .          .          .           #endif
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_mutex_unlock (__gthread_mutex_t *__mutex)
16,000,032 ( 0.10%) 177 ( 0.45%) 1 ( 0.02%)          0           0          0          8,000,016 ( 0.26%) 3 ( 0.00%) 0           {
20,000,040 ( 0.13%)   0          0                   0           0          0          4,000,008 ( 0.13%) 0          0             if (__gthread_active_p ())
16,000,032 ( 0.10%)   0          0           4,000,008 ( 0.10%)  0          0          4,000,008 ( 0.13%) 0          0               return __gthrw_(pthread_mutex_unlock) (__mutex);
         .            .          .                   .           .          .                  .          .          .             else
         .            .          .                   .           .          .                  .          .          .               return 0;
 8,000,016 ( 0.05%)   0          0           8,000,016 ( 0.19%) 11 ( 0.02%) 2 ( 0.01%)         0          0          0           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           #if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
         .            .          .                   .           .          .                  .          .          .             || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
         .            .          .                   .           .          .                  .          .          .           {
         .            .          .                   .           .          .                  .          .          .             if (__gthread_active_p ())
         .            .          .                   .           .          .                  .          .          .               {
-- line 790 ----------------------------------------
-- line 863 ----------------------------------------
         .            .          .                   .           .          .                  .          .          .           __gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
         .            .          .                   .           .          .                  .          .          .           {
         .            .          .                   .           .          .                  .          .          .             return __gthrw_(pthread_cond_wait) (__cond, __mutex);
         .            .          .                   .           .          .                  .          .          .           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
         .            .          .                   .           .          .                  .          .          .           			  const __gthread_time_t *__abs_timeout)
         6 ( 0.00%)   0          0                   0           0          0                  4 ( 0.00%) 0          0           {
         6 ( 0.00%)   0          0                   3 ( 0.00%)  0          0                  1 ( 0.00%) 0          0             return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);
         2 ( 0.00%)   0          0                   2 ( 0.00%)  1 ( 0.00%) 0                  0          0          0           }
         .            .          .                   .           .          .                  .          .          .           
         .            .          .                   .           .          .                  .          .          .           static inline int
         .            .          .                   .           .          .                  .          .          .           __gthread_cond_wait_recursive (__gthread_cond_t *__cond,
         .            .          .                   .           .          .                  .          .          .           			       __gthread_recursive_mutex_t *__mutex)
         .            .          .                   .           .          .                  .          .          .           {
         .            .          .                   .           .          .                  .          .          .             return __gthread_cond_wait (__cond, __mutex);
         .            .          .                   .           .          .                  .          .          .           }
         .            .          .                   .           .          .                  .          .          .           
-- line 881 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h
--------------------------------------------------------------------------------
Ir                   I1mr         ILmr        Dr                   D1mr        DLmr        Dw                   D1mw         DLmw        

-- line 20 ----------------------------------------
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .           /* 日志记录行缓冲区大小: 1Kb*/
          .            .           .                    .           .           .                    .            .           .           const int kLineBuff = 1024;
          .            .           .                    .           .           .                    .            .           .           /* 异步日志单个缓冲区大小: 4Mb */
          .            .           .                    .           .           .                    .            .           .           const int kBuffSize = 4 * 1024 * 1024;
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .           template <size_t SIZE> class FixedBuffer : noncopyable {
          .            .           .                    .           .           .                    .            .           .           public:
        855 ( 0.00%) 108 ( 0.27%)  5 ( 0.08%)         285 ( 0.00%)  0           0                  285 ( 0.00%)  87 ( 0.00%) 87 ( 0.00%)    FixedBuffer() : _cur(0) {}
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .             ~FixedBuffer() = default;
          .            .           .                    .           .           .                    .            .           .           
 32,000,160 ( 0.20%)  16 ( 0.04%) 10 ( 0.16%)  16,000,080 ( 0.39%) 20 ( 0.04%) 20 ( 0.06%)   8,000,040 ( 0.26%)   0           0             size_t size() const { return _cur; }
          .            .           .                    .           .           .                    .            .           .           
 16,000,424 ( 0.10%)   0           0                    0           0           0            8,000,212 ( 0.26%)   0           0             void clear() {
  8,000,212 ( 0.05%) 273 ( 0.69%)  1 ( 0.02%)   4,000,106 ( 0.10%)  0           0            4,000,106 ( 0.13%) 106 ( 0.00%) 96 ( 0.00%)      _cur = 0;
          .            .           .                    .           .           .                    .            .           .               // TODO: do we need this operation ?
          .            .           .                    .           .           .                    .            .           .               // memset(_data, 0, sizeof(_data));?
 12,000,318 ( 0.08%)   0           0            8,000,212 ( 0.19%)  0           0                    0            0           0             }
          .            .           .                    .           .           .                    .            .           .           
572,000,000 ( 3.66%)   4 ( 0.01%)  4 ( 0.06%) 208,000,000 ( 5.06%) 54 ( 0.11%) 19 ( 0.06%) 104,000,000 ( 3.37%)   0           0             size_t avail() const { return SIZE - _cur; }
          .            .           .                    .           .           .                    .            .           .           
 28,000,140 ( 0.18%)  16 ( 0.04%)  7 ( 0.11%)  12,000,060 ( 0.29%)  0           0            8,000,040 ( 0.26%)   0           0             const char *data() const { return _data; }
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .             /* 从外部直接写入内容到buffer中 */
 40,000,000 ( 0.26%)   0           0           20,000,000 ( 0.49%)  1 ( 0.00%)  0            8,000,000 ( 0.26%)   0           0             char *current() { return _data + _cur; }
          .            .           .                    .           .           .                    .            .           .           
 56,000,000 ( 0.36%)   1 ( 0.00%)  1 ( 0.02%)  24,000,000 ( 0.58%)  0           0           16,000,000 ( 0.52%)   0           0             void addLen(size_t len) { _cur += len; }
          .            .           .                    .           .           .                    .            .           .           
308,000,000 ( 1.97%)  10 ( 0.03%)  6 ( 0.10%)           0           0           0          176,000,000 ( 5.70%)  49 ( 0.00%) 11 ( 0.00%)    void append(const char *_msg, size_t _len) {
308,000,000 ( 1.97%)   1 ( 0.00%)  1 ( 0.02%)  88,000,000 ( 2.14%)  3 ( 0.01%)  1 ( 0.00%)  44,000,000 ( 1.43%)   1 ( 0.00%)  0               if (avail() > _len) {
396,000,000 ( 2.53%)   2 ( 0.01%)  2 ( 0.03%) 220,000,000 ( 5.35%)  6 ( 0.01%)  2 ( 0.01%)  44,000,000 ( 1.43%)   0           0                 memcpy(_data + _cur, _msg, _len);
264,000,000 ( 1.69%)   1 ( 0.00%)  1 ( 0.02%) 176,000,000 ( 4.28%) 21 ( 0.04%) 11 ( 0.03%)  44,000,000 ( 1.43%)   0           0                 _cur += _len;
          .            .           .                    .           .           .                    .            .           .               }
132,000,000 ( 0.84%)   0           0           88,000,000 ( 2.14%)  0           0                    0            0           0             }
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .           private:
          .            .           .                    .           .           .                    .            .           .             char _data[SIZE]; /* 缓冲区 */
          .            .           .                    .           .           .                    .            .           .             size_t _cur;      /* 第一个可写入位置 */
          .            .           .                    .           .           .                    .            .           .           };
          .            .           .                    .           .           .                    .            .           .           
          .            .           .                    .           .           .                    .            .           .           } // namespace TinyLog::LogBuffer
          .            .           .                    .           .           .                    .            .           .           
-- line 62 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 15 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           #include <ctime>
         .           .           .                   .          .          .                   .          .          .           #include <string>
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           namespace TinyLog {
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           class Timestamp {
         .           .           .                   .          .          .                   .          .          .           public:
         .           .           .                   .          .          .                   .          .          .             Timestamp() : milliSecondsSinceEpoch_(0) {}
20,000,000 ( 0.13%) 16 ( 0.04%) 11 ( 0.18%)          0          0          0          12,000,000 ( 0.39%) 0          0             explicit Timestamp(int64_t _milliSecondsSinceEpoch)
24,000,000 ( 0.15%)  0           0          16,000,000 ( 0.39%) 0          0           4,000,000 ( 0.13%) 0          0                 : milliSecondsSinceEpoch_(_milliSecondsSinceEpoch) {}
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /* Unix 时间戳 */
         .           .           .                   .          .          .                   .          .          .             static Timestamp now();
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /* 格式化时间: 使用localtime_r保证线程安全 */
         .           .           .                   .          .          .                   .          .          .             std::string toString();
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /* 获取毫秒 */
32,000,000 ( 0.20%)  0           0          16,000,000 ( 0.39%) 0          0           8,000,000 ( 0.26%) 0          0             int64_t getMilliSeconds() { return milliSecondsSinceEpoch_; }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /* 获取秒 */
16,000,000 ( 0.10%) 90 ( 0.23%)  0                   0          0          0           8,000,000 ( 0.26%) 0          0             time_t getSeconds() {
 8,000,000 ( 0.05%)  0           0           8,000,000 ( 0.19%) 0          0                   0          0          0               return static_cast<time_t>(milliSecondsSinceEpoch_ /
32,000,000 ( 0.20%)  1 ( 0.00%)  1 ( 0.02%)          0          0          0                   0          0          0                                          kmilliSecondsPerSecond);
 8,000,000 ( 0.05%)  0           0           8,000,000 ( 0.19%) 0          0                   0          0          0             }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             /* 时间戳类的静态数据成员 */
         .           .           .                   .          .          .                   .          .          .             static constexpr int kmilliSecondsPerSecond = 1000;
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           private:
         .           .           .                   .          .          .                   .          .          .             /* 毫秒级别的精度*/
         .           .           .                   .          .          .                   .          .          .             int64_t milliSecondsSinceEpoch_;
         .           .           .                   .          .          .                   .          .          .           };
-- line 47 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/main.cpp
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr        Dr                 D1mr        DLmr        Dw                  D1mw       DLmw       

-- line 9 ----------------------------------------
         .            .           .                  .           .           .                   .          .          .           #include <mutex>
         .            .           .                  .           .           .                   .          .          .           #include <sys/syscall.h>
         .            .           .                  .           .           .                   .          .          .           #include <thread>
         .            .           .                  .           .           .                   .          .          .           #include <unistd.h>
         .            .           .                  .           .           .                   .          .          .           #include <vector>
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .           using namespace std;
         .            .           .                  .           .           .                   .          .          .           
        80 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)         8 ( 0.00%)  0           0                  40 ( 0.00%) 0          0           void func() {
 3,200,024 ( 0.02%)  27 ( 0.07%)  0          1,600,008 ( 0.04%)  0           0                   8 ( 0.00%) 8 ( 0.00%) 8 ( 0.00%)      for (int i = 0; i < 1e5; i++) {
 1,600,000 ( 0.01%)   0           0                  0           0           0           1,600,000 ( 0.05%) 1 ( 0.00%) 0                   auto curId = TinyLog::ThreadInfo::getTid();
33,600,000 ( 0.21%) 534 ( 1.35%)  3 ( 0.05%)   800,000 ( 0.02%)  0           0           8,800,000 ( 0.29%) 0          0                   LOG_TRACE("TRACE hello world, current thread id  = %d\n", curId);
33,600,000 ( 0.21%) 358 ( 0.91%)  3 ( 0.05%)   800,000 ( 0.02%)  0           0           8,800,000 ( 0.29%) 0          0                   LOG_DEBUG("DEBUG hello world, current thread id  = %d\n", curId);
29,600,000 ( 0.19%) 189 ( 0.48%) 10 ( 0.16%)   800,000 ( 0.02%)  0           0           8,000,000 ( 0.26%) 0          0                   LOG_INFO("INFO hello world, current thread id = %d\n", curId);
29,600,000 ( 0.19%) 190 ( 0.48%)  2 ( 0.03%)   800,000 ( 0.02%)  0           0           8,000,000 ( 0.26%) 1 ( 0.00%) 0                   LOG_WARN("WARN hello world, current thread id  = %d\n", curId);
29,600,000 ( 0.19%) 510 ( 1.29%)  3 ( 0.05%)   800,000 ( 0.02%)  0           0           8,000,000 ( 0.26%) 0          0                   LOG_ERROR("ERROR hello world, current thread id  = %d\n", curId);
         .            .           .                  .           .           .                   .          .          .               }
        80 ( 0.00%)   0           0                 56 ( 0.00%)  8 ( 0.02%)  8 ( 0.02%)          0          0          0           }
         .            .           .                  .           .           .                   .          .          .           
         4 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0           unique_ptr<TinyLog::AsynLog> asynLog;
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .           /* 异步日志输出 */
24,000,000 ( 0.15%)   2 ( 0.01%)  2 ( 0.03%)         0           0           0          12,000,000 ( 0.39%) 0          0           void asynOutput(const char *_msg, size_t _len) {
32,000,000 ( 0.20%)   0           0          8,000,000 ( 0.19%)  1 ( 0.00%)  0           8,000,000 ( 0.26%) 0          0               asynLog->append(_msg, _len);
12,000,000 ( 0.08%)   1 ( 0.00%)  1 ( 0.02%) 8,000,000 ( 0.19%) 26 ( 0.05%) 10 ( 0.03%)          0          0          0           }
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .           void setLogger() {
         .            .           .                  .           .           .                   .          .          .               TinyLog::Logger::setOutput(asynOutput);
         .            .           .                  .           .           .                   .          .          .               /* 128 MB */
         .            .           .                  .           .           .                   .          .          .               int RollSize = 128 * 1024 * 1024;
         .            .           .                  .           .           .                   .          .          .               TinyLog::FileWriterType writerType = TinyLog::NORMALFileWriter;
         .            .           .                  .           .           .                   .          .          .               asynLog =
         .            .           .                  .           .           .                   .          .          .                   make_unique<TinyLog::AsynLog>("main.cpp", RollSize, 3, 4, writerType);
         .            .           .                  .           .           .                   .          .          .               asynLog->start();
         .            .           .                  .           .           .                   .          .          .           }
         .            .           .                  .           .           .                   .          .          .           
         8 ( 0.00%)   2 ( 0.01%)  2 ( 0.03%)         1 ( 0.00%)  0           0                   3 ( 0.00%) 0          0           void setLoggerByConfig() {
         .            .           .                  .           .           .                   .          .          .               /* 设置日志等级和日志文件相关的设置 */
         6 ( 0.00%)   1 ( 0.00%)  0                  0           0           0                   2 ( 0.00%) 0          0               TinyLog::LogConfig config;
         1 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0               config.logLevel = TinyLog::Logger::TRACE;
         5 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0               config.fileOption.baseName = "main.cpp-AsynLog";
         1 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         0           0           0                   1 ( 0.00%) 0          0               config.fileOption.fileWriter = TinyLog::NORMALFileWriter;
         .            .           .                  .           .           .                   .          .          .               /* 500MB */
         1 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0               config.fileOption.rooSize = static_cast<size_t>(500 * 1024) * 1024;
         .            .           .                  .           .           .                   .          .          .           
         3 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0               TinyLog::Logger::setConfig(config);
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .               /* 设置输出 */
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         0           0           0                   3 ( 0.00%) 0          0               TinyLog::Logger::setOutput(asynOutput);
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .               asynLog =
        10 ( 0.00%)   0           0                  0           0           0                   3 ( 0.00%) 0          0                   make_unique<TinyLog::AsynLog>();
         4 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         0           0           0                   2 ( 0.00%) 0          0               asynLog->start();
         8 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         5 ( 0.00%)  1 ( 0.00%)  0                   0          0          0           }
         .            .           .                  .           .           .                   .          .          .           
         4 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0           unique_ptr<TinyLog::SynLog> synLog;
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .           /* 同步日志输出 */
         .            .           .                  .           .           .                   .          .          .           void synOutput(const char *_msg, size_t _len) {
         .            .           .                  .           .           .                   .          .          .               synLog->append(_msg, _len);
         .            .           .                  .           .           .                   .          .          .           }
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .           void SynLogger() {
         .            .           .                  .           .           .                   .          .          .               /* 设置日志等级和日志文件相关的设置 */
-- line 72 ----------------------------------------
-- line 78 ----------------------------------------
         .            .           .                  .           .           .                   .          .          .               config.fileOption.rooSize = static_cast<size_t>(500 * 1024) * 1024;
         .            .           .                  .           .           .                   .          .          .               TinyLog::Logger::setConfig(config);
         .            .           .                  .           .           .                   .          .          .               /* 设置输出 */
         .            .           .                  .           .           .                   .          .          .               TinyLog::Logger::setOutput(synOutput);
         .            .           .                  .           .           .                   .          .          .           
         .            .           .                  .           .           .                   .          .          .               synLog = make_unique<TinyLog::SynLog>();
         .            .           .                  .           .           .                   .          .          .           }
         .            .           .                  .           .           .                   .          .          .           
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         1 ( 0.00%)  0           0                   5 ( 0.00%) 0          0           int main(int, char **) {
         2 ( 0.00%)   0           0                  0           0           0                   2 ( 0.00%) 0          0               auto start_time = chrono::system_clock::now();
         .            .           .                  .           .           .                   .          .          .               // setLogger();
         1 ( 0.00%)   0           0                  0           0           0                   1 ( 0.00%) 0          0               setLoggerByConfig();
         .            .           .                  .           .           .                   .          .          .               // SynLogger();
         .            .           .                  .           .           .                   .          .          .           
        15 ( 0.00%)   2 ( 0.01%)  1 ( 0.02%)         0           0           0                   4 ( 0.00%) 0          0               std::vector<std::thread> threads(8);
         .            .           .                  .           .           .                   .          .          .           
       137 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         2 ( 0.00%)  0           0                  38 ( 0.00%) 0          0               for (auto &t : threads)
        96 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         8 ( 0.00%)  0           0                  24 ( 0.00%) 0          0                   t = std::thread(func);
         .            .           .                  .           .           .                   .          .          .           
       137 ( 0.00%)   5 ( 0.01%)  5 ( 0.08%)         2 ( 0.00%)  0           0                  38 ( 0.00%) 3 ( 0.00%) 2 ( 0.00%)      for (auto &t : threads)
        24 ( 0.00%)   0           0                  8 ( 0.00%)  0           0                   8 ( 0.00%) 0          0                   t.join();
         .            .           .                  .           .           .                   .          .          .           
         2 ( 0.00%)   0           0                  0           0           0                   2 ( 0.00%) 0          0               auto end_time = chrono::system_clock::now();
        10 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         0           0           0                   4 ( 0.00%) 0          0               chrono::milliseconds cost_time = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);
         .            .           .                  .           .           .                   .          .          .           
        15 ( 0.00%)   1 ( 0.00%)  1 ( 0.02%)         1 ( 0.00%)  0           0                   4 ( 0.00%) 0          0               std::cout << "cost time = " << cost_time.count() << endl;
         1 ( 0.00%)   0           0                  0           0           0                   0          0          0               return 0;
        28 ( 0.00%)   5 ( 0.01%)  5 ( 0.08%)        11 ( 0.00%)  2 ( 0.00%)  1 ( 0.00%)          5 ( 0.00%) 0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                  D1mr        DLmr        Dw                 D1mw       DLmw       

-- line 12 ----------------------------------------
         .            .          .                   .           .           .                  .          .          .           #include <unistd.h>
         .            .          .                   .           .           .                  .          .          .           
         .            .          .                   .           .           .                  .          .          .           namespace TinyLog ::ThreadInfo {
         .            .          .                   .           .           .                  .          .          .           
         .            .          .                   .           .           .                  .          .          .           thread_local int currentTid = 0;
         .            .          .                   .           .           .                  .          .          .           thread_local char tidStr[32];
         .            .          .                   .           .           .                  .          .          .           thread_local size_t tidStrlen = 0;
         .            .          .                   .           .           .                  .          .          .           
 2,400,000 ( 0.02%) 260 ( 0.66%) 1 ( 0.02%)          0           0           0            800,000 ( 0.03%) 0          0           int getTid() {
 2,400,000 ( 0.02%)  88 ( 0.22%) 1 ( 0.02%)    800,000 ( 0.02%) 21 ( 0.04%)  6 ( 0.02%)         0          0          0             if (currentTid == 0) {
        16 ( 0.00%)   0          0                   0           0           0                 16 ( 0.00%) 0          0               currentTid = ::gettid();
        80 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)         16 ( 0.00%)  0           0                 16 ( 0.00%) 0          0               tidStrlen = static_cast<size_t>(snprintf(tidStr, sizeof(tidStr), "%d ", currentTid));
         .            .          .                   .           .           .                  .          .          .             }
   800,000 ( 0.01%)  16 ( 0.04%) 0             800,000 ( 0.02%)  0           0                  0          0          0             return currentTid;
 1,600,000 ( 0.01%)   0          0           1,600,000 ( 0.04%)  0           0                  0          0          0           }
         .            .          .                   .           .           .                  .          .          .           
28,000,000 ( 0.18%)   0          0          12,000,000 ( 0.29%)  1 ( 0.00%)  0          4,000,000 ( 0.13%) 0          0           const char *getTidStr() { return tidStr; }
         .            .          .                   .           .           .                  .          .          .           
24,000,000 ( 0.15%) 175 ( 0.44%) 5 ( 0.08%) 12,000,000 ( 0.29%) 71 ( 0.14%) 24 ( 0.07%) 4,000,000 ( 0.13%) 0          0           size_t getTidStrlen() { return tidStrlen; }
         .            .          .                   .           .           .                  .          .          .           
         6 ( 0.00%)   0          0                   2 ( 0.00%)  0           0                  2 ( 0.00%) 0          0           pid_t getPid() { return ::getpid(); }
         .            .          .                   .           .           .                  .          .          .           
         8 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          1 ( 0.00%)  0           0                  3 ( 0.00%) 0          0           std::string getPidStr() {
         6 ( 0.00%)   1 ( 0.00%) 1 ( 0.02%)          1 ( 0.00%)  0           0                  2 ( 0.00%) 0          0             return std::to_string(getPid());
         .            .          .                   .           .           .                  .          .          .             // char buff[32];
         .            .          .                   .           .           .                  .          .          .             // snprintf(buff, sizeof(buff), "%d", getPid());
         .            .          .                   .           .           .                  .          .          .             // return buff;
         6 ( 0.00%)   0          0                   5 ( 0.00%)  0           0                  0          0          0           }
         .            .          .                   .           .           .                  .          .          .           
         .            .          .                   .           .           .                  .          .          .           } // namespace TinyLog::ThreadInfo
--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c
  /build/glibc-sMfBJT/glibc-2.31/libio/iopadn.c
  /build/glibc-sMfBJT/glibc-2.31/libio/libioP.h
  /build/glibc-sMfBJT/glibc-2.31/libio/strops.c
  /build/glibc-sMfBJT/glibc-2.31/libio/vsnprintf.c
  /build/glibc-sMfBJT/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c
  /build/glibc-sMfBJT/glibc-2.31/nptl/pthread_mutex_unlock.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/../libio/libioP.h
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/_itoa.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/printf-parse.h
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/snprintf.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/vfprintf-internal.c
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strchr-avx2.S
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strrchr-avx2.S
  /build/glibc-sMfBJT/glibc-2.31/time/../sysdeps/unix/sysv/linux/gettimeofday.c

--------------------------------------------------------------------------------
Ir                     I1mr            ILmr         Dr                     D1mr           DLmr         Dw                     D1mw         DLmw         
--------------------------------------------------------------------------------
7,122,085,959 (45.53%) 10,506 (26.57%) 975 (15.54%) 2,313,758,383 (56.25%) 1,467 ( 2.93%) 563 ( 1.75%) 1,705,721,528 (55.26%) 717 ( 0.01%) 377 ( 0.01%)  events annotated

