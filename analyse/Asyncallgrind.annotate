--------------------------------------------------------------------------------
Profile data file 'ASYNcallgrind.out.3773328' (creator: callgrind-3.19.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 2895518459
Trigger: Program termination
Profiled target:  ./build/AsynLog (PID 3773328, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
15,611,700,732 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                      file:function
--------------------------------------------------------------------------------
2,281,184,243 (14.61%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/vfprintf-internal.c:__vfprintf_internal [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
1,280,000,000 ( 8.20%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
1,264,130,317 ( 8.10%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_default_xsputn [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  672,000,465 ( 4.30%)  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  649,989,308 ( 4.16%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/_itoa.c:_itoa_word [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  640,000,040 ( 4.10%)  TinyLog/src/Logging.cpp:__tls_init [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  516,000,000 ( 3.31%)  TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  512,000,000 ( 3.28%)  ???:TLS wrapper function for TinyLog::buffer [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  484,000,000 ( 3.10%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::avail() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  456,008,151 ( 2.92%)  /build/glibc-sMfBJT/glibc-2.31/libio/vsnprintf.c:__vsnprintf_internal [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  455,200,046 ( 2.92%)  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strrchr-avx2.S:__strrchr_avx2 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  373,621,452 ( 2.39%)  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strchr-avx2.S:__strchrnul_avx2 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  328,010,993 ( 2.10%)  /build/glibc-sMfBJT/glibc-2.31/libio/strops.c:_IO_str_init_static_internal [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  272,000,000 ( 1.74%)  TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  248,004,020 ( 1.59%)  TinyLog/src/Logging.cpp:TinyLog::Logger::formatTime() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  212,008,112 ( 1.36%)  TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::append(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  200,007,057 ( 1.28%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_setb [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  184,006,454 ( 1.18%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_no_init [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  176,006,164 ( 1.13%)  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c:_IO_old_init [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
  160,800,184 ( 1.03%)  main.cpp:func() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  144,007,934 ( 0.92%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/../libio/libioP.h:__vfprintf_internal
  140,000,000 ( 0.90%)  /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator()(char const*, unsigned long) const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  140,000,000 ( 0.90%)  TinyLog/src/Timestamp.cpp:TinyLog::Timestamp::now() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  128,015,098 ( 0.82%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/printf-parse.h:__vfprintf_internal
  128,000,000 ( 0.82%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::append(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  120,000,000 ( 0.77%)  /usr/include/c++/9/bits/std_function.h:std::_Function_handler<void (char const*, unsigned long), void (*)(char const*, unsigned long)>::_M_invoke(std::_Any_data const&, char const*&&, unsigned long&&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
  116,000,298 ( 0.74%)  /build/glibc-sMfBJT/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c:pthread_mutex_lock [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
   96,003,408 ( 0.61%)  /build/glibc-sMfBJT/glibc-2.31/stdio-common/snprintf.c:snprintf [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   92,000,138 ( 0.59%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unlock() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   88,002,695 ( 0.56%)  /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_ptr() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   88,000,132 ( 0.56%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::lock() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   88,000,000 ( 0.56%)  ???:0x00000000001246e0 [???]
   88,000,000 ( 0.56%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::avail() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   88,000,000 ( 0.56%)  TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   84,000,126 ( 0.54%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,002,450 ( 0.51%)  /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::get() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,002,450 ( 0.51%)  /usr/include/c++/9/tuple:TinyLog::LogBuffer::FixedBuffer<4194304ul>* const& std::__get_helper<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >(std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,002,450 ( 0.51%)  /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_head(std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,002,450 ( 0.51%)  /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > >::type const& std::get<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >(std::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,001,380 ( 0.51%)  /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   80,000,000 ( 0.51%)  /usr/include/c++/9/bits/std_function.h:std::_Function_base::_M_empty() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   76,000,260 ( 0.49%)  /build/glibc-sMfBJT/glibc-2.31/nptl/pthread_mutex_unlock.c:pthread_mutex_unlock [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
   76,000,013 ( 0.49%)  TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   72,033,174 ( 0.46%)  /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_active_p() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   68,000,000 ( 0.44%)  main.cpp:asynOutput(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   64,000,000 ( 0.41%)  TinyLog/include/Logging.h:TinyLog::str_const::size() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   64,000,000 ( 0.41%)  TinyLog/include/Timestamp.h:TinyLog::Timestamp::getSeconds() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   61,183,332 ( 0.39%)  /build/glibc-sMfBJT/glibc-2.31/libio/libioP.h:_IO_default_xsputn
   60,000,090 ( 0.38%)  /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   60,000,090 ( 0.38%)  /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_lock(pthread_mutex_t*) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   60,000,090 ( 0.38%)  /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_unlock(pthread_mutex_t*) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   60,000,000 ( 0.38%)  /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_get_pointer(std::_Any_data const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   57,037,218 ( 0.37%)  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__mempcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   56,001,715 ( 0.36%)  /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, false>::_M_head(std::_Head_base<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, false> const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   56,000,084 ( 0.36%)  /usr/include/c++/9/bits/std_mutex.h:std::mutex::lock() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   56,000,000 ( 0.36%)  /usr/include/c++/9/bits/move.h:char const*&& std::forward<char const*>(std::remove_reference<char const*>::type&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   56,000,000 ( 0.36%)  /usr/include/c++/9/bits/move.h:unsigned long&& std::forward<unsigned long>(std::remove_reference<unsigned long>::type&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   56,000,000 ( 0.36%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::addLen(unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   44,000,066 ( 0.28%)  /usr/include/c++/9/bits/std_mutex.h:std::mutex::unlock() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   44,000,022 ( 0.28%)  /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::_M_ptr() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   44,000,000 ( 0.28%)  /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator bool() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   44,000,000 ( 0.28%)  TinyLog/include/Timestamp.h:TinyLog::Timestamp::Timestamp(long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,028,050 ( 0.26%)  /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,028,050 ( 0.26%)  /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,020 ( 0.26%)  /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::get() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,020 ( 0.26%)  /usr/include/c++/9/tuple:TinyLog::AsynLog* const& std::__get_helper<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,020 ( 0.26%)  /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >::_M_head(std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,020 ( 0.26%)  /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > >::type const& std::get<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,010 ( 0.26%)  /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::operator->() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,000 ( 0.26%)  /usr/include/c++/9/bits/std_function.h:void (* const&std::_Any_data::_M_access<void (*)(char const*, unsigned long)>() const)(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   40,000,000 ( 0.26%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::current() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   36,000,000 ( 0.23%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::clear() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   32,024,120 ( 0.21%)  /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::get() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   32,001,912 ( 0.20%)  ???:0x0000000004a99390 [???]
   32,000,000 ( 0.20%)  /build/glibc-sMfBJT/glibc-2.31/time/../sysdeps/unix/sysv/linux/gettimeofday.c:__gettimeofday_syscall [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   32,000,000 ( 0.20%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::size() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   32,000,000 ( 0.20%)  TinyLog/include/Logging.h:TinyLog::str_const::data() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   32,000,000 ( 0.20%)  TinyLog/include/Timestamp.h:TinyLog::Timestamp::getMilliSeconds() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,042 ( 0.18%)  /usr/include/c++/9/bits/move.h:std::mutex* std::__addressof<std::mutex>(std::mutex&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,014 ( 0.18%)  /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::AsynLog*, false>::_M_head(std::_Head_base<0ul, TinyLog::AsynLog*, false> const&) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,000 ( 0.18%)  /usr/include/c++/9/bits/move.h:void (* const*std::__addressof<void (* const)(char const*, unsigned long)>(void (* const&)(char const*, unsigned long)))(char const*, unsigned long) [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,000 ( 0.18%)  /usr/include/c++/9/bits/std_function.h:std::_Any_data::_M_access() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,000 ( 0.18%)  TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::data() const [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]
   28,000,000 ( 0.18%)  TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTidStr() [/home1/jsj/Code/cpp/projects/AsynLog/build/AsynLog]

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/src/Logging.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 18 ----------------------------------------
          .           #include <cstdlib>
          .           #include <ctime>
          .           #include <mutex>
          .           #include <utility>
          .           
          .           namespace TinyLog {
          .           
          .           /*Global Logger Config*/
          6 ( 0.00%)  LogConfig kLogConfig;
         74 ( 0.00%)  => ???:0x0000000000124700 (1x)
         43 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/LogConfig.h:TinyLog::LogConfig::LogConfig() (1x)
          .           
          .           /* Logger 单例变量的定义 */
          .           Logger *Logger::_logger = nullptr;
          .           std::mutex Logger::_mtx;
          .           
          .           /* 用于回收单例资源 */
          4 ( 0.00%)  Logger::GC gcVariabel;
         74 ( 0.00%)  => ???:0x0000000000124700 (1x)
          .           
          .           /* 线程局部变量, 对日期和时间部分进行缓存, 每个线程拥有独立的缓存*/
          .           thread_local time_t prevSecond;
          .           thread_local char timeStr[64];
384,000,032 ( 2.46%)  thread_local Logger::Buffer buffer;
         72 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::FixedBuffer() (8x)
          .           
 32,000,000 ( 0.20%)  Logger *Logger::getInstance() {
          .             /* 双检锁实现单例模式 */
 12,000,000 ( 0.08%)    if (_logger == nullptr) {
          .               /* RAII lock template */
          7 ( 0.00%)      std::unique_lock<std::mutex> lock(_mtx);
        119 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&) (1x)
         94 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock() (1x)
          3 ( 0.00%)      if (_logger == nullptr)
          3 ( 0.00%)        _logger = new Logger;
      1,453 ( 0.00%)  => ???:0x0000000000124780 (1x)
          .             }
  4,000,000 ( 0.03%)    return _logger;
 28,000,000 ( 0.18%)  }
          .           
          .           /* 默认日志等级为: INFO*/
          6 ( 0.00%)  inline Logger::LogLevel defaultLogLevel() { return kLogConfig.logLevel; }
          .           
          .           const char *LogLevelStr[Logger::LogLevel::numOfLevels] = {
          .               "TRACE", "DEBUG", "INFO ", "WARN ", "ERROR", "FATAL",
          .           };
          .           
          .           /* 默认输出路径为stdout */
          .           inline void defaultOutput(const char *_msg, size_t _len) {
          .             size_t n = fwrite(_msg, 1, _len, stdout);
          .             (void)n;
          .           }
          .           
          .           /* 默认flush函数*/
          .           inline void defaultFlush() { fflush(stdout); }
          .           
          2 ( 0.00%)  Logger::LogLevel _global_logLevel = defaultLogLevel();
          6 ( 0.00%)  => TinyLog/src/Logging.cpp:TinyLog::defaultLogLevel() (1x)
          7 ( 0.00%)  Logger::outPutFunc _global_outPutFunc = defaultOutput;
         74 ( 0.00%)  => ???:0x0000000000124700 (1x)
        134 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::function<void (*)(char const*, unsigned long), void, void>(void (*)(char const*, unsigned long)) (1x)
          7 ( 0.00%)  Logger::flushFunc _global_flushFunc = defaultFlush;
         74 ( 0.00%)  => ???:0x0000000000124700 (1x)
        134 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void ()>::function<void (*)(), void, void>(void (*)()) (1x)
          .           
          5 ( 0.00%)  void Logger::setOutput(Logger::outPutFunc _func) {
          6 ( 0.00%)    _global_outPutFunc = std::move(_func);
        535 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator=(std::function<void (char const*, unsigned long)>&&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<std::function<void (char const*, unsigned long)>&>::type&& std::move<std::function<void (char const*, unsigned long)>&>(std::function<void (char const*, unsigned long)>&) (1x)
          3 ( 0.00%)  }
          .           
          .           void Logger::setFlush(Logger::flushFunc _func) {
          .             _global_flushFunc = std::move(_func);
          .           }
          .           
          .           /* 不能被内联 */
  9,600,000 ( 0.06%)  Logger::LogLevel Logger::getLogLevel() { return kLogConfig.logLevel; }
          .           
          .           /* 不能被内联 */
         12 ( 0.00%)  void Logger::setConfig(const LogConfig &_config) { kLogConfig = _config; }
      1,461 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/LogConfig.h:TinyLog::LogConfig::operator=(TinyLog::LogConfig const&) (1x)
          .           
          .           /* 设置日志时间, 使用TLS进行缓存优化 */
 28,000,000 ( 0.18%)  inline void Logger::formatTime() {
  8,000,000 ( 0.05%)    Timestamp current = Timestamp::now();
224,000,000 ( 1.43%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Timestamp.cpp:TinyLog::Timestamp::now() (4,000,000x)
 16,000,000 ( 0.10%)    time_t curSecond = current.getSeconds();
 64,000,000 ( 0.41%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::getSeconds() (4,000,000x)
 60,000,000 ( 0.38%)    int milliSecond = static_cast<int>(current.getMilliSeconds() %
 32,000,000 ( 0.20%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::getMilliSeconds() (4,000,000x)
  4,000,000 ( 0.03%)                                       Timestamp::kmilliSecondsPerSecond);
          .             /* 无法使用TLS时间缓存进行优化 */
 16,000,000 ( 0.10%)    if (curSecond != prevSecond) {
        268 ( 0.00%)      prevSecond = curSecond;
          .               /* 重新写入时间到TLS中 */
          .               struct tm tm_time;
        670 ( 0.00%)      localtime_r(&curSecond, &tm_time);
    260,094 ( 0.00%)  => ???:0x0000000000124620 (134x)
          .           
      2,814 ( 0.00%)      snprintf(timeStr, sizeof(timeStr), "%4d-%02d-%02d %02d:%02d:%02d-",
    419,172 ( 0.00%)  => ???:0x0000000000124930 (134x)
        268 ( 0.00%)               tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
          .                        tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
          .             }
          .             /* 写入日志行缓冲区中: 精确到秒 */
 32,000,000 ( 0.20%)    buffer.append(timeStr, 20);
224,000,000 ( 1.43%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,112 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
          .             /* 写入毫秒 */
          .             char mStr[6];
 32,000,000 ( 0.20%)    snprintf(mStr, sizeof(mStr), "%03d ", milliSecond);
3,116,166,108 (19.96%)  => ???:0x0000000000124930 (4,000,000x)
 28,000,000 ( 0.18%)    buffer.append(mStr, 4);
240,000,000 ( 1.54%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 24,000,000 ( 0.15%)  }
          .           
          .           /* file和line在编译期获取其长度fileLen, lineLen */
          .           void Logger::append(const char *file, size_t fileLen, const char *line,
          .                               size_t lineLen, const char *fmt, Logger::LogLevel level,
 68,000,000 ( 0.44%)                      ...) {
          .             /* 处理日志中的时间 */
  4,000,000 ( 0.03%)    formatTime();
4,292,849,506 (27.50%)  => TinyLog/src/Logging.cpp:TinyLog::Logger::formatTime() (4,000,000x)
          .           
          .             /* 添加线程号: ID*/
 20,000,000 ( 0.13%)    buffer.append("tid:", 4);
240,000,000 ( 1.54%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 36,000,000 ( 0.23%)    buffer.append(ThreadInfo::getTidStr(), ThreadInfo::getTidStrlen());
232,000,000 ( 1.49%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 28,000,000 ( 0.18%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTidStr() (4,000,000x)
 24,000,000 ( 0.15%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTidStrlen() (4,000,000x)
          .           
          .             /* 源文件[line:行号] - 日志级别
          .              *  example:
          .              *  test.py[line:233] - INFO: 正文
          .              */
 28,000,000 ( 0.18%)    buffer.append(file, fileLen);
232,000,000 ( 1.49%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 20,000,000 ( 0.13%)    buffer.append("[line:", 6);
240,000,000 ( 1.54%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 28,000,000 ( 0.18%)    buffer.append(line, lineLen);
248,000,000 ( 1.59%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 20,000,000 ( 0.13%)    buffer.append("] - ", 4);
240,000,000 ( 1.54%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 44,000,000 ( 0.28%)    buffer.append(LogLevelStr[level], 5);
240,000,000 ( 1.54%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 20,000,000 ( 0.13%)    buffer.append(": ", 2);
248,000,000 ( 1.59%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::append(char const*, unsigned long) (4,000,000x)
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
          .           
          .             /* 正文, 使用va_list、va_arg和va_end等宏来处理, 其原理是
          .              * cdelc_ 参数从右到左压栈, 第一个参数在栈顶 */
          .             va_list argPtr;
 24,000,000 ( 0.15%)    va_start(argPtr, fmt);
 60,000,000 ( 0.38%)    int n = vsnprintf(buffer.current(), buffer.avail(), fmt, argPtr);
3,369,600,000 (21.58%)  => ???:0x0000000000124520 (4,000,000x)
144,000,000 ( 0.92%)  => ???:TLS wrapper function for TinyLog::buffer (8,000,000x)
 44,000,000 ( 0.28%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::avail() const (4,000,000x)
 40,000,000 ( 0.26%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::current() (4,000,000x)
          .             va_end(argPtr);
 28,000,000 ( 0.18%)    buffer.addLen(static_cast<size_t>(n));
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 56,000,000 ( 0.36%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::addLen(unsigned long) (4,000,000x)
          .           
          .             /* appen到outPutfunc */
          .             /* used for BenchMark*/
 16,000,000 ( 0.10%)    if (_global_outPutFunc)
 84,000,000 ( 0.54%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator bool() const (4,000,000x)
 44,000,000 ( 0.28%)      _global_outPutFunc(buffer.data(), buffer.size());
2,940,517,977 (18.84%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::operator()(char const*, unsigned long) const (4,000,000x)
144,000,000 ( 0.92%)  => ???:TLS wrapper function for TinyLog::buffer (8,000,000x)
 32,000,000 ( 0.20%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::size() const (4,000,000x)
 28,000,000 ( 0.18%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::data() const (4,000,000x)
          .             /* 缓冲区清空, 等待线程下一条日志记录, 因为其是TLS变量*/
 12,000,000 ( 0.08%)    buffer.clear();
 72,000,000 ( 0.46%)  => ???:TLS wrapper function for TinyLog::buffer (4,000,000x)
 36,000,000 ( 0.23%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<1024ul>::clear() (4,000,000x)
          .             /* 学习muduo的做法 */
  8,000,000 ( 0.05%)    if (level == Logger::FATAL) {
          .               if (_global_flushFunc)
          .                 _global_flushFunc();
          .               abort();
          .             }
 36,000,000 ( 0.23%)  }
          .           
256,000,029 ( 1.64%)  } // namespace TinyLog
        652 ( 0.00%)  => TinyLog/src/Logging.cpp:__static_initialization_and_destruction_0(int, int) (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/unique_lock.h
--------------------------------------------------------------------------------
Ir                  

-- line 60 ----------------------------------------
         .               {
         .               public:
         .                 typedef _Mutex mutex_type;
         .           
         .                 unique_lock() noexcept
         .                 : _M_device(0), _M_owns(false)
         .                 { }
         .           
24,000,036 ( 0.15%)        explicit unique_lock(mutex_type& __m)
28,000,042 ( 0.18%)        : _M_device(std::__addressof(__m)), _M_owns(false)
28,000,042 ( 0.18%)  => /usr/include/c++/9/bits/move.h:std::mutex* std::__addressof<std::mutex>(std::mutex&) (4,000,006x)
         .                 {
12,000,018 ( 0.08%)  	lock();
364,000,782 ( 2.33%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::lock() (4,000,006x)
 8,000,012 ( 0.05%)  	_M_owns = true;
12,000,018 ( 0.08%)        }
         .           
         .                 unique_lock(mutex_type& __m, defer_lock_t) noexcept
         .                 : _M_device(std::__addressof(__m)), _M_owns(false)
         .                 { }
         .           
         .                 unique_lock(mutex_type& __m, try_to_lock_t)
         .                 : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())
         .                 { }
-- line 81 ----------------------------------------
-- line 95 ----------------------------------------
         .           
         .                 template<typename _Rep, typename _Period>
         .           	unique_lock(mutex_type& __m,
         .           		    const chrono::duration<_Rep, _Period>& __rtime)
         .           	: _M_device(std::__addressof(__m)),
         .           	  _M_owns(_M_device->try_lock_for(__rtime))
         .           	{ }
         .           
20,000,030 ( 0.13%)        ~unique_lock()
         .                 {
16,000,024 ( 0.10%)  	if (_M_owns)
12,000,018 ( 0.08%)  	  unlock();
316,000,558 ( 2.02%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unlock() (4,000,006x)
12,000,018 ( 0.08%)        }
         .           
         .                 unique_lock(const unique_lock&) = delete;
         .                 unique_lock& operator=(const unique_lock&) = delete;
         .           
         .                 unique_lock(unique_lock&& __u) noexcept
         .                 : _M_device(__u._M_device), _M_owns(__u._M_owns)
         .                 {
         .           	__u._M_device = 0;
-- line 115 ----------------------------------------
-- line 125 ----------------------------------------
         .           
         .           	__u._M_device = 0;
         .           	__u._M_owns = false;
         .           
         .           	return *this;
         .                 }
         .           
         .                 void
20,000,030 ( 0.13%)        lock()
         .                 {
16,000,024 ( 0.10%)  	if (!_M_device)
         .           	  __throw_system_error(int(errc::operation_not_permitted));
16,000,024 ( 0.10%)  	else if (_M_owns)
         .           	  __throw_system_error(int(errc::resource_deadlock_would_occur));
         .           	else
         .           	  {
16,000,024 ( 0.10%)  	    _M_device->lock();
276,000,650 ( 1.77%)  => /usr/include/c++/9/bits/std_mutex.h:std::mutex::lock() (4,000,006x)
 8,000,012 ( 0.05%)  	    _M_owns = true;
         .           	  }
12,000,018 ( 0.08%)        }
         .           
         .                 bool
         .                 try_lock()
         .                 {
         .           	if (!_M_device)
         .           	  __throw_system_error(int(errc::operation_not_permitted));
         .           	else if (_M_owns)
         .           	  __throw_system_error(int(errc::resource_deadlock_would_occur));
-- line 152 ----------------------------------------
-- line 183 ----------------------------------------
         .           	  else
         .           	    {
         .           	      _M_owns = _M_device->try_lock_for(__rtime);
         .           	      return _M_owns;
         .           	    }
         .           	 }
         .           
         .                 void
20,000,030 ( 0.13%)        unlock()
         .                 {
20,000,030 ( 0.13%)  	if (!_M_owns)
         .           	  __throw_system_error(int(errc::operation_not_permitted));
16,000,024 ( 0.10%)  	else if (_M_device)
         .           	  {
16,000,024 ( 0.10%)  	    _M_device->unlock();
224,000,420 ( 1.43%)  => /usr/include/c++/9/bits/std_mutex.h:std::mutex::unlock() (4,000,006x)
 8,000,012 ( 0.05%)  	    _M_owns = false;
         .           	  }
12,000,018 ( 0.08%)        }
         .           
         .                 void
         .                 swap(unique_lock& __u) noexcept
         .                 {
         .           	std::swap(_M_device, __u._M_device);
         .           	std::swap(_M_owns, __u._M_owns);
         .                 }
         .           
-- line 208 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/shared_ptr_base.h
--------------------------------------------------------------------------------
Ir                  

-- line 109 ----------------------------------------
         .                 enum { _S_need_barriers = 1 };
         .               };
         .           
         .             template<_Lock_policy _Lp = __default_lock_policy>
         .               class _Sp_counted_base
         .               : public _Mutex_base<_Lp>
         .               {
         .               public:
       436 ( 0.00%)        _Sp_counted_base() noexcept
     1,090 ( 0.00%)        : _M_use_count(1), _M_weak_count(1) { }
         .           
         .                 virtual
       436 ( 0.00%)        ~_Sp_counted_base() noexcept
       654 ( 0.00%)        { }
         .           
         .                 // Called when _M_use_count drops to zero, to release the resources
         .                 // managed by *this.
         .                 virtual void
         .                 _M_dispose() noexcept = 0;
         .           
         .                 // Called when _M_weak_count drops to zero.
         .                 virtual void
         .                 _M_destroy() noexcept
         .                 { delete this; }
         .           
         .                 virtual void*
         .                 _M_get_deleter(const std::type_info&) noexcept = 0;
         .           
         .                 void
     8,640 ( 0.00%)        _M_add_ref_copy()
    13,824 ( 0.00%)        { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
    65,664 ( 0.00%)  => /usr/include/c++/9/ext/atomicity.h:__gnu_cxx::__atomic_add_dispatch(int*, int) (1,728x)
         .           
         .                 void
         .                 _M_add_ref_lock();
         .           
         .                 bool
         .                 _M_add_ref_lock_nothrow();
         .           
         .                 void
     9,185 ( 0.00%)        _M_release() noexcept
         .                 {
         .                   // Be race-detector-friendly.  For more info see bits/c++config.
         .                   _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
    16,533 ( 0.00%)  	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
    67,969 ( 0.00%)  => /usr/include/c++/9/ext/atomicity.h:__gnu_cxx::__exchange_and_add_dispatch(int*, int) (1,837x)
         .           	  {
         .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
       763 ( 0.00%)  	    _M_dispose();
    45,547 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (109x)
         .           	    // There must be a memory barrier between dispose() and destroy()
         .           	    // to ensure that the effects of dispose() are observed in the
         .           	    // thread that runs destroy().
         .           	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
         .           	    if (_Mutex_base<_Lp>::_S_need_barriers)
         .           	      {
         .           		__atomic_thread_fence (__ATOMIC_ACQ_REL);
         .           	      }
         .           
         .                       // Be race-detector-friendly.  For more info see bits/c++config.
         .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
       763 ( 0.00%)  	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
     4,033 ( 0.00%)  => /usr/include/c++/9/ext/atomicity.h:__gnu_cxx::__exchange_and_add_dispatch(int*, int) (109x)
       218 ( 0.00%)  						       -1) == 1)
         .                         {
         .                           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
       763 ( 0.00%)  	        _M_destroy();
    38,048 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (109x)
         .                         }
         .           	  }
     5,511 ( 0.00%)        }
         .           
         .                 void
         .                 _M_weak_add_ref() noexcept
         .                 { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
         .           
         .                 void
         .                 _M_weak_release() noexcept
         .                 {
-- line 182 ----------------------------------------
-- line 404 ----------------------------------------
         .               _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }
         .           
         .             template<int _Nm, typename _Tp,
         .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
         .               struct _Sp_ebo_helper;
         .           
         .             /// Specialization using EBO.
         .             template<int _Nm, typename _Tp>
     1,199 ( 0.00%)      struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::~allocator() (109x)
         .               {
     1,526 ( 0.00%)        explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
     2,398 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::allocator(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
         .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }
         .           
         .                 static _Tp&
     1,526 ( 0.00%)        _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
         .               };
         .           
         .             /// Specialization not using EBO.
         .             template<int _Nm, typename _Tp>
         .               struct _Sp_ebo_helper<_Nm, _Tp, false>
         .               {
         .                 explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
         .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }
-- line 426 ----------------------------------------
-- line 518 ----------------------------------------
         .               struct _Sp_alloc_shared_tag
         .               {
         .                 const _Alloc& _M_a;
         .               };
         .           
         .             template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
         .               class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
         .               {
     1,199 ( 0.00%)        class _Impl : _Sp_ebo_helper<0, _Alloc>
     3,161 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<TinyLog::AsynLog::BufferNode>, true>::~_Sp_ebo_helper() (109x)
         .                 {
         .           	typedef _Sp_ebo_helper<0, _Alloc>	_A_base;
         .           
         .                 public:
     1,526 ( 0.00%)  	explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }
     3,924 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<TinyLog::AsynLog::BufferNode>, true>::_Sp_ebo_helper(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
         .           
     2,180 ( 0.00%)  	_Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }
     1,526 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<TinyLog::AsynLog::BufferNode>, true>::_S_get(std::_Sp_ebo_helper<0, std::allocator<TinyLog::AsynLog::BufferNode>, true>&) (218x)
         .           
         .           	__gnu_cxx::__aligned_buffer<_Tp> _M_storage;
         .                 };
         .           
         .               public:
         .                 using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
         .           
         .                 // Alloc parameter is not a reference so doesn't alias anything in __args
         .                 template<typename... _Args>
     1,090 ( 0.00%)  	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
     2,180 ( 0.00%)  	: _M_impl(__a)
     5,450 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_Impl::_Impl(std::allocator<TinyLog::AsynLog::BufferNode>) (109x)
     2,398 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::allocator(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::~allocator() (109x)
     1,526 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_Sp_counted_base() (109x)
         .           	{
         .           	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           	  // 2070.  allocate_shared should use allocator_traits<A>::construct
       872 ( 0.00%)  	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
    24,852 ( 0.00%)  => /usr/include/c++/9/bits/alloc_traits.h:void std::allocator_traits<std::allocator<TinyLog::AsynLog::BufferNode> >::construct<TinyLog::AsynLog::BufferNode>(std::allocator<TinyLog::AsynLog::BufferNode>&, TinyLog::AsynLog::BufferNode*) (109x)
     3,052 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (109x)
         .           	      std::forward<_Args>(__args)...); // might throw
       872 ( 0.00%)  	}
         .           
     1,962 ( 0.00%)        ~_Sp_counted_ptr_inplace() noexcept { }
     4,360 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_Impl::~_Impl() (109x)
     1,090 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::~_Sp_counted_base() (109x)
         .           
         .                 virtual void
       654 ( 0.00%)        _M_dispose() noexcept
         .                 {
     1,199 ( 0.00%)  	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
    38,244 ( 0.00%)  => /usr/include/c++/9/bits/alloc_traits.h:void std::allocator_traits<std::allocator<TinyLog::AsynLog::BufferNode> >::destroy<TinyLog::AsynLog::BufferNode>(std::allocator<TinyLog::AsynLog::BufferNode>&, TinyLog::AsynLog::BufferNode*) (109x)
     3,052 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (109x)
     1,853 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_Impl::_M_alloc() (109x)
       545 ( 0.00%)        }
         .           
         .                 // Override because the allocator needs to know the dynamic type
         .                 virtual void
       872 ( 0.00%)        _M_destroy() noexcept
         .                 {
     1,308 ( 0.00%)  	__allocator_type __a(_M_impl._M_alloc());
     2,071 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >::allocator<TinyLog::AsynLog::BufferNode>(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >::~allocator() (109x)
     1,853 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_Impl::_M_alloc() (109x)
       981 ( 0.00%)  	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
    17,883 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() (109x)
     2,725 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >::__allocated_ptr(std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >&, std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>*) (109x)
       327 ( 0.00%)  	this->~_Sp_counted_ptr_inplace();
     7,412 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::~_Sp_counted_ptr_inplace() (109x)
       654 ( 0.00%)        }
         .           
         .               private:
         .                 friend class __shared_count<_Lp>; // To be able to call _M_ptr().
         .           
         .                 // No longer used, but code compiled against old libstdc++ headers
         .                 // might still call it from __shared_ptr ctor to get the pointer out.
         .                 virtual void*
         .                 _M_get_deleter(const std::type_info& __ti) noexcept override
-- line 575 ----------------------------------------
-- line 586 ----------------------------------------
         .           #else
         .           	    _Sp_make_shared_tag::_S_eq(__ti)
         .           #endif
         .           	   )
         .           	  return __ptr;
         .           	return nullptr;
         .                 }
         .           
     3,597 ( 0.00%)        _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
     5,559 ( 0.00%)  => /usr/include/c++/9/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<TinyLog::AsynLog::BufferNode>::_M_ptr() (327x)
         .           
         .                 _Impl _M_impl;
         .               };
         .           
         .             // The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.
         .             struct __sp_array_delete
         .             {
         .               template<typename _Yp>
-- line 602 ----------------------------------------
-- line 608 ----------------------------------------
         .               {
         .                 template<typename _Tp>
         .           	struct __not_alloc_shared_tag { using type = void; };
         .           
         .                 template<typename _Tp>
         .           	struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };
         .           
         .               public:
     3,384 ( 0.00%)        constexpr __shared_count() noexcept : _M_pi(0)
     1,692 ( 0.00%)        { }
         .           
         .                 template<typename _Ptr>
         .                   explicit
         .           	__shared_count(_Ptr __p) : _M_pi(0)
         .           	{
         .           	  __try
         .           	    {
         .           	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
-- line 625 ----------------------------------------
-- line 664 ----------------------------------------
         .           	  __catch(...)
         .           	    {
         .           	      __d(__p); // Call _Deleter on __p.
         .           	      __throw_exception_again;
         .           	    }
         .           	}
         .           
         .                 template<typename _Tp, typename _Alloc, typename... _Args>
     1,417 ( 0.00%)  	__shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         .           		       _Args&&... __args)
         .           	{
         .           	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
       872 ( 0.00%)  	  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
     2,071 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >::allocator<TinyLog::AsynLog::BufferNode>(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >::~allocator() (109x)
       872 ( 0.00%)  	  auto __guard = std::__allocate_guarded(__a2);
    42,704 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > > std::__allocate_guarded<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >(std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> >&) (109x)
     1,308 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() (109x)
       436 ( 0.00%)  	  _Sp_cp_type* __mem = __guard.get();
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >::get() (109x)
     1,962 ( 0.00%)  	  auto __pi = ::new (__mem)
    44,254 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_Sp_counted_ptr_inplace<>(std::allocator<TinyLog::AsynLog::BufferNode>) (109x)
     2,398 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::allocator(std::allocator<TinyLog::AsynLog::BufferNode> const&) (109x)
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<TinyLog::AsynLog::BufferNode>::~allocator() (109x)
       872 ( 0.00%)  => /usr/include/c++/9/new:operator new(unsigned long, void*) (109x)
         .           	    _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
       436 ( 0.00%)  	  __guard = nullptr;
     1,090 ( 0.00%)  => /usr/include/c++/9/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2> > >::operator=(decltype(nullptr)) (109x)
       327 ( 0.00%)  	  _M_pi = __pi;
       545 ( 0.00%)  	  __p = __pi->_M_ptr();
     3,052 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (109x)
     1,090 ( 0.00%)  	}
         .           
         .           #if _GLIBCXX_USE_DEPRECATED
         .           #pragma GCC diagnostic push
         .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .                 // Special case for auto_ptr<_Tp> to provide the strong guarantee.
         .                 template<typename _Tp>
         .                   explicit
         .           	__shared_count(std::auto_ptr<_Tp>&& __r);
-- line 692 ----------------------------------------
-- line 719 ----------------------------------------
         .           	}
         .           
         .                 // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
         .                 explicit __shared_count(const __weak_count<_Lp>& __r);
         .           
         .                 // Does not throw if __r._M_get_use_count() == 0, caller must check.
         .                 explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);
         .           
     6,120 ( 0.00%)        ~__shared_count() noexcept
         .                 {
     4,896 ( 0.00%)  	if (_M_pi != nullptr)
     3,068 ( 0.00%)  	  _M_pi->_M_release();
    43,564 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() (767x)
     3,672 ( 0.00%)        }
         .           
     3,306 ( 0.00%)        __shared_count(const __shared_count& __r) noexcept
     2,204 ( 0.00%)        : _M_pi(__r._M_pi)
         .                 {
     2,204 ( 0.00%)  	if (_M_pi != 0)
     2,200 ( 0.00%)  	  _M_pi->_M_add_ref_copy();
    28,050 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy() (550x)
     1,653 ( 0.00%)        }
         .           
         .                 __shared_count&
     8,346 ( 0.00%)        operator=(const __shared_count& __r) noexcept
         .                 {
     4,173 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
     5,564 ( 0.00%)  	if (__tmp != _M_pi)
         .           	  {
     2,574 ( 0.00%)  	    if (__tmp != 0)
     3,534 ( 0.00%)  	      __tmp->_M_add_ref_copy();
    60,078 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy() (1,178x)
     5,148 ( 0.00%)  	    if (_M_pi != 0)
     4,280 ( 0.00%)  	      _M_pi->_M_release();
   145,769 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() (1,070x)
     3,861 ( 0.00%)  	    _M_pi = __tmp;
         .           	  }
     1,391 ( 0.00%)  	return *this;
     2,782 ( 0.00%)        }
         .           
         .                 void
     1,725 ( 0.00%)        _M_swap(__shared_count& __r) noexcept
         .                 {
     1,035 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
     1,380 ( 0.00%)  	__r._M_pi = _M_pi;
     1,035 ( 0.00%)  	_M_pi = __tmp;
     1,035 ( 0.00%)        }
         .           
         .                 long
         .                 _M_get_use_count() const noexcept
         .                 { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
         .           
         .                 bool
         .                 _M_unique() const noexcept
         .                 { return this->_M_get_use_count() == 1; }
-- line 769 ----------------------------------------
-- line 1004 ----------------------------------------
         .                 element_type&
         .                 operator*() const noexcept
         .                 {
         .           	__glibcxx_assert(_M_get() != nullptr);
         .           	return *_M_get();
         .                 }
         .           
         .                 element_type*
20,014,025 ( 0.13%)        operator->() const noexcept
         .                 {
         .           	_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);
12,008,415 ( 0.08%)  	return _M_get();
72,050,490 ( 0.46%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const (4,002,805x)
 8,005,610 ( 0.05%)        }
         .           
         .               private:
         .                 element_type*
20,014,025 ( 0.13%)        _M_get() const noexcept
20,014,025 ( 0.13%)        { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
32,022,440 ( 0.21%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::get() const (4,002,805x)
         .               };
         .           
         .             // Define operator-> for shared_ptr<cv void>.
         .             template<typename _Tp, _Lock_policy _Lp>
         .               class __shared_ptr_access<_Tp, _Lp, false, true>
         .               {
         .               public:
         .                 using element_type = _Tp;
-- line 1029 ----------------------------------------
-- line 1072 ----------------------------------------
         .           
         .               private:
         .                 element_type*
         .                 _M_get() const noexcept
         .                 { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
         .               };
         .           
         .             template<typename _Tp, _Lock_policy _Lp>
    27,820 ( 0.00%)      class __shared_ptr
   247,500 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1,391x)
         .               : public __shared_ptr_access<_Tp, _Lp>
         .               {
         .               public:
         .                 using element_type = typename remove_extent<_Tp>::type;
         .           
         .               private:
         .                 // Constraint for taking ownership of a pointer of type _Yp*:
         .                 template<typename _Yp>
-- line 1088 ----------------------------------------
-- line 1110 ----------------------------------------
         .           	using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;
         .           
         .               public:
         .           
         .           #if __cplusplus > 201402L
         .                 using weak_type = __weak_ptr<_Tp, _Lp>;
         .           #endif
         .           
     1,640 ( 0.00%)        constexpr __shared_ptr() noexcept
     1,968 ( 0.00%)        : _M_ptr(0), _M_refcount()
     2,952 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (328x)
       984 ( 0.00%)        { }
         .           
         .                 template<typename _Yp, typename = _SafeConv<_Yp>>
         .           	explicit
         .           	__shared_ptr(_Yp* __p)
         .           	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
         .           	{
         .           	  static_assert( !is_void<_Yp>::value, "incomplete type" );
         .           	  static_assert( sizeof(_Yp) > 0, "incomplete type" );
-- line 1128 ----------------------------------------
-- line 1159 ----------------------------------------
         .           	{ }
         .           
         .                 template<typename _Yp>
         .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
         .           		     element_type* __p) noexcept
         .           	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
         .           	{ }
         .           
    11,020 ( 0.00%)        __shared_ptr(const __shared_ptr&) noexcept = default;
    39,617 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (551x)
         .                 __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
    14,688 ( 0.00%)        ~__shared_ptr() = default;
    61,248 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() (1,218x)
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         .           	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         .           	{ }
         .           
     1,416 ( 0.00%)        __shared_ptr(__shared_ptr&& __r) noexcept
     1,888 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount()
     2,124 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (236x)
         .                 {
     1,652 ( 0.00%)  	_M_refcount._M_swap(__r._M_refcount);
     4,248 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (236x)
       472 ( 0.00%)  	__r._M_ptr = 0;
       708 ( 0.00%)        }
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
         .           	: _M_ptr(__r._M_ptr), _M_refcount()
         .           	{
         .           	  _M_refcount._M_swap(__r._M_refcount);
         .           	  __r._M_ptr = 0;
         .           	}
-- line 1189 ----------------------------------------
-- line 1255 ----------------------------------------
         .           	{
         .           	  __shared_ptr(std::move(__r)).swap(*this);
         .           	  return *this;
         .           	}
         .           #pragma GCC diagnostic pop
         .           #endif
         .           
         .                 __shared_ptr&
       981 ( 0.00%)        operator=(__shared_ptr&& __r) noexcept
         .                 {
     1,744 ( 0.00%)  	__shared_ptr(std::move(__r)).swap(*this);
    10,028 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::swap(std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>&) (109x)
     8,880 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() (109x)
     5,777 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>&&) (109x)
       763 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>&>::type&& std::move<std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>&>(std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>&) (109x)
       109 ( 0.00%)  	return *this;
       545 ( 0.00%)        }
         .           
         .                 template<class _Yp>
         .           	_Assignable<_Yp>
         .           	operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
         .           	{
         .           	  __shared_ptr(std::move(__r)).swap(*this);
         .           	  return *this;
         .           	}
-- line 1275 ----------------------------------------
-- line 1301 ----------------------------------------
         .           	{ __shared_ptr(__p, std::move(__d)).swap(*this); }
         .           
         .                 template<typename _Yp, typename _Deleter, typename _Alloc>
         .           	_SafeConv<_Yp>
         .           	reset(_Yp* __p, _Deleter __d, _Alloc __a)
         .                   { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }
         .           
         .                 element_type*
16,012,060 ( 0.10%)        get() const noexcept
16,012,060 ( 0.10%)        { return _M_ptr; }
         .           
       440 ( 0.00%)        explicit operator bool() const // never throws
       660 ( 0.00%)        { return _M_ptr == 0 ? false : true; }
         .           
         .                 bool
         .                 unique() const noexcept
         .                 { return _M_refcount._M_unique(); }
         .           
         .                 long
         .                 use_count() const noexcept
         .                 { return _M_refcount._M_get_use_count(); }
         .           
         .                 void
       654 ( 0.00%)        swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
         .                 {
       545 ( 0.00%)  	std::swap(_M_ptr, __other._M_ptr);
     5,777 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<TinyLog::AsynLog::BufferNode*> >, std::is_move_constructible<TinyLog::AsynLog::BufferNode*>, std::is_move_assignable<TinyLog::AsynLog::BufferNode*> >::value, void>::type std::swap<TinyLog::AsynLog::BufferNode*>(TinyLog::AsynLog::BufferNode*&, TinyLog::AsynLog::BufferNode*&) (109x)
       763 ( 0.00%)  	_M_refcount._M_swap(__other._M_refcount);
     1,962 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (109x)
       327 ( 0.00%)        }
         .           
         .                 template<typename _Tp1>
         .           	bool
         .           	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .           
         .                 template<typename _Tp1>
         .           	bool
         .           	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .           
         .               protected:
         .                 // This constructor is non-standard, it is used by allocate_shared.
         .                 template<typename _Alloc, typename... _Args>
       654 ( 0.00%)  	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
       981 ( 0.00%)  	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
   111,592 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count<TinyLog::AsynLog::BufferNode, std::allocator<TinyLog::AsynLog::BufferNode>>(TinyLog::AsynLog::BufferNode*&, std::_Sp_alloc_shared_tag<std::allocator<TinyLog::AsynLog::BufferNode> >) (109x)
       981 ( 0.00%)  	{ _M_enable_shared_from_this_with(_M_ptr); }
       872 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::enable_if<!std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::__has_esft_base<TinyLog::AsynLog::BufferNode, void>::value, void>::type std::__shared_ptr<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2>::_M_enable_shared_from_this_with<TinyLog::AsynLog::BufferNode, TinyLog::AsynLog::BufferNode>(TinyLog::AsynLog::BufferNode*) (109x)
         .           
         .                 template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
         .           	       typename... _Args>
         .           	friend __shared_ptr<_Tp1, _Lp1>
         .           	__allocate_shared(const _Alloc& __a, _Args&&... __args);
         .           
         .                 // This constructor is used by __weak_ptr::lock() and
         .                 // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).
-- line 1353 ----------------------------------------
-- line 1380 ----------------------------------------
         .           	_M_enable_shared_from_this_with(_Yp* __p) noexcept
         .           	{
         .           	  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
         .           	    __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
         .           	}
         .           
         .                 template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
         .           	typename enable_if<!__has_esft_base<_Yp2>::value>::type
       545 ( 0.00%)  	_M_enable_shared_from_this_with(_Yp*) noexcept
       327 ( 0.00%)  	{ }
         .           
         .                 void*
         .                 _M_get_deleter(const std::type_info& __ti) const noexcept
         .                 { return _M_refcount._M_get_deleter(__ti); }
         .           
         .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
         .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
         .           
-- line 1397 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h
--------------------------------------------------------------------------------
Ir                  

-- line 241 ----------------------------------------
         .           #elif defined (__BIONIC__)
         .           # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_create)
         .           #else
         .           # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_cancel)
         .           #endif
         .           
         .           static inline int
         .           __gthread_active_p (void)
16,007,372 ( 0.10%)  {
         .             static void *const __gthread_active_ptr
         .               = __extension__ (void *) &GTHR_ACTIVE_PROXY;
40,018,430 ( 0.26%)    return __gthread_active_ptr != 0;
16,007,372 ( 0.10%)  }
         .           
         .           #endif /* FreeBSD or Solaris */
         .           
         .           #else /* not __GXX_WEAK__ */
         .           
         .           /* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread
         .              calls in shared flavors of the HP-UX C library.  Most of the stubs
         .              have no functionality.  The details are described in the "libc cumulative
-- line 261 ----------------------------------------
-- line 739 ----------------------------------------
         .             if (__gthread_active_p ())
         .               return __gthrw_(pthread_mutex_destroy) (__mutex);
         .             else
         .               return 0;
         .           }
         .           
         .           static inline int
         .           __gthread_mutex_lock (__gthread_mutex_t *__mutex)
16,000,024 ( 0.10%)  {
20,000,030 ( 0.13%)    if (__gthread_active_p ())
36,000,054 ( 0.23%)  => /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_active_p() (4,000,006x)
16,000,024 ( 0.10%)      return __gthrw_(pthread_mutex_lock) (__mutex);
124,000,422 ( 0.79%)  => ???:0x00000000001248e0 (4,000,006x)
         .             else
         .               return 0;
 8,000,012 ( 0.05%)  }
         .           
         .           static inline int
         .           __gthread_mutex_trylock (__gthread_mutex_t *__mutex)
         .           {
         .             if (__gthread_active_p ())
         .               return __gthrw_(pthread_mutex_trylock) (__mutex);
         .             else
         .               return 0;
-- line 760 ----------------------------------------
-- line 769 ----------------------------------------
         .               return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);
         .             else
         .               return 0;
         .           }
         .           #endif
         .           
         .           static inline int
         .           __gthread_mutex_unlock (__gthread_mutex_t *__mutex)
16,000,024 ( 0.10%)  {
20,000,030 ( 0.13%)    if (__gthread_active_p ())
36,000,054 ( 0.23%)  => /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_active_p() (4,000,006x)
16,000,024 ( 0.10%)      return __gthrw_(pthread_mutex_unlock) (__mutex);
84,000,210 ( 0.54%)  => ???:0x00000000001246b0 (4,000,006x)
         .             else
         .               return 0;
 8,000,012 ( 0.05%)  }
         .           
         .           #if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
         .             || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
         .           static inline int
         .           __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
         .           {
         .             if (__gthread_active_p ())
         .               {
-- line 790 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/include/Timestamp.h
--------------------------------------------------------------------------------
Ir                  

-- line 15 ----------------------------------------
         .           #include <ctime>
         .           #include <string>
         .           
         .           namespace TinyLog {
         .           
         .           class Timestamp {
         .           public:
         .             Timestamp() : milliSecondsSinceEpoch_(0) {}
20,000,000 ( 0.13%)    explicit Timestamp(int64_t _milliSecondsSinceEpoch)
24,000,000 ( 0.15%)        : milliSecondsSinceEpoch_(_milliSecondsSinceEpoch) {}
         .           
         .             /* Unix 时间戳 */
         .             static Timestamp now();
         .           
         .             /* 格式化时间: 使用localtime_r保证线程安全 */
         .             std::string toString();
         .           
         .             /* 获取毫秒 */
32,000,000 ( 0.20%)    int64_t getMilliSeconds() { return milliSecondsSinceEpoch_; }
         .           
         .             /* 获取秒 */
16,000,000 ( 0.10%)    time_t getSeconds() {
 8,000,000 ( 0.05%)      return static_cast<time_t>(milliSecondsSinceEpoch_ /
32,000,000 ( 0.20%)                                 kmilliSecondsPerSecond);
 8,000,000 ( 0.05%)    }
         .           
         .             /* 时间戳类的静态数据成员 */
         .             static constexpr int kmilliSecondsPerSecond = 1000;
         .           
         .           private:
         .             /* 毫秒级别的精度*/
         .             int64_t milliSecondsSinceEpoch_;
         .           };
-- line 47 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: main.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 9 ----------------------------------------
         .           #include <mutex>
         .           #include <sys/syscall.h>
         .           #include <thread>
         .           #include <unistd.h>
         .           #include <vector>
         .           
         .           using namespace std;
         .           
        80 ( 0.00%)  void func() {
 3,200,024 ( 0.02%)      for (int i = 0; i < 1e5; i++) {
 1,600,000 ( 0.01%)          auto curId = TinyLog::ThreadInfo::getTid();
 7,206,560 ( 0.05%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getTid() (800,000x)
33,600,000 ( 0.22%)          LOG_TRACE("TRACE hello world, current thread id  = %d\n", curId);
2,885,136,163 (18.48%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) (800,000x)
129,600,000 ( 0.83%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) (1,600,000x)
40,800,000 ( 0.26%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) (800,000x)
15,201,679 ( 0.10%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() (800,000x)
12,800,000 ( 0.08%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size() (1,600,000x)
 6,400,000 ( 0.04%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data() (800,000x)
 4,800,000 ( 0.03%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getLogLevel() (800,000x)
33,600,000 ( 0.22%)          LOG_DEBUG("DEBUG hello world, current thread id  = %d\n", curId);
2,885,055,044 (18.48%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) (800,000x)
129,600,000 ( 0.83%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) (1,600,000x)
39,200,000 ( 0.25%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) (800,000x)
15,200,000 ( 0.10%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() (800,000x)
12,800,000 ( 0.08%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size() (1,600,000x)
 6,400,000 ( 0.04%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data() (800,000x)
 4,800,000 ( 0.03%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getLogLevel() (800,000x)
29,600,000 ( 0.19%)          LOG_INFO("INFO hello world, current thread id = %d\n", curId);
2,881,827,292 (18.46%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) (800,000x)
129,600,000 ( 0.83%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) (1,600,000x)
39,200,000 ( 0.25%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) (800,000x)
15,200,000 ( 0.10%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() (800,000x)
12,800,000 ( 0.08%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size() (1,600,000x)
 6,400,000 ( 0.04%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data() (800,000x)
29,600,000 ( 0.19%)          LOG_WARN("WARN hello world, current thread id  = %d\n", curId);
2,881,850,382 (18.46%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) (800,000x)
129,600,000 ( 0.83%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) (1,600,000x)
36,000,000 ( 0.23%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) (800,000x)
15,200,000 ( 0.10%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() (800,000x)
12,800,000 ( 0.08%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size() (1,600,000x)
 6,400,000 ( 0.04%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data() (800,000x)
29,600,000 ( 0.19%)          LOG_ERROR("ERROR hello world, current thread id  = %d\n", curId);
2,885,098,602 (18.48%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::append(char const*, unsigned long, char const*, unsigned long, char const*, TinyLog::Logger::LogLevel, ...) (800,000x)
129,600,000 ( 0.83%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<46ul>(char const (&) [46ul]) (1,600,000x)
36,000,000 ( 0.23%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::str_const<3ul>(char const (&) [3ul]) (800,000x)
15,200,000 ( 0.10%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::getInstance() (800,000x)
12,800,000 ( 0.08%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::size() (1,600,000x)
 6,400,000 ( 0.04%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Logging.h:TinyLog::str_const::data() (800,000x)
         .               }
        80 ( 0.00%)  }
         .           
         4 ( 0.00%)  unique_ptr<TinyLog::AsynLog> asynLog;
        74 ( 0.00%)  => ???:0x0000000000124700 (1x)
         .           
         .           /* 异步日志输出 */
24,000,000 ( 0.15%)  void asynOutput(const char *_msg, size_t _len) {
32,000,000 ( 0.20%)      asynLog->append(_msg, _len);
2,032,517,977 (13.02%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::append(char const*, unsigned long) (4,000,000x)
272,000,000 ( 1.74%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::operator->() const (4,000,000x)
12,000,000 ( 0.08%)  }
         .           
         .           void setLogger() {
         .               TinyLog::Logger::setOutput(asynOutput);
         .               /* 128 MB */
         .               int RollSize = 128 * 1024 * 1024;
         .               TinyLog::FileWriterType writerType = TinyLog::NORMALFileWriter;
         .               asynLog =
         .                   make_unique<TinyLog::AsynLog>("main.cpp", RollSize, 3, 4, writerType);
         .               asynLog->start();
         .           }
         .           
         8 ( 0.00%)  void setLoggerByConfig() {
         .               /* 设置日志等级和日志文件相关的设置 */
         6 ( 0.00%)      TinyLog::LogConfig config;
       120 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/LogConfig.h:TinyLog::LogConfig::~LogConfig() (1x)
        43 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/LogConfig.h:TinyLog::LogConfig::LogConfig() (1x)
         1 ( 0.00%)      config.logLevel = TinyLog::Logger::TRACE;
         5 ( 0.00%)      config.fileOption.baseName = "main.cpp-AsynLog";
     5,991 ( 0.00%)  => ???:0x0000000000124860 (1x)
         1 ( 0.00%)      config.fileOption.fileWriter = TinyLog::NORMALFileWriter;
         .               /* 500MB */
         1 ( 0.00%)      config.fileOption.rooSize = static_cast<size_t>(500 * 1024) * 1024;
         .           
         3 ( 0.00%)      TinyLog::Logger::setConfig(config);
     1,473 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::setConfig(TinyLog::LogConfig const&) (1x)
         .           
         .               /* 设置输出 */
        10 ( 0.00%)      TinyLog::Logger::setOutput(asynOutput);
       556 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/Logging.cpp:TinyLog::Logger::setOutput(std::function<void (char const*, unsigned long)>) (1x)
       134 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::function<void (*)(char const*, unsigned long), void, void>(void (*)(char const*, unsigned long)) (1x)
        23 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::~function() (1x)
         .           
         .               asynLog =
        10 ( 0.00%)          make_unique<TinyLog::AsynLog>();
     4,839 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::_MakeUniq<TinyLog::AsynLog>::__single_object std::make_unique<TinyLog::AsynLog>() (1x)
       390 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::operator=(std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >&&) (1x)
        68 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::~unique_ptr() (1x)
         4 ( 0.00%)      asynLog->start();
     9,704 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/AsynLog.h:TinyLog::AsynLog::start() (1x)
        68 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::operator->() const (1x)
         8 ( 0.00%)  }
         .           
         4 ( 0.00%)  unique_ptr<TinyLog::SynLog> synLog;
        74 ( 0.00%)  => ???:0x0000000000124700 (1x)
         .           
         .           /* 同步日志输出 */
         .           void synOutput(const char *_msg, size_t _len) {
         .               synLog->append(_msg, _len);
         .           }
         .           
         .           void SynLogger() {
         .               /* 设置日志等级和日志文件相关的设置 */
-- line 72 ----------------------------------------
-- line 78 ----------------------------------------
         .               config.fileOption.rooSize = static_cast<size_t>(500 * 1024) * 1024;
         .               TinyLog::Logger::setConfig(config);
         .               /* 设置输出 */
         .               TinyLog::Logger::setOutput(synOutput);
         .           
         .               synLog = make_unique<TinyLog::SynLog>();
         .           }
         .           
        10 ( 0.00%)  int main(int, char **) {
         2 ( 0.00%)      auto start_time = chrono::system_clock::now();
       979 ( 0.00%)  => ???:0x0000000000124540 (1x)
         .               // setLogger();
         1 ( 0.00%)      setLoggerByConfig();
    23,466 ( 0.00%)  => main.cpp:setLoggerByConfig() (1x)
         .               // SynLogger();
         .           
        15 ( 0.00%)      std::vector<std::thread> threads(8);
     1,094 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::vector(unsigned long, std::allocator<std::thread> const&) (1x)
       923 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::~vector() (1x)
        18 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::thread>::~allocator() (1x)
        18 ( 0.00%)  => /usr/include/c++/9/bits/allocator.h:std::allocator<std::thread>::allocator() (1x)
         .           
       137 ( 0.00%)      for (auto &t : threads)
       315 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:bool __gnu_cxx::operator!=<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >(__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > > const&, __gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > > const&) (9x)
        96 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >::operator++() (8x)
        64 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >::operator*() const (8x)
        32 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::end() (1x)
        31 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::begin() (1x)
        96 ( 0.00%)          t = std::thread(func);
    14,686 ( 0.00%)  => /usr/include/c++/9/thread:std::thread::thread<void (&)(), , void>(void (&)()) (8x)
     1,024 ( 0.00%)  => /usr/include/c++/9/thread:std::thread::operator=(std::thread&&) (8x)
       440 ( 0.00%)  => /usr/include/c++/9/thread:std::thread::~thread() (8x)
         .           
       137 ( 0.00%)      for (auto &t : threads)
       315 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:bool __gnu_cxx::operator!=<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >(__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > > const&, __gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > > const&) (9x)
        96 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >::operator++() (8x)
        64 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >::operator*() const (8x)
        32 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::end() (1x)
        31 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::thread, std::allocator<std::thread> >::begin() (1x)
        24 ( 0.00%)          t.join();
     5,906 ( 0.00%)  => ???:0x0000000000124970 (8x)
         .           
         2 ( 0.00%)      auto end_time = chrono::system_clock::now();
        40 ( 0.00%)  => ???:0x0000000000124540 (1x)
        10 ( 0.00%)      chrono::milliseconds cost_time = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);
       110 ( 0.00%)  => /usr/include/c++/9/chrono:std::common_type<std::chrono::duration<long, std::ratio<1l, 1000000000l> >, std::chrono::duration<long, std::ratio<1l, 1000000000l> > >::type std::chrono::operator-<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> >, std::chrono::duration<long, std::ratio<1l, 1000000000l> > >(std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > > const&, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > > const&) (1x)
        62 ( 0.00%)  => /usr/include/c++/9/chrono:std::enable_if<std::chrono::__is_duration<std::chrono::duration<long, std::ratio<1l, 1000l> > >::value, std::chrono::duration<long, std::ratio<1l, 1000l> > >::type std::chrono::duration_cast<std::chrono::duration<long, std::ratio<1l, 1000l> >, long, std::ratio<1l, 1000000000l> >(std::chrono::duration<long, std::ratio<1l, 1000000000l> > const&) (1x)
         .           
        15 ( 0.00%)      std::cout << "cost time = " << cost_time.count() << endl;
     5,346 ( 0.00%)  => ???:0x00000000001249c0 (1x)
     4,943 ( 0.00%)  => ???:0x0000000000124760 (1x)
     3,354 ( 0.00%)  => ???:0x00000000001247a0 (1x)
         8 ( 0.00%)  => /usr/include/c++/9/chrono:std::chrono::duration<long, std::ratio<1l, 1000l> >::count() const (1x)
         1 ( 0.00%)      return 0;
        28 ( 0.00%)  }
   106,891 ( 0.00%)  => main.cpp:__static_initialization_and_destruction_0(int, int) (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/std_function.h
--------------------------------------------------------------------------------
Ir                  

-- line 79 ----------------------------------------
         .               void*       _M_object;
         .               const void* _M_const_object;
         .               void (*_M_function_pointer)();
         .               void (_Undefined_class::*_M_member_pointer)();
         .             };
         .           
         .             union [[gnu::may_alias]] _Any_data
         .             {
        42 ( 0.00%)      void*       _M_access()       { return &_M_pod_data[0]; }
28,000,000 ( 0.18%)      const void* _M_access() const { return &_M_pod_data[0]; }
         .           
         .               template<typename _Tp>
         .                 _Tp&
        15 ( 0.00%)        _M_access()
        15 ( 0.00%)        { return *static_cast<_Tp*>(_M_access()); }
         7 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Any_data::_M_access() (1x)
         .           
         .               template<typename _Tp>
         .                 const _Tp&
20,000,000 ( 0.13%)        _M_access() const
20,000,000 ( 0.13%)        { return *static_cast<const _Tp*>(_M_access()); }
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/std_function.h:std::_Any_data::_M_access() const (4,000,000x)
         .           
         .               _Nocopy_types _M_unused;
         .               char _M_pod_data[sizeof(_Nocopy_types)];
         .             };
         .           
         .             enum _Manager_operation
         .             {
         .               __get_type_info,
-- line 106 ----------------------------------------
-- line 143 ----------------------------------------
         .           	 && sizeof(_Functor) <= _M_max_size
         .           	 && __alignof__(_Functor) <= _M_max_align
         .           	 && (_M_max_align % __alignof__(_Functor) == 0));
         .           
         .           	typedef integral_constant<bool, __stored_locally> _Local_storage;
         .           
         .           	// Retrieve a pointer to the function object
         .           	static _Functor*
20,000,000 ( 0.13%)  	_M_get_pointer(const _Any_data& __source)
         .           	{
         .           	  if _GLIBCXX17_CONSTEXPR (__stored_locally)
         .           	    {
16,000,000 ( 0.10%)  	      const _Functor& __f = __source._M_access<_Functor>();
68,000,000 ( 0.44%)  => /usr/include/c++/9/bits/std_function.h:void (* const&std::_Any_data::_M_access<void (*)(char const*, unsigned long)>() const)(char const*, unsigned long) (4,000,000x)
16,000,000 ( 0.10%)  	      return const_cast<_Functor*>(std::__addressof(__f));
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/move.h:void (* const*std::__addressof<void (* const)(char const*, unsigned long)>(void (* const&)(char const*, unsigned long)))(char const*, unsigned long) (4,000,000x)
         .           	    }
         .           	  else // have stored a pointer
         .           	    return __source._M_access<_Functor*>();
 8,000,000 ( 0.05%)  	}
         .           
         .           	// Clone a location-invariant function object that fits within
         .           	// an _Any_data structure.
         .           	static void
         .           	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
         .           	{
         .           	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
         .           	}
-- line 168 ----------------------------------------
-- line 174 ----------------------------------------
         .           	{
         .           	  __dest._M_access<_Functor*>() =
         .           	    new _Functor(*__source._M_access<const _Functor*>());
         .           	}
         .           
         .           	// Destroying a location-invariant object may still require
         .           	// destruction.
         .           	static void
        15 ( 0.00%)  	_M_destroy(_Any_data& __victim, true_type)
         .           	{
         9 ( 0.00%)  	  __victim._M_access<_Functor>().~_Functor();
        34 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:void (*&std::_Any_data::_M_access<void (*)(char const*, unsigned long)>())(char const*, unsigned long) (2x)
         9 ( 0.00%)  	}
         .           
         .           	// Destroying an object located on the heap.
         .           	static void
         .           	_M_destroy(_Any_data& __victim, false_type)
         .           	{
         .           	  delete __victim._M_access<_Functor*>();
         .           	}
         .           
         .                 public:
         .           	static bool
        33 ( 0.00%)  	_M_manager(_Any_data& __dest, const _Any_data& __source,
         .           		   _Manager_operation __op)
         .           	{
         9 ( 0.00%)  	  switch (__op)
         .           	    {
         .           #if __cpp_rtti
         .           	    case __get_type_info:
         .           	      __dest._M_access<const type_info*>() = &typeid(_Functor);
         .           	      break;
         .           #endif
         .           	    case __get_functor_ptr:
         .           	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
         .           	      break;
         .           
         .           	    case __clone_functor:
         .           	      _M_clone(__dest, __source, _Local_storage());
         .           	      break;
         .           
         .           	    case __destroy_functor:
         9 ( 0.00%)  	      _M_destroy(__dest, _Local_storage());
        56 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_destroy(std::_Any_data&, std::integral_constant<bool, true>) (2x)
         3 ( 0.00%)  	      break;
         .           	    }
         3 ( 0.00%)  	  return false;
        21 ( 0.00%)  	}
         .           
         .           	static void
        27 ( 0.00%)  	_M_init_functor(_Any_data& __functor, _Functor&& __f)
        42 ( 0.00%)  	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
        45 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)()>::_M_init_functor(std::_Any_data&, void (*&&)(), std::integral_constant<bool, true>) (1x)
         7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<void (*&)()>::type&& std::move<void (*&)()>(void (*&)()) (1x)
         .           
         .           	template<typename _Signature>
         .           	  static bool
         .           	  _M_not_empty_function(const function<_Signature>& __f)
         .           	  { return static_cast<bool>(__f); }
         .           
         .           	template<typename _Tp>
         .           	  static bool
        12 ( 0.00%)  	  _M_not_empty_function(_Tp* __fp)
        12 ( 0.00%)  	  { return __fp != nullptr; }
         .           
         .           	template<typename _Class, typename _Tp>
         .           	  static bool
         .           	  _M_not_empty_function(_Tp _Class::* __mp)
         .           	  { return __mp != nullptr; }
         .           
         .           	template<typename _Tp>
         .           	  static bool
         .           	  _M_not_empty_function(const _Tp&)
         .           	  { return true; }
         .           
         .                 private:
         .           	static void
        21 ( 0.00%)  	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
        48 ( 0.00%)  	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
         8 ( 0.00%)  => /usr/include/c++/9/new:operator new(unsigned long, void*) (1x)
         7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<void (*&)()>::type&& std::move<void (*&)()>(void (*&)()) (1x)
         7 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Any_data::_M_access() (1x)
         .           
         .           	static void
         .           	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
         .           	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
         .                 };
         .           
        36 ( 0.00%)      _Function_base() : _M_manager(nullptr) { }
         .           
        20 ( 0.00%)      ~_Function_base()
         .               {
        16 ( 0.00%)        if (_M_manager)
        24 ( 0.00%)  	_M_manager(_M_functor, _M_functor, __destroy_functor);
       108 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (2x)
        54 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)()>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (1x)
        12 ( 0.00%)      }
         .           
80,000,000 ( 0.51%)      bool _M_empty() const { return !_M_manager; }
         .           
         .               typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
         .           				  _Manager_operation);
         .           
         .               _Any_data     _M_functor;
         .               _Manager_type _M_manager;
         .             };
         .           
-- line 271 ----------------------------------------
-- line 290 ----------------------------------------
         .             template<typename _Functor, typename... _ArgTypes>
         .               class _Function_handler<void(_ArgTypes...), _Functor>
         .               : public _Function_base::_Base_manager<_Functor>
         .               {
         .                 typedef _Function_base::_Base_manager<_Functor> _Base;
         .           
         .                public:
         .                 static void
36,000,000 ( 0.23%)        _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
         .                 {
36,000,000 ( 0.23%)  	(*_Base::_M_get_pointer(__functor))(
2,372,517,977 (15.20%)  => /home1/jsj/Code/cpp/projects/AsynLog/main.cpp:asynOutput(char const*, unsigned long) (4,000,000x)
156,000,000 ( 1.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_get_pointer(std::_Any_data const&) (4,000,000x)
24,000,000 ( 0.15%)  	    std::forward<_ArgTypes>(__args)...);
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/move.h:char const*&& std::forward<char const*>(std::remove_reference<char const*>::type&) (4,000,000x)
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/move.h:unsigned long&& std::forward<unsigned long>(std::remove_reference<unsigned long>::type&) (4,000,000x)
24,000,000 ( 0.15%)        }
         .               };
         .           
         .             template<typename _Class, typename _Member, typename _Res,
         .           	   typename... _ArgTypes>
         .               class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
         .               : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
         .               {
         .                 typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
-- line 310 ----------------------------------------
-- line 361 ----------------------------------------
         .           
         .             /**
         .              *  @brief Primary class template for std::function.
         .              *  @ingroup functors
         .              *
         .              *  Polymorphic function wrapper.
         .              */
         .             template<typename _Res, typename... _ArgTypes>
        44 ( 0.00%)      class function<_Res(_ArgTypes...)>
        74 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::~_Function_base() (1x)
         .               : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
         .                 private _Function_base
         .               {
         .                 template<typename _Func,
         .           	       typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
         .           	struct _Callable
         .           	: __is_invocable_impl<_Res2, _Res>::type
         .           	{ };
-- line 377 ----------------------------------------
-- line 415 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief %Function move constructor.
         .                  *  @param __x A %function object rvalue with identical call signature.
         .                  *
         .                  *  The newly-created %function contains the target of @a __x
         .                  *  (if it has one).
         .                  */
         9 ( 0.00%)        function(function&& __x) noexcept : _Function_base()
         9 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Function_base() (1x)
         .                 {
         5 ( 0.00%)  	__x.swap(*this);
       193 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::swap(std::function<void (char const*, unsigned long)>&) (1x)
         3 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief Builds a %function that targets a copy of the incoming
         .                  *  function object.
         .                  *  @param __f A %function object that is callable with parameters of
         .                  *  type @c T1, @c T2, ..., @c TN and returns a value convertible
         .                  *  to @c Res.
         .                  *
-- line 434 ----------------------------------------
-- line 472 ----------------------------------------
         .                  *
         .                  *  The target of @a __x is moved to @c *this. If @a __x has no
         .                  *  target, then @c *this will be empty.
         .                  *
         .                  *  If @a __x targets a function pointer or a reference to a function
         .                  *  object, then this operation will not throw an %exception.
         .                  */
         .                 function&
         9 ( 0.00%)        operator=(function&& __x) noexcept
         .                 {
        16 ( 0.00%)  	function(std::move(__x)).swap(*this);
       219 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::function(std::function<void (char const*, unsigned long)>&&) (1x)
       193 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::swap(std::function<void (char const*, unsigned long)>&) (1x)
        85 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::function<void (char const*, unsigned long)>::~function() (1x)
         7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<std::function<void (char const*, unsigned long)>&>::type&& std::move<std::function<void (char const*, unsigned long)>&>(std::function<void (char const*, unsigned long)>&) (1x)
         1 ( 0.00%)  	return *this;
         5 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief %Function assignment to zero.
         .                  *  @post @c !(bool)*this
         .                  *  @returns @c *this
         .                  *
         .                  *  The target of @c *this is deallocated, leaving it empty.
         .                  */
-- line 492 ----------------------------------------
-- line 539 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief Swap the targets of two %function objects.
         .                  *  @param __x A %function with identical call signature.
         .                  *
         .                  *  Swap the targets of @c this function object and @a __f. This
         .                  *  function will not throw an %exception.
         .                  */
        12 ( 0.00%)        void swap(function& __x) noexcept
         .                 {
        10 ( 0.00%)  	std::swap(_M_functor, __x._M_functor);
       118 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::_Any_data> >, std::is_move_constructible<std::_Any_data>, std::is_move_assignable<std::_Any_data> >::value, void>::type std::swap<std::_Any_data>(std::_Any_data&, std::_Any_data&) (2x)
        14 ( 0.00%)  	std::swap(_M_manager, __x._M_manager);
       106 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)> >, std::is_move_constructible<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)>, std::is_move_assignable<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)> >::value, void>::type std::swap<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)>(bool (*&)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation), bool (*&)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)) (2x)
        14 ( 0.00%)  	std::swap(_M_invoker, __x._M_invoker);
       106 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<void (*)(std::_Any_data const&, char const*&&, unsigned long&&)> >, std::is_move_constructible<void (*)(std::_Any_data const&, char const*&&, unsigned long&&)>, std::is_move_assignable<void (*)(std::_Any_data const&, char const*&&, unsigned long&&)> >::value, void>::type std::swap<void (*)(std::_Any_data const&, char const*&&, unsigned long&&)>(void (*&)(std::_Any_data const&, char const*&&, unsigned long&&), void (*&)(std::_Any_data const&, char const*&&, unsigned long&&)) (2x)
         6 ( 0.00%)        }
         .           
         .                 // [3.7.2.3] function capacity
         .           
         .                 /**
         .                  *  @brief Determine if the %function wrapper has a target.
         .                  *
         .                  *  @return @c true when this %function object contains a target,
         .                  *  or @c false when it is empty.
         .                  *
         .                  *  This function will not throw an %exception.
         .                  */
20,000,000 ( 0.13%)        explicit operator bool() const noexcept
24,000,000 ( 0.15%)        { return !_M_empty(); }
40,000,000 ( 0.26%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_M_empty() const (4,000,000x)
         .           
         .                 // [3.7.2.4] function invocation
         .           
         .                 /**
         .                  *  @brief Invokes the function targeted by @c *this.
         .                  *  @returns the result of the target.
         .                  *  @throws bad_function_call when @c !(bool)*this
         .                  *
-- line 573 ----------------------------------------
-- line 659 ----------------------------------------
         .           	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
         .           	  _M_invoker = __x._M_invoker;
         .           	  _M_manager = __x._M_manager;
         .           	}
         .               }
         .           
         .             template<typename _Res, typename... _ArgTypes>
         .               template<typename _Functor, typename, typename>
        21 ( 0.00%)        function<_Res(_ArgTypes...)>::
         .                 function(_Functor __f)
         9 ( 0.00%)        : _Function_base()
        18 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Function_base() (2x)
         .                 {
         .           	typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;
         .           
        15 ( 0.00%)  	if (_My_handler::_M_not_empty_function(__f))
        16 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:bool std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_not_empty_function<void (char const*, unsigned long)>(void (*)(char const*, unsigned long)) (2x)
         .           	  {
        24 ( 0.00%)  	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
       150 ( 0.00%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_Base_manager<void (*)(char const*, unsigned long)>::_M_init_functor(std::_Any_data&, void (*&&)(char const*, unsigned long)) (2x)
        14 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<void (*&)(char const*, unsigned long)>::type&& std::move<void (*&)(char const*, unsigned long)>(void (*&)(char const*, unsigned long)) (2x)
         9 ( 0.00%)  	    _M_invoker = &_My_handler::_M_invoke;
         9 ( 0.00%)  	    _M_manager = &_My_handler::_M_manager;
         .           	  }
        18 ( 0.00%)        }
         .           
         .             template<typename _Res, typename... _ArgTypes>
         .               _Res
36,000,000 ( 0.23%)      function<_Res(_ArgTypes...)>::
         .               operator()(_ArgTypes... __args) const
         .               {
20,000,000 ( 0.13%)        if (_M_empty())
40,000,000 ( 0.26%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_base::_M_empty() const (4,000,000x)
         .           	__throw_bad_function_call();
64,000,000 ( 0.41%)        return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
2,704,517,977 (17.32%)  => /usr/include/c++/9/bits/std_function.h:std::_Function_handler<void (char const*, unsigned long), void (*)(char const*, unsigned long)>::_M_invoke(std::_Any_data const&, char const*&&, unsigned long&&) (4,000,000x)
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/move.h:char const*&& std::forward<char const*>(std::remove_reference<char const*>::type&) (4,000,000x)
28,000,000 ( 0.18%)  => /usr/include/c++/9/bits/move.h:unsigned long&& std::forward<unsigned long>(std::remove_reference<unsigned long>::type&) (4,000,000x)
20,000,000 ( 0.13%)      }
         .           
         .           #if __cpp_rtti
         .             template<typename _Res, typename... _ArgTypes>
         .               const type_info&
         .               function<_Res(_ArgTypes...)>::
         .               target_type() const noexcept
         .               {
         .                 if (_M_manager)
-- line 697 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/include/Buffer.h
--------------------------------------------------------------------------------
Ir                   

-- line 20 ----------------------------------------
          .           
          .           /* 日志记录行缓冲区大小: 1Kb*/
          .           const int kLineBuff = 1024;
          .           /* 异步日志单个缓冲区大小: 4Mb */
          .           const int kBuffSize = 4 * 1024 * 1024;
          .           
          .           template <size_t SIZE> class FixedBuffer : noncopyable {
          .           public:
      1,035 ( 0.00%)    FixedBuffer() : _cur(0) {}
          .           
          .             ~FixedBuffer() = default;
          .           
 32,000,128 ( 0.20%)    size_t size() const { return _cur; }
          .           
 16,000,424 ( 0.10%)    void clear() {
  8,000,212 ( 0.05%)      _cur = 0;
          .               // TODO: do we need this operation ?
          .               // memset(_data, 0, sizeof(_data));?
 12,000,318 ( 0.08%)    }
          .           
572,000,000 ( 3.66%)    size_t avail() const { return SIZE - _cur; }
          .           
 28,000,112 ( 0.18%)    const char *data() const { return _data; }
          .           
          .             /* 从外部直接写入内容到buffer中 */
 40,000,000 ( 0.26%)    char *current() { return _data + _cur; }
          .           
 56,000,000 ( 0.36%)    void addLen(size_t len) { _cur += len; }
          .           
308,000,000 ( 1.97%)    void append(const char *_msg, size_t _len) {
308,000,000 ( 1.97%)      if (avail() > _len) {
 44,000,000 ( 0.28%)  => TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::avail() const (4,000,000x)
396,000,000 ( 2.54%)        memcpy(_data + _cur, _msg, _len);
 96,000,000 ( 0.61%)  => ???:0x00000000001246e0 (4,000,000x)
264,000,000 ( 1.69%)        _cur += _len;
          .               }
132,000,000 ( 0.85%)    }
          .           
          .           private:
          .             char _data[SIZE]; /* 缓冲区 */
          .             size_t _cur;      /* 第一个可写入位置 */
          .           };
          .           
          .           } // namespace TinyLog::LogBuffer
          .           
-- line 62 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/unique_ptr.h
--------------------------------------------------------------------------------
Ir                   

-- line 63 ----------------------------------------
          .           
          .                 /** @brief Converting constructor.
          .                  *
          .                  * Allows conversion from a deleter for arrays of another type, @p _Up,
          .                  * only if @p _Up* is convertible to @p _Tp*.
          .                  */
          .                 template<typename _Up, typename = typename
          .           	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
          8 ( 0.00%)          default_delete(const default_delete<_Up>&) noexcept { }
          .           
          .                 /// Calls @c delete @p __ptr
          .                 void
        655 ( 0.00%)        operator()(_Tp* __ptr) const
          .                 {
          .           	static_assert(!is_void<_Tp>::value,
          .           		      "can't delete pointer to incomplete type");
          .           	static_assert(sizeof(_Tp)>0,
          .           		      "can't delete pointer to incomplete type");
        658 ( 0.00%)  	delete __ptr;
        752 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/FileWriter.cpp:TinyLog::NormalFileWriter::~NormalFileWriter() (1x)
        329 ( 0.00%)        }
          .               };
          .           
          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .             // DR 740 - omit specialization for array objects with a compile time length
          .             /// Specialization for arrays, default_delete.
          .             template<typename _Tp>
          .               struct default_delete<_Tp[]>
          .               {
-- line 90 ----------------------------------------
-- line 138 ----------------------------------------
          .           	       is_default_constructible<_Dp>>::value>;
          .           
          .                 using pointer = typename _Ptr<_Tp, _Dp>::type;
          .           
          .                 static_assert( !is_rvalue_reference<_Dp>::value,
          .           		     "unique_ptr's deleter type must be a function object type"
          .           		     " or an lvalue reference type" );
          .           
      1,210 ( 0.00%)        __uniq_ptr_impl() = default;
      5,668 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::tuple<TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> >, true>() (109x)
      2,330 ( 0.00%)        __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
         52 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog>, true>() (1x)
         47 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::_M_ptr() (1x)
          .           
          .                 template<typename _Del>
          .                 __uniq_ptr_impl(pointer __p, _Del&& __d)
          .           	: _M_t(__p, std::forward<_Del>(__d)) { }
          .           
      5,660 ( 0.00%)        pointer&   _M_ptr() { return std::get<0>(_M_t); }
        185 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > >::type& std::get<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >&) (5x)
132,003,102 ( 0.85%)        pointer    _M_ptr() const { return std::get<0>(_M_t); }
         37 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple_element<0ul, std::tuple<TinyLog::NormalFileWriter*, std::default_delete<TinyLog::NormalFileWriter> > >::type const& std::get<0ul, TinyLog::NormalFileWriter*, std::default_delete<TinyLog::NormalFileWriter> >(std::tuple<TinyLog::NormalFileWriter*, std::default_delete<TinyLog::NormalFileWriter> > const&) (1x)
      3,270 ( 0.00%)        _Dp&       _M_deleter() { return std::get<1>(_M_t); }
        111 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple_element<1ul, std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > >::type& std::get<1ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::tuple<TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >&) (3x)
          .                 const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
          .           
          .                 void
          .                 swap(__uniq_ptr_impl& __rhs) noexcept
          .                 {
          .           	using std::swap;
          .           	swap(this->_M_ptr(), __rhs._M_ptr());
          .           	swap(this->_M_deleter(), __rhs._M_deleter());
-- line 163 ----------------------------------------
-- line 191 ----------------------------------------
          .           	  __not_<is_array<_Up>>
          .                   >;
          .           
          .               public:
          .                 // Constructors.
          .           
          .                 /// Default constructor, creates a unique_ptr that owns nothing.
          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
          5 ( 0.00%)  	constexpr unique_ptr() noexcept
          5 ( 0.00%)  	: _M_t()
         63 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::FileWriter, std::default_delete<TinyLog::FileWriter> >::__uniq_ptr_impl() (1x)
          3 ( 0.00%)  	{ }
          .           
          .                 /** Takes ownership of a pointer.
          .                  *
          .                  * @param __p  A pointer to an object of @c element_type
          .                  *
          .                  * The deleter will be value-initialized.
          .                  */
          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
          .           	explicit
        708 ( 0.00%)  	unique_ptr(pointer __p) noexcept
        590 ( 0.00%)  	: _M_t(__p)
        116 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::__uniq_ptr_impl(TinyLog::AsynLog*) (1x)
        354 ( 0.00%)          { }
          .           
          .                 /** Takes ownership of a pointer.
          .                  *
          .                  * @param __p  A pointer to an object of @c element_type
          .                  * @param __d  A reference to a deleter.
          .                  *
          .                  * The deleter will be initialized with @p __d
          .                  */
-- line 221 ----------------------------------------
-- line 242 ----------------------------------------
          .                 template<typename _Del = deleter_type,
          .           	       typename _DelUnref = typename remove_reference<_Del>::type>
          .           	unique_ptr(pointer,
          .           		   __enable_if_t<is_lvalue_reference<_Del>::value,
          .           				 _DelUnref&&>) = delete;
          .           
          .                 /// Creates a unique_ptr that owns nothing.
          .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
        654 ( 0.00%)  	constexpr unique_ptr(nullptr_t) noexcept
        545 ( 0.00%)  	: _M_t()
      6,867 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::__uniq_ptr_impl() (109x)
        327 ( 0.00%)  	{ }
          .           
          .                 // Move constructors.
          .           
          .                 /// Move constructor.
          .                 unique_ptr(unique_ptr&& __u) noexcept
          .                 : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
          .           
          .                 /** @brief Converting constructor from another type
-- line 260 ----------------------------------------
-- line 278 ----------------------------------------
          .                 /// Converting constructor from @c auto_ptr
          .                 template<typename _Up, typename = _Require<
          .           	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
          .           	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
          .           #pragma GCC diagnostic pop
          .           #endif
          .           
          .                 /// Destructor, invokes the deleter if the stored pointer is not null.
      1,380 ( 0.00%)        ~unique_ptr() noexcept
          .                 {
          .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
          .           		      "unique_ptr's deleter must be invocable with a pointer");
        920 ( 0.00%)  	auto& __ptr = _M_t._M_ptr();
         47 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::SynLog, std::default_delete<TinyLog::SynLog> >::_M_ptr() (1x)
        920 ( 0.00%)  	if (__ptr != nullptr)
      1,199 ( 0.00%)  	  get_deleter()(std::move(__ptr));
     10,272 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> >::operator()(TinyLog::LogBuffer::FixedBuffer<4194304ul>*) const (107x)
      6,099 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::get_deleter() (107x)
        749 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>::type&& std::move<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>(TinyLog::LogBuffer::FixedBuffer<4194304ul>*&) (107x)
        460 ( 0.00%)  	__ptr = pointer();
      1,150 ( 0.00%)        }
          .           
          .                 // Assignment.
          .           
          .                 /** @brief Move assignment operator.
          .                  *
          .                  * @param __u  The object to transfer ownership from.
          .                  *
          .                  * Invokes the deleter first if this object owns a pointer.
          .                  */
          .                 unique_ptr&
        648 ( 0.00%)        operator=(unique_ptr&& __u) noexcept
          .                 {
        864 ( 0.00%)  	reset(__u.release());
        123 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::reset(TinyLog::AsynLog*) (1x)
        121 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::release() (1x)
        864 ( 0.00%)  	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
        114 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::get_deleter() (2x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::default_delete<TinyLog::AsynLog>&& std::forward<std::default_delete<TinyLog::AsynLog> >(std::remove_reference<std::default_delete<TinyLog::AsynLog> >::type&) (1x)
        108 ( 0.00%)  	return *this;
        216 ( 0.00%)        }
          .           
          .                 /** @brief Assignment from another type.
          .                  *
          .                  * @param __u  The object to transfer ownership from, which owns a
          .                  *             convertible pointer to a non-array object.
          .                  *
          .                  * Invokes the deleter first if this object owns a pointer.
          .                  */
          .                 template<typename _Up, typename _Ep>
          .                   typename enable_if< __and_<
          .                     __safe_conversion_up<_Up, _Ep>,
          .                     is_assignable<deleter_type&, _Ep&&>
          .                     >::value,
          .                     unique_ptr&>::type
          9 ( 0.00%)  	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
          .           	{
          8 ( 0.00%)  	  reset(__u.release());
        123 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::FileWriter, std::default_delete<TinyLog::FileWriter> >::reset(TinyLog::FileWriter*) (1x)
        121 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::NormalFileWriter, std::default_delete<TinyLog::NormalFileWriter> >::release() (1x)
         13 ( 0.00%)  	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
         57 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::NormalFileWriter, std::default_delete<TinyLog::NormalFileWriter> >::get_deleter() (1x)
         57 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::FileWriter, std::default_delete<TinyLog::FileWriter> >::get_deleter() (1x)
          8 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::default_delete<TinyLog::FileWriter>::default_delete<TinyLog::NormalFileWriter, void>(std::default_delete<TinyLog::NormalFileWriter> const&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::default_delete<TinyLog::NormalFileWriter>&& std::forward<std::default_delete<TinyLog::NormalFileWriter> >(std::remove_reference<std::default_delete<TinyLog::NormalFileWriter> >::type&) (1x)
          1 ( 0.00%)  	  return *this;
          5 ( 0.00%)  	}
          .           
          .                 /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
          .                 unique_ptr&
          .                 operator=(nullptr_t) noexcept
          .                 {
          .           	reset();
          .           	return *this;
          .                 }
-- line 338 ----------------------------------------
-- line 344 ----------------------------------------
          .                 operator*() const
          .                 {
          .           	__glibcxx_assert(get() != pointer());
          .           	return *get();
          .                 }
          .           
          .                 /// Return the stored pointer.
          .                 pointer
 60,000,865 ( 0.38%)        operator->() const noexcept
          .                 {
          .           	_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
 36,000,519 ( 0.23%)  	return get();
464,008,004 ( 2.97%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::get() const (8,000,138x)
 24,000,346 ( 0.15%)        }
          .           
          .                 /// Return the stored pointer.
          .                 pointer
 60,001,410 ( 0.38%)        get() const noexcept
 60,001,410 ( 0.38%)        { return _M_t._M_ptr(); }
384,011,760 ( 2.46%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_ptr() const (8,000,245x)
          .           
          .                 /// Return a reference to the stored deleter.
          .                 deleter_type&
      1,635 ( 0.00%)        get_deleter() noexcept
      1,635 ( 0.00%)        { return _M_t._M_deleter(); }
         94 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::FileWriter, std::default_delete<TinyLog::FileWriter> >::_M_deleter() (2x)
          .           
          .                 /// Return a reference to the stored deleter.
          .                 const deleter_type&
          .                 get_deleter() const noexcept
          .                 { return _M_t._M_deleter(); }
          .           
          .                 /// Return @c true if the stored pointer is not null.
          .                 explicit operator bool() const noexcept
          .                 { return get() == pointer() ? false : true; }
          .           
          .                 // Modifiers.
          .           
          .                 /// Release ownership of any stored pointer.
          .                 pointer
        545 ( 0.00%)        release() noexcept
          .                 {
        436 ( 0.00%)  	pointer __p = get();
         58 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::get() const (1x)
        436 ( 0.00%)  	_M_t._M_ptr() = pointer();
         47 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::_M_ptr() (1x)
        109 ( 0.00%)  	return __p;
        218 ( 0.00%)        }
          .           
          .                 /** @brief Replace the stored pointer.
          .                  *
          .                  * @param __p  The new pointer to store.
          .                  *
          .                  * The deleter will be invoked if a pointer is already owned.
          .                  */
          .                 void
        763 ( 0.00%)        reset(pointer __p = pointer()) noexcept
          .                 {
          .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
          .           		      "unique_ptr's deleter must be invocable with a pointer");
          .           	using std::swap;
        872 ( 0.00%)  	swap(_M_t._M_ptr(), __p);
         53 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<TinyLog::AsynLog*> >, std::is_move_constructible<TinyLog::AsynLog*>, std::is_move_assignable<TinyLog::AsynLog*> >::value, void>::type std::swap<TinyLog::AsynLog*>(TinyLog::AsynLog*&, TinyLog::AsynLog*&) (1x)
         47 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::__uniq_ptr_impl<TinyLog::AsynLog, std::default_delete<TinyLog::AsynLog> >::_M_ptr() (1x)
        327 ( 0.00%)  	if (__p != pointer())
          .           	  get_deleter()(std::move(__p));
        545 ( 0.00%)        }
          .           
          .                 /// Exchange the pointer and deleter with another object.
          .                 void
          .                 swap(unique_ptr& __u) noexcept
          .                 {
          .           	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
          .           	_M_t.swap(__u._M_t);
          .                 }
-- line 411 ----------------------------------------
-- line 848 ----------------------------------------
          .           
          .             template<typename _Tp, size_t _Bound>
          .               struct _MakeUniq<_Tp[_Bound]>
          .               { struct __invalid_type { }; };
          .           
          .             /// std::make_unique for single objects
          .             template<typename _Tp, typename... _Args>
          .               inline typename _MakeUniq<_Tp>::__single_object
        655 ( 0.00%)      make_unique(_Args&&... __args)
      1,542 ( 0.00%)      { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
     33,132 ( 0.00%)  => ???:0x0000000000124780 (107x)
     14,231 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::unique_ptr<std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> >, void>(TinyLog::LogBuffer::FixedBuffer<4194304ul>*) (107x)
        963 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::FixedBuffer() (107x)
          .           
          .             /// std::make_unique for arrays of unknown bound
          .             template<typename _Tp>
          .               inline typename _MakeUniq<_Tp>::__array
          .               make_unique(size_t __num)
          .               { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
          .           
          .             /// Disable std::make_unique for arrays of known bound
-- line 865 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/src/Asynlog.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 15 ----------------------------------------
         .           #include <chrono>
         .           #include <cstddef>
         .           #include <memory>
         .           #include <mutex>
         .           #include <type_traits>
         .           
         .           namespace TinyLog {
         .           
        14 ( 0.00%)  AsynLog::AsynLog(const std::string &_basename, size_t _rollSize,
         .                            int _flushInterval, int _bufferNums,
         .                            FileWriterType _writerType)
         .               : basename_(_basename), rollSize_(_rollSize),
         .                 flushInterval_(_flushInterval), started_(false), counter_(1),
         .                 bufferSize_(_bufferNums), writerType_(_writerType),
         .                 head(std::make_shared<BufferNode>()),
        55 ( 0.00%)        tail(std::make_shared<BufferNode>()) {
     2,092 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode> std::make_shared<TinyLog::AsynLog::BufferNode>() (2x)
     1,778 ( 0.00%)  => ???:0x00000000001245f0 (1x)
        67 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::vector() (1x)
        51 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/CountDownLatch.cpp:TinyLog::CountDownLatch::CountDownLatch(int) (1x)
        34 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr() (1x)
        27 ( 0.00%)  => /usr/include/c++/9/atomic:std::atomic<bool>::atomic(bool) (1x)
        24 ( 0.00%)  => /usr/include/c++/9/bits/std_mutex.h:std::mutex::mutex() (1x)
        20 ( 0.00%)  => /usr/include/c++/9/thread:std::thread::thread() (1x)
         8 ( 0.00%)  => ???:0x00000000001248a0 (1x)
         .             /* 初始化 head 和 tail 的指针域*/
        10 ( 0.00%)    head->next_ = tail;
       113 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
        28 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        10 ( 0.00%)    tail->prev_ = head;
       113 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
        28 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
         8 ( 0.00%)  }
         .           
        40 ( 0.00%)  AsynLog::~AsynLog() {
     2,425 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (3x)
     1,092 ( 0.00%)  => ???:0x00000000001249b0 (1x)
       320 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::~vector() (1x)
        97 ( 0.00%)  => ???:0x0000000000124660 (1x)
        55 ( 0.00%)  => /usr/include/c++/9/thread:std::thread::~thread() (1x)
        41 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/CountDownLatch.h:TinyLog::CountDownLatch::~CountDownLatch() (1x)
         6 ( 0.00%)    if (started_)
        29 ( 0.00%)  => /usr/include/c++/9/atomic:std::atomic<bool>::operator bool() const (1x)
         3 ( 0.00%)      stop();
       812 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/AsynLog.h:TinyLog::AsynLog::stop() (1x)
         .             /* 回收缓冲区资源, 裸指针的时候需要这样做 */
         .             // BufferNodePtr cur = head;
         .             // while (cur != nullptr) {
         .             //   BufferNodePtr nxt = cur->next_;
         .             //   delete cur;
         .             //   cur = nxt;
         .             // }
         .             /* shared_ptr节点会造成循环引用而导致无法释放, 因此手动释放 */
         9 ( 0.00%)    BufferNodePtr cur = head;
        35 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (1x)
       106 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
       769 ( 0.00%)    while (cur != nullptr) {
     2,310 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:bool std::operator!=<TinyLog::AsynLog::BufferNode>(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&, decltype(nullptr)) (110x)
     1,199 ( 0.00%)      BufferNodePtr nxt = cur->next_;
    10,079 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (109x)
    11,499 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (109x)
     3,052 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (109x)
     2,507 ( 0.00%)      cur->prev_ = cur->next_ = nullptr;
   100,675 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (109x)
    31,661 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode>&&) (109x)
     3,815 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (109x)
     6,104 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (218x)
     5,014 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(decltype(nullptr)) (109x)
       545 ( 0.00%)      cur = nxt;
    18,585 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (109x)
         .             }
         8 ( 0.00%)  }
         .           
     1,070 ( 0.00%)  AsynLog::BufferNodePtr AsynLog::newBufferNode() {
       321 ( 0.00%)    BufferNodePtr cur = std::make_shared<BufferNode>();
   123,016 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode> std::make_shared<TinyLog::AsynLog::BufferNode>() (107x)
     1,498 ( 0.00%)    cur->buff_ = std::make_unique<Buffer>();
    50,466 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::_MakeUniq<TinyLog::LogBuffer::FixedBuffer<4194304ul> >::__single_object std::make_unique<TinyLog::LogBuffer::FixedBuffer<4194304ul>>() (107x)
    41,730 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator=(std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >&&) (107x)
     7,276 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::~unique_ptr() (107x)
     2,996 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (107x)
       107 ( 0.00%)    return cur;
       856 ( 0.00%)  }
         .           
         .           /* 前端和后端的唯一接口 */
44,000,000 ( 0.28%)  void AsynLog::append(const char *_msg, size_t _len) {
         .             /* RAII lock */
24,000,000 ( 0.15%)    std::unique_lock<std::mutex> lock(mtx_);
476,000,212 ( 3.05%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&) (4,000,000x)
20,000,000 ( 0.13%)    std::unique_ptr<Buffer> &curBuff = curBuffNode->buff_;
112,000,000 ( 0.72%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (4,000,000x)
         .           
36,000,000 ( 0.23%)    if (curBuff->avail() > _len) {
272,000,000 ( 1.74%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const (4,000,000x)
44,000,000 ( 0.28%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::avail() const (4,000,000x)
39,998,950 ( 0.26%)      curBuff->append(_msg, _len);
271,992,860 ( 1.74%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const (3,999,895x)
267,992,965 ( 1.72%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::append(char const*, unsigned long) (3,999,895x)
 3,999,895 ( 0.03%)      return;
         .             }
         .             /* 当前缓冲区写满了, 从环形缓冲区中移除该bufferNode */
         .             /* curPtr = curBuffNode */
     1,260 ( 0.00%)    assert(curBuffNode == head->next_);
     2,940 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (105x)
     3,780 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:bool std::operator==<TinyLog::AsynLog::BufferNode, TinyLog::AsynLog::BufferNode>(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&, std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (105x)
         .             /* 将当前缓冲区加入待落盘队列 */
       735 ( 0.00%)    writeBufferNode.push_back(curBuffNode);
    65,804 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::push_back(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (105x)
       840 ( 0.00%)    removeHead();
    71,085 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::removeHead() (105x)
     9,765 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (105x)
       525 ( 0.00%)    bufferSize_ -= 1;
         .           
         .             /* 如果无空余缓冲, 则新建缓冲区 BufferNode, 并加入环形缓冲区中 */
       420 ( 0.00%)    if (bufferSize_ == 0) {
       816 ( 0.00%)      BufferNodePtr newNode = newBufferNode();
   217,621 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::newBufferNode() (102x)
     9,486 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (102x)
     1,326 ( 0.00%)      addTail(newNode);
    80,580 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::addTail(std::shared_ptr<TinyLog::AsynLog::BufferNode>) (102x)
     9,486 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (102x)
    10,812 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (102x)
       510 ( 0.00%)      bufferSize_ += 1;
         .             }
         .             /* 更新 curBuffNode, 然后写入消息 */
     1,050 ( 0.00%)    curBuffNode = head->next_;
     2,940 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (105x)
    17,955 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (105x)
     1,260 ( 0.00%)    curBuffNode->buff_->append(_msg, _len);
     7,140 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const (105x)
     7,035 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::append(char const*, unsigned long) (105x)
     2,940 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (105x)
         .             /* 唤醒后台线程进行落盘操作 */
16,000,525 ( 0.10%)    cv_.notify_one();
376,000,070 ( 2.41%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock() (4,000,000x)
     4,389 ( 0.00%)  => ???:0x0000000000124610 (105x)
28,000,000 ( 0.18%)  }
         .           
         .           /* 后台日志线程 */
         9 ( 0.00%)  void AsynLog::threadFunc() {
         7 ( 0.00%)    assert(started_ == true);
        29 ( 0.00%)  => /usr/include/c++/9/atomic:std::atomic<bool>::operator bool() const (1x)
         4 ( 0.00%)    assert(bufferSize_ > 0);
         4 ( 0.00%)    counter_.countdown();
     1,395 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/CountDownLatch.cpp:TinyLog::CountDownLatch::countdown() (1x)
         .           
         .             /* 构建默认大小的环形缓冲区 */
        29 ( 0.00%)    for (int i = 0; i < bufferSize_; i++) {
        32 ( 0.00%)      auto cur = newBufferNode();
       372 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (4x)
     9,487 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::newBufferNode() (4x)
        52 ( 0.00%)      addHead(cur);
       424 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (4x)
       372 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (4x)
     3,160 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::addHead(std::shared_ptr<TinyLog::AsynLog::BufferNode>) (4x)
         .             }
         .           
         .             /* 初始化curBuffNode, 让其指向head -> next */
        10 ( 0.00%)    curBuffNode = head->next_;
        28 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
       113 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
         .             /* 日志文件写的具体实现 */
        11 ( 0.00%)    LogFile fileWriter(basename_, rollSize_, writerType_);
    19,322 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/LogFile.cpp:TinyLog::LogFile::LogFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, TinyLog::FileWriterType) (1x)
     1,027 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/LogFile.h:TinyLog::LogFile::~LogFile() (1x)
         .           
        13 ( 0.00%)    while (started_) {
        58 ( 0.00%)  => /usr/include/c++/9/atomic:std::atomic<bool>::operator bool() const (2x)
         .               /* RAII lock block */
         .               {
         6 ( 0.00%)        std::unique_lock<std::mutex> lock(mtx_);
       143 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&) (1x)
         .                 /* 如果写的太慢会被刷盘间隔唤醒, 唤醒后进行刷盘,
         .                  * 不能用while循环判断缓冲区是否为空, 如果缓冲区一直为空, 则导致死锁*/
         6 ( 0.00%)        if (writeBufferNode.empty())
       129 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::empty() const (1x)
         .                   cv_.wait_for(lock, std::chrono::seconds(flushInterval_));
         .           
         9 ( 0.00%)        if (writeBufferNode.empty() and curBuffNode->buff_->size() == 0)
       129 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::empty() const (1x)
         .                   continue;
         .                 /* 将当前缓冲区加入待落盘队列 */
         7 ( 0.00%)        writeBufferNode.push_back(curBuffNode);
       199 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::push_back(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
         8 ( 0.00%)        removeHead();
        93 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (1x)
       677 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::removeHead() (1x)
         5 ( 0.00%)        bufferSize_ -= 1;
         .           
         .                 /* 如果之后无缓冲区则新建 */
         4 ( 0.00%)        if (bufferSize_ == 0) {
         8 ( 0.00%)          auto newNode = newBufferNode();
        93 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (1x)
     2,228 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::newBufferNode() (1x)
        13 ( 0.00%)          addTail(newNode);
       790 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::addTail(std::shared_ptr<TinyLog::AsynLog::BufferNode>) (1x)
       106 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
        93 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (1x)
         5 ( 0.00%)          bufferSize_ += 1;
         .                 }
         .                 /* 更新 curBuffNode */
        16 ( 0.00%)        curBuffNode = head->next_;
        28 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
       171 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (1x)
       101 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock() (1x)
         .               }
         .           
         .               /* 异步写入日志, 限制最大写入缓冲区数目*/
         5 ( 0.00%)      int mxNums = std::min(static_cast<int>(writeBufferNode.size()),
        13 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::size() const (1x)
         6 ( 0.00%)                            kLogConfig.fileOption.maxBuffToWrite);
        15 ( 0.00%)  => /usr/include/c++/9/bits/stl_algobase.h:int const& std::min<int>(int const&, int const&) (1x)
        84 ( 0.00%)      for (int i = 0; i < mxNums; i++) {
       240 ( 0.00%)        BufferNodePtr node = writeBufferNode[i];
     1,696 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (16x)
     1,488 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (16x)
       192 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::operator[](unsigned long) (16x)
       336 ( 0.00%)        fileWriter.append(node->buff_->data(), node->buff_->size());
 1,048,166 ( 0.01%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/LogFile.cpp:TinyLog::LogFile::append(char const*, unsigned long) (16x)
     2,176 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const (32x)
       896 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (32x)
       128 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::size() const (16x)
       112 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::data() const (16x)
         .               }
         .           
         .               /* Flush */
         3 ( 0.00%)      fileWriter.flush();
       333 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/LogFile.cpp:TinyLog::LogFile::flush() (1x)
         .           
         .               /* RAII lock block*/
         .               {
         .                 /* 归还buffer到环形缓冲区中 */
         9 ( 0.00%)        std::unique_lock<std::mutex> lock(mtx_);
       119 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::unique_lock(std::mutex&) (1x)
        94 ( 0.00%)  => /usr/include/c++/9/bits/unique_lock.h:std::unique_lock<std::mutex>::~unique_lock() (1x)
     1,608 ( 0.00%)        for (auto &node : writeBufferNode) {
     3,745 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:bool __gnu_cxx::operator!=<std::shared_ptr<TinyLog::AsynLog::BufferNode>*, std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > > >(__gnu_cxx::__normal_iterator<std::shared_ptr<TinyLog::AsynLog::BufferNode>*, std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > > > const&, __gnu_cxx::__normal_iterator<std::shared_ptr<TinyLog::AsynLog::BufferNode>*, std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > > > const&) (107x)
     1,272 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<TinyLog::AsynLog::BufferNode>*, std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > > >::operator++() (106x)
       848 ( 0.00%)  => /usr/include/c++/9/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<TinyLog::AsynLog::BufferNode>*, std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > > >::operator*() const (106x)
        32 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::end() (1x)
        31 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::begin() (1x)
         .                   /* 必须清空后加入环形缓冲区 */
       742 ( 0.00%)          node->buff_->clear();
     7,208 ( 0.00%)  => /usr/include/c++/9/bits/unique_ptr.h:std::unique_ptr<TinyLog::LogBuffer::FixedBuffer<4194304ul>, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::operator->() const (106x)
     2,968 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (106x)
       954 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Buffer.h:TinyLog::LogBuffer::FixedBuffer<4194304ul>::clear() (106x)
     1,378 ( 0.00%)          addTail(node);
    83,573 ( 0.00%)  => TinyLog/src/Asynlog.cpp:TinyLog::AsynLog::addTail(std::shared_ptr<TinyLog::AsynLog::BufferNode>) (106x)
    11,236 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (106x)
     9,858 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::~shared_ptr() (106x)
       530 ( 0.00%)          bufferSize_ += 1;
         .                 }
         4 ( 0.00%)        writeBufferNode.clear();
    12,917 ( 0.00%)  => /usr/include/c++/9/bits/stl_vector.h:std::vector<std::shared_ptr<TinyLog::AsynLog::BufferNode>, std::allocator<std::shared_ptr<TinyLog::AsynLog::BufferNode> > >::clear() (1x)
         .               }
         .             }
         .           
         .             /* Last Flush */
         3 ( 0.00%)    fileWriter.flush();
       174 ( 0.00%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/src/LogFile.cpp:TinyLog::LogFile::flush() (1x)
         8 ( 0.00%)  }
         .           
         .           /* 必须在临界区中执行, 即被 mutex 保护 */
        28 ( 0.00%)  void AsynLog::addHead(BufferNodePtr cur) {
        48 ( 0.00%)    cur->next_ = head->next_;
       452 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (4x)
       224 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (8x)
        48 ( 0.00%)    head->next_->prev_ = cur;
       684 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (4x)
       224 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (8x)
        36 ( 0.00%)    head->next_ = cur;
       684 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (4x)
       112 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (4x)
        36 ( 0.00%)    cur->prev_ = head;
       452 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (4x)
       112 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (4x)
        20 ( 0.00%)  }
         .           
         .           /* 必须在临界区中执行, 即被 mutex 保护 */
     1,060 ( 0.00%)  AsynLog::BufferNodePtr AsynLog::removeHead() {
       424 ( 0.00%)    assert(bufferSize_ != 0);
       954 ( 0.00%)    BufferNodePtr ret = head->next_;
     2,968 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (106x)
    11,236 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::shared_ptr(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (106x)
     1,696 ( 0.00%)    head->next_ = head->next_->next_;
    18,126 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (106x)
     8,904 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (318x)
     1,378 ( 0.00%)    head->next_->prev_ = head;
    18,126 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (106x)
     5,936 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (212x)
       106 ( 0.00%)    return ret;
       848 ( 0.00%)  }
         .           
         .           /* 必须在临界区中执行, 即被 mutex 保护 */
     1,463 ( 0.00%)  void AsynLog::addTail(BufferNodePtr cur) {
     2,508 ( 0.00%)    cur->prev_ = tail->prev_;
    29,765 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (209x)
    11,704 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (418x)
     2,508 ( 0.00%)    tail->prev_->next_ = cur;
    35,739 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (209x)
    11,704 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (418x)
     1,881 ( 0.00%)    cur->next_ = tail;
    17,302 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (209x)
     5,852 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (209x)
     1,881 ( 0.00%)    tail->prev_ = cur;
    35,739 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr.h:std::shared_ptr<TinyLog::AsynLog::BufferNode>::operator=(std::shared_ptr<TinyLog::AsynLog::BufferNode> const&) (209x)
     5,852 ( 0.00%)  => /usr/include/c++/9/bits/shared_ptr_base.h:std::__shared_ptr_access<TinyLog::AsynLog::BufferNode, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (209x)
     1,045 ( 0.00%)  }
         .           
         .           /* 必须在临界区中执行, 即被 mutex 保护 */
         .           AsynLog::BufferNodePtr AsynLog::removeTail() {
         .             assert(bufferSize_ != 0);
         .             BufferNodePtr ret = tail->prev_;
         .             tail->prev_ = tail->prev_->prev_;
         .             tail->prev_->next_ = tail;
         .             return ret;
-- line 195 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/include/Logging.h
--------------------------------------------------------------------------------
Ir                   

-- line 30 ----------------------------------------
          .           */
          .           class str_const { // constexpr string
          .           private:
          .             const char *p_;
          .             std::size_t sz_;
          .           
          .           public:
          .             template <std::size_t N>
132,000,000 ( 0.85%)    constexpr str_const(const char (&a)[N]) : p_(a), sz_(N - 1) {
 72,000,000 ( 0.46%)      const char *idx = strrchr(p_, '/'); // builtin function
376,000,000 ( 2.41%)  => ???:0x00000000001247f0 (8,000,000x)
 24,000,000 ( 0.15%)      if (idx) {
 32,000,000 ( 0.20%)        p_ = idx + 1;
 64,000,000 ( 0.41%)        sz_ -= static_cast<size_t>(p_ - a);
          .               }
 36,000,000 ( 0.23%)    }
          .           
          .             constexpr char operator[](std::size_t n) { // []
          .               return n < sz_ ? p_[n] : throw std::out_of_range("");
          .             }
          .           
 64,000,000 ( 0.41%)    constexpr std::size_t size() { return sz_; }
 32,000,000 ( 0.20%)    constexpr const char *data() { return p_; }
          .           };
          .           
          .           /* compile-time 将x转换为字符串 */
          .           #define strify_(x) val_(x)
          .           #define val_(x) #x
          .           
          .           /* 编译期获取字符串长度宏定义 */
          .           #define getStrLen_(x) TinyLog::str_const(x).size()
-- line 59 ----------------------------------------
-- line 106 ----------------------------------------
          .              *va_list、va_arg和va_end等可变参数相关的宏来处理.
          .              **/
          .             void append(const char *file, size_t fileLen, const char *line,
          .                         size_t lineLen, const char *fmt, Logger::LogLevel level, ...);
          .           
          .             /*内部类 用于回收单例Logger资源 */
          .             struct GC {
          .               GC() = default;
          5 ( 0.00%)      ~GC() {
          3 ( 0.00%)        if (_logger)
          6 ( 0.00%)          delete _logger;
         95 ( 0.00%)  => ???:0x0000000000124790 (1x)
          3 ( 0.00%)      }
          .             };
          .           
          .           private:
          .             /* Logger 单例变量的声明 */
          .             static Logger *_logger;
          .             static std::mutex _mtx;
          .             Logger() = default;
          .             ~Logger() = default;
-- line 125 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/src/Timestamp.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 13 ----------------------------------------
         .           #include "sys/time.h"
         .           #include <cstddef>
         .           #include <cstdio>
         .           #include <ctime>
         .           
         .           namespace TinyLog {
         .           
         .           /* Unix 时间戳 */
28,000,000 ( 0.18%)  Timestamp Timestamp::now() {
         .             struct timeval tv;
16,000,000 ( 0.10%)    gettimeofday(&tv, NULL);
40,000,000 ( 0.26%)  => ???:0x0000000000124940 (4,000,000x)
 8,000,000 ( 0.05%)    int64_t seconds = tv.tv_sec;
28,000,000 ( 0.18%)    return Timestamp(seconds * kmilliSecondsPerSecond +
44,000,000 ( 0.28%)  => /home1/jsj/Code/cpp/projects/AsynLog/TinyLog/include/Timestamp.h:TinyLog::Timestamp::Timestamp(long) (4,000,000x)
40,000,000 ( 0.26%)                     tv.tv_usec / kmilliSecondsPerSecond);
20,000,000 ( 0.13%)  }
         .           
         .           /* 格式化时间: 使用localtime_r保证线程安全 */
         .           std::string Timestamp::toString() {
         .             char buff[64];
         .             time_t second =
         .                 static_cast<time_t>(milliSecondsSinceEpoch_ / kmilliSecondsPerSecond);
         .             struct tm tm_time;
         .             /* stores the data in a user-supplied struct tm_time*/
-- line 35 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: TinyLog/src/ThreadInfo.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 12 ----------------------------------------
         .           #include <unistd.h>
         .           
         .           namespace TinyLog ::ThreadInfo {
         .           
         .           thread_local int currentTid = 0;
         .           thread_local char tidStr[32];
         .           thread_local size_t tidStrlen = 0;
         .           
 2,400,000 ( 0.02%)  int getTid() {
 2,400,000 ( 0.02%)    if (currentTid == 0) {
        16 ( 0.00%)      currentTid = ::gettid();
        48 ( 0.00%)  => ???:0x0000000000124720 (8x)
        80 ( 0.00%)      tidStrlen = static_cast<size_t>(snprintf(tidStr, sizeof(tidStr), "%d ", currentTid));
     6,416 ( 0.00%)  => ???:0x0000000000124930 (8x)
         .             }
   800,000 ( 0.01%)    return currentTid;
 1,600,000 ( 0.01%)  }
         .           
28,000,000 ( 0.18%)  const char *getTidStr() { return tidStr; }
         .           
24,000,000 ( 0.15%)  size_t getTidStrlen() { return tidStrlen; }
         .           
         6 ( 0.00%)  pid_t getPid() { return ::getpid(); }
         6 ( 0.00%)  => ???:0x00000000001248d0 (1x)
         .           
         8 ( 0.00%)  std::string getPidStr() {
         6 ( 0.00%)    return std::to_string(getPid());
     1,048 ( 0.00%)  => /usr/include/c++/9/bits/basic_string.h:std::__cxx11::to_string(int) (1x)
        12 ( 0.00%)  => TinyLog/src/ThreadInfo.cpp:TinyLog::ThreadInfo::getPid() (1x)
         .             // char buff[32];
         .             // snprintf(buff, sizeof(buff), "%d", getPid());
         .             // return buff;
         6 ( 0.00%)  }
         .           
         .           } // namespace TinyLog::ThreadInfo
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/tuple
--------------------------------------------------------------------------------
Ir                   

-- line 68 ----------------------------------------
          .             template<std::size_t _Idx, typename _Head,
          .           	   bool = __empty_not_final<_Head>::value>
          .               struct _Head_base;
          .           
          .             template<std::size_t _Idx, typename _Head>
          .               struct _Head_base<_Idx, _Head, true>
          .               : public _Head
          .               {
        912 ( 0.00%)        constexpr _Head_base()
        684 ( 0.00%)        : _Head() { }
          .           
          .                 constexpr _Head_base(const _Head& __h)
          .                 : _Head(__h) { }
          .           
          .                 constexpr _Head_base(const _Head_base&) = default;
          .                 constexpr _Head_base(_Head_base&&) = default;
          .           
          .                 template<typename _UHead>
-- line 85 ----------------------------------------
-- line 105 ----------------------------------------
          .           	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
          .           	: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }
          .           
          .                 template<typename _Alloc, typename _UHead>
          .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
          .           	: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }
          .           
          .                 static constexpr _Head&
      2,289 ( 0.00%)        _M_head(_Head_base& __b) noexcept { return __b; }
          .           
          .                 static constexpr const _Head&
          .                 _M_head(const _Head_base& __b) noexcept { return __b; }
          .               };
          .           
          .             template<std::size_t _Idx, typename _Head>
          .               struct _Head_base<_Idx, _Head, false>
          .               {
        912 ( 0.00%)        constexpr _Head_base()
      1,140 ( 0.00%)        : _M_head_impl() { }
          .           
         40 ( 0.00%)        constexpr _Head_base(const _Head& __h)
         56 ( 0.00%)        : _M_head_impl(__h) { }
          .           
          .                 constexpr _Head_base(const _Head_base&) = default;
          .                 constexpr _Head_base(_Head_base&&) = default;
          .           
          .                 template<typename _UHead>
         72 ( 0.00%)          constexpr _Head_base(_UHead&& __h)
        112 ( 0.00%)  	: _M_head_impl(std::forward<_UHead>(__h)) { }
         14 ( 0.00%)  => /usr/include/c++/9/bits/move.h:void (TinyLog::AsynLog::*&&std::forward<void (TinyLog::AsynLog::*)()>(std::remove_reference<void (TinyLog::AsynLog::*)()>::type&))() (2x)
          .           
          .                 _Head_base(allocator_arg_t, __uses_alloc0)
          .                 : _M_head_impl() { }
          .           
          .                 template<typename _Alloc>
          .           	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
          .           	: _M_head_impl(allocator_arg, *__a._M_a) { }
          .           
-- line 141 ----------------------------------------
-- line 152 ----------------------------------------
          .           	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
          .           	{ }
          .           
          .                 template<typename _Alloc, typename _UHead>
          .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
          .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
          .           
          .                 static constexpr _Head&
      4,102 ( 0.00%)        _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
          .           
          .                 static constexpr const _Head&
 84,001,974 ( 0.54%)        _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
          .           
          .                 _Head _M_head_impl;
          .               };
          .           
          .             /**
          .              * Contains the actual implementation of the @c tuple template, stored
          .              * as a recursive inheritance hierarchy from the first element (most
          .              * derived class) to the last (least derived class). The @c Idx
-- line 171 ----------------------------------------
-- line 187 ----------------------------------------
          .                 private _Head_base<_Idx, _Head>
          .               {
          .                 template<std::size_t, typename...> friend class _Tuple_impl;
          .           
          .                 typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
          .                 typedef _Head_base<_Idx, _Head> _Base;
          .           
          .                 static constexpr _Head&
      5,682 ( 0.00%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
         14 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, void (TinyLog::AsynLog::*)(), false>::_M_head(std::_Head_base<0ul, void (TinyLog::AsynLog::*)(), false>&) (2x)
          .           
          .                 static constexpr const _Head&
120,002,820 ( 0.77%)        _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          7 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::NormalFileWriter*, false>::_M_head(std::_Head_base<0ul, TinyLog::NormalFileWriter*, false> const&) (1x)
          .           
          .                 static constexpr _Inherited&
          7 ( 0.00%)        _M_tail(_Tuple_impl& __t) noexcept { return __t; }
          .           
          .                 static constexpr const _Inherited&
          .                 _M_tail(const _Tuple_impl& __t) noexcept { return __t; }
          .           
      1,140 ( 0.00%)        constexpr _Tuple_impl()
      2,052 ( 0.00%)        : _Inherited(), _Base() { }
      3,888 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<1ul, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_Tuple_impl() (216x)
      1,944 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, false>::_Head_base() (216x)
          .           
          .                 explicit
          .                 constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
          .                 : _Inherited(__tail...), _Base(__head) { }
          .           
          .                 template<typename _UHead, typename... _UTail, typename = typename
          .                          enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
          .                   explicit
          8 ( 0.00%)          constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
          .           	: _Inherited(std::forward<_UTail>(__tail)...),
         20 ( 0.00%)  	  _Base(std::forward<_UHead>(__head)) { }
         48 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<1ul, TinyLog::AsynLog*>::_Tuple_impl<TinyLog::AsynLog*>(TinyLog::AsynLog*&&) (1x)
         24 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, void (TinyLog::AsynLog::*)(), false>::_Head_base<void (TinyLog::AsynLog::*)()>(void (TinyLog::AsynLog::*&&)()) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:void (TinyLog::AsynLog::*&&std::forward<void (TinyLog::AsynLog::*)()>(std::remove_reference<void (TinyLog::AsynLog::*)()>::type&))() (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:TinyLog::AsynLog*&& std::forward<TinyLog::AsynLog*>(std::remove_reference<TinyLog::AsynLog*>::type&) (1x)
          .           
          .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
          .           
          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .                 // 2729. Missing SFINAE on std::pair::operator=
          .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
          .           
          .                 constexpr
          7 ( 0.00%)        _Tuple_impl(_Tuple_impl&& __in)
          .                 noexcept(__and_<is_nothrow_move_constructible<_Head>,
          .           	              is_nothrow_move_constructible<_Inherited>>::value)
          5 ( 0.00%)        : _Inherited(std::move(_M_tail(__in))),
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<std::_Tuple_impl<1ul, TinyLog::AsynLog*>&>::type&& std::move<std::_Tuple_impl<1ul, TinyLog::AsynLog*>&>(std::_Tuple_impl<1ul, TinyLog::AsynLog*>&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>::_M_tail(std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>&) (1x)
         19 ( 0.00%)  	_Base(std::forward<_Head>(_M_head(__in))) { }
         67 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<1ul, TinyLog::AsynLog*>::_Tuple_impl(std::_Tuple_impl<1ul, TinyLog::AsynLog*>&&) (1x)
         24 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, void (TinyLog::AsynLog::*)(), false>::_Head_base<void (TinyLog::AsynLog::*)()>(void (TinyLog::AsynLog::*&&)()) (1x)
         18 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>::_M_head(std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:void (TinyLog::AsynLog::*&&std::forward<void (TinyLog::AsynLog::*)()>(std::remove_reference<void (TinyLog::AsynLog::*)()>::type&))() (1x)
          .           
          .                 template<typename... _UElements>
          .                   constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
          .           	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
          .           	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
          .           
          .                 template<typename _UHead, typename... _UTails>
          .                   constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
-- line 239 ----------------------------------------
-- line 326 ----------------------------------------
          .               struct _Tuple_impl<_Idx, _Head>
          .               : private _Head_base<_Idx, _Head>
          .               {
          .                 template<std::size_t, typename...> friend class _Tuple_impl;
          .           
          .                 typedef _Head_base<_Idx, _Head> _Base;
          .           
          .                 static constexpr _Head&
      3,450 ( 0.00%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
         14 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<1ul, TinyLog::AsynLog*, false>::_M_head(std::_Head_base<1ul, TinyLog::AsynLog*, false>&) (2x)
          .           
          .                 static constexpr const _Head&
          .                 _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
          .           
      1,140 ( 0.00%)        constexpr _Tuple_impl()
      1,368 ( 0.00%)        : _Base() { }
      1,512 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<1ul, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> >, true>::_Head_base() (216x)
          .           
          .                 explicit
         48 ( 0.00%)        constexpr _Tuple_impl(const _Head& __head)
         64 ( 0.00%)        : _Base(__head) { }
         96 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<0ul, void (*)(), false>::_Head_base(void (* const&)()) (8x)
          .           
          .                 template<typename _UHead>
          .                   explicit
          7 ( 0.00%)          constexpr _Tuple_impl(_UHead&& __head)
         12 ( 0.00%)  	: _Base(std::forward<_UHead>(__head)) { }
         22 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<1ul, TinyLog::AsynLog*, false>::_Head_base<TinyLog::AsynLog*>(TinyLog::AsynLog*&&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:TinyLog::AsynLog*&& std::forward<TinyLog::AsynLog*>(std::remove_reference<TinyLog::AsynLog*>::type&) (1x)
          .           
          .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
          .           
          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .                 // 2729. Missing SFINAE on std::pair::operator=
          .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
          .           
          .                 constexpr
         63 ( 0.00%)        _Tuple_impl(_Tuple_impl&& __in)
          .                 noexcept(is_nothrow_move_constructible<_Head>::value)
        126 ( 0.00%)        : _Base(std::forward<_Head>(_M_head(__in))) { }
         22 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Head_base<1ul, TinyLog::AsynLog*, false>::_Head_base<TinyLog::AsynLog*>(TinyLog::AsynLog*&&) (1x)
         17 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<1ul, TinyLog::AsynLog*>::_M_head(std::_Tuple_impl<1ul, TinyLog::AsynLog*>&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:TinyLog::AsynLog*&& std::forward<TinyLog::AsynLog*>(std::remove_reference<TinyLog::AsynLog*>::type&) (1x)
          .           
          .                 template<typename _UHead>
          .                   constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
          .           	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
          .           
          .                 template<typename _UHead>
          .                   constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
          .           	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
-- line 368 ----------------------------------------
-- line 580 ----------------------------------------
          .                 template<typename _Dummy = void,
          .                          typename enable_if<
          .                            _TCC<_Dummy>::template
          .                              _ConstructibleTuple<_Elements...>()
          .                            && _TCC<_Dummy>::template
          .                              _ImplicitlyConvertibleTuple<_Elements...>()
          .                            && (sizeof...(_Elements) >= 1),
          .                          bool>::type=true>
         48 ( 0.00%)          constexpr tuple(const _Elements&... __elements)
         64 ( 0.00%)        : _Inherited(__elements...) { }
        208 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (*)()>::_Tuple_impl(void (* const&)()) (8x)
          .           
          .                 template<typename _Dummy = void,
          .                          typename enable_if<
          .                            _TCC<_Dummy>::template
          .                              _ConstructibleTuple<_Elements...>()
          .                            && !_TCC<_Dummy>::template
          .                              _ImplicitlyConvertibleTuple<_Elements...>()
          .                            && (sizeof...(_Elements) >= 1),
-- line 597 ----------------------------------------
-- line 634 ----------------------------------------
          .                               _ImplicitlyMoveConvertibleTuple<_UElements...>()
          .                             && (sizeof...(_Elements) >= 1),
          .                   bool>::type=false>
          .                   explicit constexpr tuple(_UElements&&... __elements)
          .           	: _Inherited(std::forward<_UElements>(__elements)...) {	}
          .           
          .                 constexpr tuple(const tuple&) = default;
          .           
        112 ( 0.00%)        constexpr tuple(tuple&&) = default;
        536 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (*)()>::_Tuple_impl(std::_Tuple_impl<0ul, void (*)()>&&) (8x)
          .           
          .                 // Shortcut for the cases where constructors taking tuples
          .                 // must avoid creating temporaries.
          .                 template<typename _Dummy> using _TNTC =
          .                   _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
          .                       _Elements...>;
          .           
          .                 template<typename... _UElements, typename _Dummy = void, typename
-- line 650 ----------------------------------------
-- line 910 ----------------------------------------
          .           
          .               public:
          .                 template <typename _U1 = _T1,
          .                           typename _U2 = _T2,
          .                           typename enable_if<__and_<
          .                                                __is_implicitly_default_constructible<_U1>,
          .                                                __is_implicitly_default_constructible<_U2>>
          .                                              ::value, bool>::type = true>
      1,140 ( 0.00%)  	constexpr tuple()
      1,368 ( 0.00%)  	: _Inherited() { }
         41 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >::_Tuple_impl() (1x)
          .           
          .                 template <typename _U1 = _T1,
          .                           typename _U2 = _T2,
          .                           typename enable_if<
          .                             __and_<
          .                               is_default_constructible<_U1>,
          .                               is_default_constructible<_U2>,
          .                               __not_<
-- line 927 ----------------------------------------
-- line 960 ----------------------------------------
          .           
          .                 template<typename _U1, typename _U2, typename
          .                   enable_if<_TMC::template
          .                               _MoveConstructibleTuple<_U1, _U2>()
          .                             && _TMC::template
          .                               _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
          .           	          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
          .           	bool>::type = true>
          9 ( 0.00%)          constexpr tuple(_U1&& __a1, _U2&& __a2)
         18 ( 0.00%)  	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
        114 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>::_Tuple_impl<void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*, void>(void (TinyLog::AsynLog::*&&)(), TinyLog::AsynLog*&&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:TinyLog::AsynLog*&& std::forward<TinyLog::AsynLog*>(std::remove_reference<TinyLog::AsynLog*>::type&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:void (TinyLog::AsynLog::*&&std::forward<void (TinyLog::AsynLog::*)()>(std::remove_reference<void (TinyLog::AsynLog::*)()>::type&))() (1x)
          .           
          .                 template<typename _U1, typename _U2, typename
          .                   enable_if<_TMC::template
          .                               _MoveConstructibleTuple<_U1, _U2>()
          .                             && !_TMC::template
          .                               _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
          .           	          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
          .           	bool>::type = false>
          .                   explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
          .           	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
          .           
          .                 constexpr tuple(const tuple&) = default;
          .           
         14 ( 0.00%)        constexpr tuple(tuple&&) = default;
        161 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>::_Tuple_impl(std::_Tuple_impl<0ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>&&) (1x)
          .           
          .                 template<typename _U1, typename _U2, typename
          .                   enable_if<_TMC::template
          .                               _ConstructibleTuple<_U1, _U2>()
          .                             && _TMC::template
          .                               _ImplicitlyConvertibleTuple<_U1, _U2>(),
          .           	bool>::type = true>
          .                   constexpr tuple(const tuple<_U1, _U2>& __in)
-- line 991 ----------------------------------------
-- line 1301 ----------------------------------------
          .               struct tuple_element<__i, tuple<>>
          .               {
          .                 static_assert(__i < tuple_size<tuple<>>::value,
          .           	  "tuple index is in range");
          .               };
          .           
          .             template<std::size_t __i, typename _Head, typename... _Tail>
          .               constexpr _Head&
      4,515 ( 0.00%)      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      4,515 ( 0.00%)      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
         17 ( 0.00%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::SynLog*, std::default_delete<TinyLog::SynLog> >::_M_head(std::_Tuple_impl<0ul, TinyLog::SynLog*, std::default_delete<TinyLog::SynLog> >&) (1x)
          .           
          .             template<std::size_t __i, typename _Head, typename... _Tail>
          .               constexpr const _Head&
 60,001,410 ( 0.38%)      __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 60,001,410 ( 0.38%)      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
136,004,165 ( 0.87%)  => /usr/include/c++/9/tuple:std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > >::_M_head(std::_Tuple_impl<0ul, TinyLog::LogBuffer::FixedBuffer<4194304ul>*, std::default_delete<TinyLog::LogBuffer::FixedBuffer<4194304ul> > > const&) (8,000,245x)
          .           
          .             /// Return a reference to the ith element of a tuple.
          .             template<std::size_t __i, typename... _Elements>
          .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      4,515 ( 0.00%)      get(tuple<_Elements...>& __t) noexcept
      4,515 ( 0.00%)      { return std::__get_helper<__i>(__t); }
         27 ( 0.00%)  => /usr/include/c++/9/tuple:TinyLog::AsynLog*& std::__get_helper<1ul, TinyLog::AsynLog*>(std::_Tuple_impl<1ul, TinyLog::AsynLog*>&) (1x)
          .           
          .             /// Return a const reference to the ith element of a const tuple.
          .             template<std::size_t __i, typename... _Elements>
          .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
 60,001,410 ( 0.38%)      get(const tuple<_Elements...>& __t) noexcept
 60,001,410 ( 0.38%)      { return std::__get_helper<__i>(__t); }
108,000,054 ( 0.69%)  => /usr/include/c++/9/tuple:TinyLog::AsynLog* const& std::__get_helper<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> >(std::_Tuple_impl<0ul, TinyLog::AsynLog*, std::default_delete<TinyLog::AsynLog> > const&) (4,000,002x)
          .           
          .             /// Return an rvalue reference to the ith element of a tuple rvalue.
          .             template<std::size_t __i, typename... _Elements>
          .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
         50 ( 0.00%)      get(tuple<_Elements...>&& __t) noexcept
          .               {
          .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
         50 ( 0.00%)        return std::forward<__element_type&&>(std::get<__i>(__t));
         37 ( 0.00%)  => /usr/include/c++/9/tuple:std::tuple_element<1ul, std::tuple<void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*> >::type& std::get<1ul, void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>(std::tuple<void (TinyLog::AsynLog::*)(), TinyLog::AsynLog*>&) (1x)
          7 ( 0.00%)  => /usr/include/c++/9/bits/move.h:TinyLog::AsynLog*&& std::forward<TinyLog::AsynLog*&&>(std::remove_reference<TinyLog::AsynLog*&&>::type&) (1x)
         20 ( 0.00%)      }
          .           
          .             /// Return a const rvalue reference to the ith element of a const tuple rvalue.
          .             template<std::size_t __i, typename... _Elements>
          .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
          .               get(const tuple<_Elements...>&& __t) noexcept
          .               {
          .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
          .                 return std::forward<const __element_type&&>(std::get<__i>(__t));
-- line 1344 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/move.h
--------------------------------------------------------------------------------
Ir                  

-- line 39 ----------------------------------------
         .           
         .             // Used, in C++03 mode too, by allocators, etc.
         .             /**
         .              *  @brief Same as C++11 std::addressof
         .              *  @ingroup utilities
         .              */
         .             template<typename _Tp>
         .               inline _GLIBCXX_CONSTEXPR _Tp*
32,002,908 ( 0.20%)      __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
24,002,181 ( 0.15%)      { return __builtin_addressof(__r); }
         .           
         .           #if __cplusplus >= 201103L
         .           
         .           _GLIBCXX_END_NAMESPACE_VERSION
         .           } // namespace
         .           
         .           #include <type_traits> // Brings in std::declval too.
         .           
-- line 56 ----------------------------------------
-- line 66 ----------------------------------------
         .             /**
         .              *  @brief  Forward an lvalue.
         .              *  @return The parameter cast to the specified type.
         .              *
         .              *  This function is used to implement "perfect forwarding".
         .              */
         .             template<typename _Tp>
         .               constexpr _Tp&&
64,002,712 ( 0.41%)      forward(typename std::remove_reference<_Tp>::type& __t) noexcept
48,002,034 ( 0.31%)      { return static_cast<_Tp&&>(__t); }
         .           
         .             /**
         .              *  @brief  Forward an rvalue.
         .              *  @return The parameter cast to the specified type.
         .              *
         .              *  This function is used to implement "perfect forwarding".
         .              */
         .             template<typename _Tp>
-- line 83 ----------------------------------------
-- line 91 ----------------------------------------
         .           
         .             /**
         .              *  @brief  Convert a value to an rvalue.
         .              *  @param  __t  A thing of arbitrary type.
         .              *  @return The parameter cast to an rvalue-reference to allow moving it.
         .             */
         .             template<typename _Tp>
         .               constexpr typename std::remove_reference<_Tp>::type&&
     5,212 ( 0.00%)      move(_Tp&& __t) noexcept
     3,909 ( 0.00%)      { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
         .           
         .           
         .             template<typename _Tp>
         .               struct __move_if_noexcept_cond
         .               : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
         .                               is_copy_constructible<_Tp>>::type { };
         .           
         .             /**
-- line 108 ----------------------------------------
-- line 174 ----------------------------------------
         .              *  @return   Nothing.
         .             */
         .             template<typename _Tp>
         .               inline
         .           #if __cplusplus >= 201103L
         .               typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         .           			      is_move_constructible<_Tp>,
         .           			      is_move_assignable<_Tp>>::value>::type
     2,097 ( 0.00%)      swap(_Tp& __a, _Tp& __b)
         .               noexcept(__and_<is_nothrow_move_constructible<_Tp>,
         .           	            is_nothrow_move_assignable<_Tp>>::value)
         .           #else
         .               void
         .               swap(_Tp& __a, _Tp& __b)
         .           #endif
         .               {
         .                 // concept requirements
         .                 __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
         .           
     1,169 ( 0.00%)        _Tp __tmp = _GLIBCXX_MOVE(__a);
       749 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>::type&& std::move<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>(TinyLog::LogBuffer::FixedBuffer<4194304ul>*&) (107x)
     1,402 ( 0.00%)        __a = _GLIBCXX_MOVE(__b);
       749 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>::type&& std::move<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>(TinyLog::LogBuffer::FixedBuffer<4194304ul>*&) (107x)
     1,402 ( 0.00%)        __b = _GLIBCXX_MOVE(__tmp);
       749 ( 0.00%)  => /usr/include/c++/9/bits/move.h:std::remove_reference<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>::type&& std::move<TinyLog::LogBuffer::FixedBuffer<4194304ul>*&>(TinyLog::LogBuffer::FixedBuffer<4194304ul>*&) (107x)
     1,398 ( 0.00%)      }
         .           
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // DR 809. std::swap should be overloaded for array types.
         .             /// Swap the contents of two arrays.
         .             template<typename _Tp, size_t _Nm>
         .               inline
         .           #if __cplusplus >= 201103L
         .               typename enable_if<__is_swappable<_Tp>::value>::type
-- line 204 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/std_mutex.h
--------------------------------------------------------------------------------
Ir                  

-- line 57 ----------------------------------------
         .             class __mutex_base
         .             {
         .             protected:
         .               typedef __gthread_mutex_t			__native_type;
         .           
         .           #ifdef __GTHREAD_MUTEX_INIT
         .               __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;
         .           
        26 ( 0.00%)      constexpr __mutex_base() noexcept = default;
         .           #else
         .               __native_type  _M_mutex;
         .           
         .               __mutex_base() noexcept
         .               {
         .                 // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
         .                 __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
         .               }
-- line 73 ----------------------------------------
-- line 83 ----------------------------------------
         .             class mutex : private __mutex_base
         .             {
         .             public:
         .               typedef __native_type* 			native_handle_type;
         .           
         .           #ifdef __GTHREAD_MUTEX_INIT
         .               constexpr
         .           #endif
        22 ( 0.00%)      mutex() noexcept = default;
        26 ( 0.00%)  => /usr/include/c++/9/bits/std_mutex.h:std::__mutex_base::__mutex_base() (2x)
         .               ~mutex() = default;
         .           
         .               mutex(const mutex&) = delete;
         .               mutex& operator=(const mutex&) = delete;
         .           
         .               void
20,000,030 ( 0.13%)      lock()
         .               {
16,000,024 ( 0.10%)        int __e = __gthread_mutex_lock(&_M_mutex);
220,000,566 ( 1.41%)  => /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_lock(pthread_mutex_t*) (4,000,006x)
         .           
         .                 // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
 8,000,012 ( 0.05%)        if (__e)
         .           	__throw_system_error(__e);
12,000,018 ( 0.08%)      }
         .           
         .               bool
         .               try_lock() noexcept
         .               {
         .                 // XXX EINVAL, EAGAIN, EBUSY
         .                 return !__gthread_mutex_trylock(&_M_mutex);
         .               }
         .           
         .               void
20,000,030 ( 0.13%)      unlock()
         .               {
         .                 // XXX EINVAL, EAGAIN, EPERM
12,000,018 ( 0.08%)        __gthread_mutex_unlock(&_M_mutex);
180,000,354 ( 1.15%)  => /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:__gthread_mutex_unlock(pthread_mutex_t*) (4,000,006x)
12,000,018 ( 0.08%)      }
         .           
         .               native_handle_type
         .               native_handle() noexcept
         .               { return &_M_mutex; }
         .             };
         .           
         .           #endif // _GLIBCXX_HAS_GTHREADS
         .           
-- line 127 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-sMfBJT/glibc-2.31/libio/genops.c
  /build/glibc-sMfBJT/glibc-2.31/libio/libioP.h
  /build/glibc-sMfBJT/glibc-2.31/libio/strops.c
  /build/glibc-sMfBJT/glibc-2.31/libio/vsnprintf.c
  /build/glibc-sMfBJT/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c
  /build/glibc-sMfBJT/glibc-2.31/nptl/pthread_mutex_unlock.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/../libio/libioP.h
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/_itoa.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/printf-parse.h
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/snprintf.c
  /build/glibc-sMfBJT/glibc-2.31/stdio-common/vfprintf-internal.c
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strchr-avx2.S
  /build/glibc-sMfBJT/glibc-2.31/string/../sysdeps/x86_64/multiarch/strrchr-avx2.S
  /build/glibc-sMfBJT/glibc-2.31/time/../sysdeps/unix/sysv/linux/gettimeofday.c

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
7,122,139,150 (45.62%)  events annotated

